{"version":3,"sources":["../../src/rx-database-internal-store.ts"],"names":["body","recover","result","e","then","ensureStorageTokenExists","rxDatabase","storageTokenDocumentId","getPrimaryKeyOfInternalDocument","STORAGE_TOKEN_DOCUMENT_KEY","INTERNAL_CONTEXT_STORAGE_TOKEN","storageToken","internalStore","document","id","context","key","data","token","_deleted","_meta","_attachments","err","isError","status","useStorageTokenDoc","getAllCollectionDocuments","storageInstance","storage","getAllQueryPrepared","statics","prepareQuery","schema","selector","INTERNAL_CONTEXT_COLLECTION","sort","query","queryResult","allDocs","documents","INTERNAL_CONTEXT_ENCRYPTION","INTERNAL_CONTEXT_REPLICATION_PRIMITIVES","INTERNAL_STORE_SCHEMA","version","primaryKey","fields","separator","type","properties","additionalProperties","indexes","required"],"mappings":"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","sourcesContent":["import { getComposedPrimaryKeyOfDocumentData } from './rx-schema-helper';\nimport { getSingleDocument, writeSingle } from './rx-storage-helper';\nimport type {\n    RxDatabase,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageBulkWriteError,\n    RxStorageInstance\n} from './types';\nimport { getDefaultRxDocumentMeta, randomCouchString } from './util';\n\nexport const INTERNAL_CONTEXT_COLLECTION = 'collection';\nexport const INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\nexport const INTERNAL_CONTEXT_ENCRYPTION = 'plugin-encryption';\nexport const INTERNAL_CONTEXT_REPLICATION_PRIMITIVES = 'plugin-replication-primitives';\n\nexport const INTERNAL_STORE_SCHEMA: RxJsonSchema<InternalStoreDocType<any>> = {\n    version: 0,\n    primaryKey: {\n        key: 'id',\n        fields: [\n            'context',\n            'key'\n        ],\n        separator: '|'\n    },\n    type: 'object',\n    properties: {\n        id: {\n            type: 'string'\n        },\n        key: {\n            type: 'string'\n        },\n        context: {\n            type: 'string',\n            enum: [\n                INTERNAL_CONTEXT_COLLECTION,\n                INTERNAL_CONTEXT_STORAGE_TOKEN,\n                INTERNAL_CONTEXT_ENCRYPTION,\n                INTERNAL_CONTEXT_REPLICATION_PRIMITIVES,\n                'OTHER'\n            ]\n        },\n        data: {\n            type: 'object',\n            additionalProperties: true\n        }\n    },\n    indexes: [],\n    required: [\n        'key',\n        'context',\n        'data'\n    ],\n    additionalProperties: false\n};\n\nexport type InternalStoreDocType<Data = any> = {\n    id: string;\n    key: string;\n    context: string;\n    data: Data;\n}\n\n/**\n * Stores information about the collections.\n * The collection.name is the 'key' value.\n */\nexport type InternalStoreStorageTokenDocType = InternalStoreDocType<{\n    token: string;\n}>;\n\n/**\n * Stores information about the collections.\n * The collection.name is the 'key' value.\n */\nexport type InternalStoreCollectionDocType = InternalStoreDocType<{\n    schema: RxJsonSchema<any>;\n    schemaHash: string;\n    version: number;\n}>;\n\n\nexport function getPrimaryKeyOfInternalDocument(\n    key: string,\n    context: string\n): string {\n    return getComposedPrimaryKeyOfDocumentData<InternalStoreDocType>(\n        INTERNAL_STORE_SCHEMA,\n        {\n            key,\n            context\n        }\n    )\n}\n\n/**\n * Returns all internal documents\n * with context 'collection'\n */\nexport async function getAllCollectionDocuments(\n    storageInstance: RxStorageInstance<InternalStoreDocType<any>, any, any>,\n    storage: RxStorage<any, any>\n): Promise<RxDocumentData<InternalStoreCollectionDocType>[]> {\n    const getAllQueryPrepared = storage.statics.prepareQuery(\n        storageInstance.schema,\n        {\n            selector: {\n                context: INTERNAL_CONTEXT_COLLECTION\n            },\n            sort: [{ id: 'asc' }]\n        }\n    );\n    const queryResult = await storageInstance.query(getAllQueryPrepared);\n    const allDocs = queryResult.documents;\n    return allDocs;\n}\n\n/**\n * to not confuse multiInstance-messages with other databases that have the same\n * name and adapter, but do not share state with this one (for example in-memory-instances),\n * we set a storage-token and use it in the broadcast-channel\n */\nexport const STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\nexport async function ensureStorageTokenExists<Collections = any>(rxDatabase: RxDatabase<Collections>): Promise<string> {\n    const storageTokenDocumentId = getPrimaryKeyOfInternalDocument(\n        STORAGE_TOKEN_DOCUMENT_KEY,\n        INTERNAL_CONTEXT_STORAGE_TOKEN\n    );\n\n    /**\n     * To have less read-write cycles,\n     * we just try to insert a new document\n     * and only fetch the existing one if a conflict happened.\n     */\n    const storageToken = randomCouchString(10);\n    try {\n        await writeSingle<InternalStoreStorageTokenDocType>(\n            rxDatabase.internalStore,\n            {\n                document: {\n                    id: storageTokenDocumentId,\n                    context: INTERNAL_CONTEXT_STORAGE_TOKEN,\n                    key: STORAGE_TOKEN_DOCUMENT_KEY,\n                    data: {\n                        token: storageToken\n                    },\n                    _deleted: false,\n                    _meta: getDefaultRxDocumentMeta(),\n                    _attachments: {}\n                }\n            }\n        );\n        return storageToken;\n    } catch (err: RxStorageBulkWriteError<InternalStoreStorageTokenDocType> | any) {\n        /**\n         * If we get a 409 error,\n         * it means another instance already inserted the storage token.\n         * So we get that token from the database and return that one.\n         */\n        if (\n            err.isError &&\n            (err as RxStorageBulkWriteError<InternalStoreStorageTokenDocType>).status === 409\n        ) {\n            const useStorageTokenDoc = await getSingleDocument<InternalStoreStorageTokenDocType>(\n                rxDatabase.internalStore,\n                storageTokenDocumentId\n            );\n            if (useStorageTokenDoc) {\n                return useStorageTokenDoc.data.token;\n            }\n        }\n        throw err;\n    }\n}\n"],"file":"rx-database-internal-store.js"}
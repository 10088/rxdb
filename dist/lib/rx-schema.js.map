{"version":3,"sources":["../../src/rx-schema.ts"],"names":["RxSchema","jsonSchema","indexes","getIndexes","primaryPath","getPrimaryFieldOfPrimaryKey","primaryKey","finalFields","getFinalFields","required","concat","filter","field","includes","elem","pos","arr","indexOf","validateChange","dataBefore","dataAfter","forEach","fieldName","schema","validate","_obj","_schemaPath","fillObjectWithDefaults","obj","Object","entries","defaultValues","k","hasOwnProperty","v","getDocumentPrototype","proto","getPrimaryOfDocumentData","documentData","getComposedPrimaryKeyOfDocumentData","fillPrimaryKey","cloned","newPrimary","existingPrimary","args","version","normalizeRxJsonSchema","values","normalized","properties","encrypted","length","attachments","map","index","key","compositePrimary","fields","value","objectPath","get","join","separator","getPreviousVersions","c","Array","fill","ret","keys","push","normalizedSchema","from","arIndex","modifiedIndex","slice","RX_META_SCHEMA","type","lwt","minimum","additionalProperties","fillWithDefaultSettings","schemaObj","keyCompression","_rev","minLength","_attachments","_deleted","_meta","createRxSchema","runPreCreateHooks","isInstanceOf","toTypedRxJsonSchema"],"mappings":"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","sourcesContent":["import deepEqual from 'fast-deep-equal';\nimport objectPath from 'object-path';\n\nimport {\n    clone,\n    hash,\n    sortObject,\n    overwriteGetterForCaching,\n    flatClone, isMaybeReadonlyArray\n} from './util';\nimport {\n    newRxError,\n} from './rx-error';\nimport {\n    runPluginHooks\n} from './hooks';\nimport {\n    defineGetterSetter\n} from './rx-document';\n\nimport type {\n    CompositePrimaryKey,\n    DeepMutable,\n    DeepReadonly, JsonSchema, MaybeReadonly,\n    PrimaryKey,\n    RxJsonSchema\n} from './types';\n\nexport class RxSchema<T = any> {\n    public indexes: MaybeReadonly<string[]>[];\n    public primaryPath: keyof T;\n    public finalFields: string[];\n\n    constructor(\n        public readonly jsonSchema: RxJsonSchema<T>\n    ) {\n        this.indexes = getIndexes(this.jsonSchema);\n\n        // primary is always required\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.jsonSchema.primaryKey);\n\n        // final fields are always required\n        this.finalFields = getFinalFields(this.jsonSchema);\n\n        this.jsonSchema.required = (this.jsonSchema as any).required\n            .concat(this.finalFields)\n            .filter((field: string) => !field.includes('.'))\n            .filter((elem: any, pos: any, arr: any) => arr.indexOf(elem) === pos); // unique;\n    }\n\n    public get version(): number {\n        return this.jsonSchema.version;\n    }\n\n    get normalized(): RxJsonSchema<T> {\n        return overwriteGetterForCaching(\n            this,\n            'normalized',\n            normalizeRxJsonSchema(this.jsonSchema)\n        );\n    }\n\n    public get defaultValues(): { [P in keyof T]: T[P] } {\n        const values = {} as { [P in keyof T]: T[P] };\n        Object\n            .entries(this.normalized.properties)\n            .filter(([, v]) => (v as any).hasOwnProperty('default'))\n            .forEach(([k, v]) => (values as any)[k] = (v as any).default);\n        return overwriteGetterForCaching(\n            this,\n            'defaultValues',\n            values\n        );\n    }\n\n    /**\n        * true if schema contains at least one encrypted path\n        */\n    get crypt(): boolean {\n        if (\n            !!this.jsonSchema.encrypted && this.jsonSchema.encrypted.length > 0 ||\n            this.jsonSchema.attachments && this.jsonSchema.attachments.encrypted\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * get all encrypted paths\n     */\n    get encryptedPaths(): string[] {\n        return this.jsonSchema.encrypted || [];\n    }\n\n    /**\n     * @overrides itself on the first call\n     */\n    public get hash(): string {\n        return overwriteGetterForCaching(\n            this,\n            'hash',\n            hash(this.normalized)\n        );\n    }\n\n    /**\n     * checks if a given change on a document is allowed\n     * Ensures that:\n     * - primary is not modified\n     * - final fields are not modified\n     * @throws {Error} if not valid\n     */\n    validateChange(dataBefore: any, dataAfter: any): void {\n        this.finalFields.forEach(fieldName => {\n            if (!deepEqual(dataBefore[fieldName], dataAfter[fieldName])) {\n                throw newRxError('DOC9', {\n                    dataBefore,\n                    dataAfter,\n                    fieldName,\n                    schema: this.jsonSchema\n                });\n            }\n        });\n    }\n\n    /**\n     * validate if the obj matches the schema\n     * @overwritten by plugin (required)\n     * @param schemaPath if given, validates agains deep-path of schema\n     * @throws {Error} if not valid\n     * @param obj equal to input-obj\n     */\n    public validate(_obj: any, _schemaPath?: string): void {\n        /**\n         * This method might be overwritten by a validation plugin,\n         * otherwise do nothing.\n         */\n    }\n\n    /**\n     * fills all unset fields with default-values if set\n     */\n    fillObjectWithDefaults(obj: any): any {\n        obj = flatClone(obj);\n        Object\n            .entries(this.defaultValues)\n            .filter(([k]) => !obj.hasOwnProperty(k) || typeof obj[k] === 'undefined')\n            .forEach(([k, v]) => obj[k] = v);\n        return obj;\n    }\n\n    /**\n     * creates the schema-based document-prototype,\n     * see RxCollection.getDocumentPrototype()\n     */\n    public getDocumentPrototype(): any {\n        const proto = {};\n        defineGetterSetter(this, proto, '');\n        overwriteGetterForCaching(\n            this,\n            'getDocumentPrototype',\n            () => proto\n        );\n        return proto;\n    }\n\n\n    getPrimaryOfDocumentData(\n        documentData: Partial<T>\n    ): string {\n        return getComposedPrimaryKeyOfDocumentData(\n            this.jsonSchema,\n            documentData\n        );\n    }\n\n    fillPrimaryKey(\n        documentData: T\n    ): T {\n        const cloned = flatClone(documentData);\n        const newPrimary = getComposedPrimaryKeyOfDocumentData<T>(\n            this.jsonSchema,\n            documentData\n        );\n        const existingPrimary: string | undefined = documentData[this.primaryPath] as any;\n        if (\n            existingPrimary &&\n            existingPrimary !== newPrimary\n        ) {\n            throw newRxError(\n                'DOC19',\n                {\n                    args: {\n                        documentData,\n                        existingPrimary,\n                        newPrimary,\n                    },\n                    schema: this.jsonSchema\n                });\n        }\n\n        (cloned as any)[this.primaryPath] = newPrimary;\n        return cloned;\n    }\n\n}\n\nexport function getIndexes<T = any>(\n    jsonSchema: RxJsonSchema<T>\n): MaybeReadonly<string[]>[] {\n    return (jsonSchema.indexes || []).map(index => isMaybeReadonlyArray(index) ? index : [index]);\n}\n\nexport function getPrimaryFieldOfPrimaryKey<RxDocType>(\n    primaryKey: PrimaryKey<RxDocType>\n): keyof RxDocType {\n    if (typeof primaryKey === 'string') {\n        return primaryKey as any;\n    } else {\n        return (primaryKey as CompositePrimaryKey<RxDocType>).key;\n    }\n}\n\n/**\n * Returns the composed primaryKey of a document by its data.\n */\nexport function getComposedPrimaryKeyOfDocumentData<RxDocType>(\n    jsonSchema: RxJsonSchema<RxDocType>,\n    documentData: Partial<RxDocType>\n): string {\n    if (typeof jsonSchema.primaryKey === 'string') {\n        return (documentData as any)[jsonSchema.primaryKey];\n    }\n\n    const compositePrimary: CompositePrimaryKey<RxDocType> = jsonSchema.primaryKey as any;\n    return compositePrimary.fields.map(field => {\n        const value = objectPath.get(documentData as any, field as string);\n        if (typeof value === 'undefined') {\n            throw newRxError('DOC18', { args: { field, documentData } });\n        }\n        return value;\n    }).join(compositePrimary.separator);\n}\n\n/**\n * array with previous version-numbers\n */\nexport function getPreviousVersions(schema: RxJsonSchema<any>): number[] {\n    const version = schema.version ? schema.version : 0;\n    let c = 0;\n    return new Array(version)\n        .fill(0)\n        .map(() => c++);\n}\n\n/**\n * returns the final-fields of the schema\n * @return field-names of the final-fields\n */\nexport function getFinalFields<T = any>(\n    jsonSchema: RxJsonSchema<T>\n): string[] {\n    const ret = Object.keys(jsonSchema.properties)\n        .filter(key => (jsonSchema as any).properties[key].final);\n\n    // primary is also final\n    const primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);\n    ret.push(primaryPath as string);\n\n    // fields of composite primary are final\n    if (typeof jsonSchema.primaryKey !== 'string') {\n        (jsonSchema.primaryKey as CompositePrimaryKey<T>).fields\n            .forEach(field => ret.push(field as string));\n    }\n\n    return ret;\n}\n\n/**\n * Normalize the RxJsonSchema.\n * We need this to ensure everything is set up properly\n * and we have the same hash on schemas that represent the same value but\n * have different json.\n * \n * - Orders the schemas attributes by alphabetical order\n * - Adds the primaryKey to all indexes that do not contain the primaryKey\n *   - We need this for determinstic sort order on all queries, which is required for event-reduce to work.\n *\n * @return RxJsonSchema - ordered and filled\n */\nexport function normalizeRxJsonSchema<T>(jsonSchema: RxJsonSchema<T>): RxJsonSchema<T> {\n    const primaryPath: string = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey) as string;\n    const normalizedSchema: RxJsonSchema<T> = sortObject(clone(jsonSchema));\n\n    // indexes must NOT be sorted because sort order is important here.\n    if (jsonSchema.indexes) {\n        normalizedSchema.indexes = Array.from(jsonSchema.indexes);\n    }\n\n    // primaryKey.fields must NOT be sorted because sort order is important here.\n    if (\n        typeof normalizedSchema.primaryKey === 'object' &&\n        typeof jsonSchema.primaryKey === 'object'\n    ) {\n        normalizedSchema.primaryKey.fields = jsonSchema.primaryKey.fields;\n    }\n\n\n    /**\n     * Add primary key to indexes that do not contain primaryKey.\n     */\n    if (normalizedSchema.indexes) {\n        normalizedSchema.indexes = normalizedSchema.indexes.map(index => {\n            const arIndex = isMaybeReadonlyArray(index) ? index : [index];\n            if (!arIndex.includes(primaryPath)) {\n                const modifiedIndex = arIndex.slice(0);\n                modifiedIndex.push(primaryPath);\n                return modifiedIndex;\n            }\n            return arIndex;\n        });\n    }\n\n\n    return normalizedSchema;\n}\n\n\nexport const RX_META_SCHEMA: JsonSchema = {\n    type: 'object',\n    properties: {\n        lwt: {\n            type: 'number',\n            minimum: 1\n        }\n    },\n    /**\n     * Additional properties are allowed\n     * and can be used by plugins to set various flags.\n     */\n    additionalProperties: true as any,\n    required: [\n        'lwt'\n    ]\n}\n\n/**\n * fills the schema-json with default-settings\n * @return cloned schemaObj\n */\nexport function fillWithDefaultSettings<T = any>(\n    schemaObj: RxJsonSchema<T>\n): RxJsonSchema<T> {\n    schemaObj = flatClone(schemaObj);\n    schemaObj.properties = flatClone(schemaObj.properties);\n\n    // additionalProperties is always false\n    schemaObj.additionalProperties = false;\n\n    // fill with key-compression-state ()\n    if (!schemaObj.hasOwnProperty('keyCompression')) {\n        schemaObj.keyCompression = false;\n    }\n\n    // indexes must be array\n    schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];\n\n    // required must be array\n    schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];\n\n    // encrypted must be array\n    schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];\n\n    /**\n     * TODO we should not need to add the internal fields to the schema.\n     * Better remove the fields before validation.\n     */\n    // add _rev\n    (schemaObj.properties as any)._rev = {\n        type: 'string',\n        minLength: 1\n    };\n\n    // add attachments\n    (schemaObj.properties as any)._attachments = {\n        type: 'object'\n    };\n\n    // add deleted flag\n    (schemaObj.properties as any)._deleted = {\n        type: 'boolean'\n    };\n\n    // add meta property\n    (schemaObj.properties as any)._meta = RX_META_SCHEMA;\n\n    // version is 0 by default\n    schemaObj.version = schemaObj.version || 0;\n\n    return schemaObj;\n}\n\nexport function createRxSchema<T>(\n    jsonSchema: RxJsonSchema<T>,\n    runPreCreateHooks = true\n): RxSchema<T> {\n    if (runPreCreateHooks) {\n        runPluginHooks('preCreateRxSchema', jsonSchema);\n    }\n    const schema = new RxSchema(fillWithDefaultSettings(jsonSchema));\n    runPluginHooks('createRxSchema', schema);\n    return schema;\n}\n\nexport function isInstanceOf(obj: any): boolean {\n    return obj instanceof RxSchema;\n}\n\n/**\n * Used as helper function the generate the document type out of the schema via typescript.\n * @link https://github.com/pubkey/rxdb/discussions/3467\n */\nexport function toTypedRxJsonSchema<T extends DeepReadonly<RxJsonSchema<any>>>(schema: T): DeepMutable<T> {\n    return schema as any;\n}\n"],"file":"rx-schema.js"}
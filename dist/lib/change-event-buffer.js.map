{"version":3,"sources":["../../src/change-event-buffer.ts"],"names":[],"mappings":"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","file":"change-event-buffer.js","sourcesContent":["/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\nimport {\n    Subscription\n} from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport type {\n    RxChangeEvent,\n    RxCollection\n} from './types';\n\nexport class ChangeEventBuffer {\n    private subs: Subscription[] = [];\n    public limit: number = 100;\n    public counter: number = 0;\n    private eventCounterMap: WeakMap<\n        RxChangeEvent<any>, number\n    > = new WeakMap();\n\n    /**\n     * array with changeEvents\n     * starts with oldest known event, ends with newest\n     */\n    public buffer: RxChangeEvent<any>[] = [];\n\n    constructor(\n        public collection: RxCollection\n    ) {\n        this.subs.push(\n            this.collection.$.pipe(\n                filter(cE => !cE.isLocal)\n            ).subscribe((cE: any) => this._handleChangeEvent(cE))\n        );\n    }\n\n    _handleChangeEvent(changeEvent: RxChangeEvent<any>) {\n        this.counter++;\n        this.buffer.push(changeEvent);\n        this.eventCounterMap.set(changeEvent, this.counter);\n        while (this.buffer.length > this.limit)\n            this.buffer.shift();\n    }\n\n    /**\n     * gets the array-index for the given pointer\n     * @return arrayIndex which can be used to itterate from there. If null, pointer is out of lower bound\n     */\n    getArrayIndexByPointer(pointer: number): number | null {\n        const oldestEvent = this.buffer[0];\n        const oldestCounter = this.eventCounterMap.get(\n            oldestEvent\n        ) as number;\n\n        if (pointer < oldestCounter)\n            return null; // out of bounds\n\n        const rest = pointer - oldestCounter;\n        return rest;\n    }\n\n    /**\n     * get all changeEvents which came in later than the pointer-event\n     * @return array with change-events. Iif null, pointer out of bounds\n     */\n    getFrom(pointer: number): RxChangeEvent<any>[] | null {\n        const ret = [];\n        let currentIndex = this.getArrayIndexByPointer(pointer);\n        if (currentIndex === null) // out of bounds\n            return null;\n\n        while (true) {\n            const nextEvent = this.buffer[currentIndex];\n            currentIndex++;\n            if (!nextEvent) {\n                return ret;\n            } else {\n                ret.push(nextEvent);\n            }\n        }\n    }\n\n    runFrom(pointer: number, fn: Function) {\n        const ret = this.getFrom(pointer);\n        if (ret === null) {\n            throw new Error('out of bounds');\n        } else {\n            ret.forEach(cE => fn(cE));\n        }\n    }\n\n    /**\n     * no matter how many operations are done on one document,\n     * only the last operation has to be checked to calculate the new state\n     * this function reduces the events to the last ChangeEvent of each doc\n     */\n    reduceByLastOfDoc(changeEvents: RxChangeEvent<any>[]): RxChangeEvent<any>[] {\n        return changeEvents.slice(0);\n        // TODO the old implementation was wrong\n        // because it did not correctly reassigned the previousData of the changeevents\n        // this should be added to the event-reduce library and not be done in RxDB\n        const docEventMap: any = {};\n        changeEvents.forEach(changeEvent => {\n            docEventMap[changeEvent.documentId] = changeEvent;\n        });\n        return Object.values(docEventMap);\n    }\n\n    /**\n     * use this to check if a change has already been handled\n     * @returns true if change with revision exists\n     * TODO only used in the in-memory plugin, we should move it there.\n     *\n     */\n    hasChangeWithRevision(revision: string): boolean {\n        // we loop from behind because its more likely that the searched event is at the end\n        let t = this.buffer.length;\n        while (t > 0) {\n            t--;\n            const cE: any = this.buffer[t];\n            if (cE.documentData && cE.documentData._rev === revision) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    destroy() {\n        this.subs.forEach(sub => sub.unsubscribe());\n    }\n}\n\nexport function createChangeEventBuffer(\n    collection: RxCollection<any, any>\n) {\n    return new ChangeEventBuffer(collection);\n}\n"]}
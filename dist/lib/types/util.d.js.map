{"version":3,"file":"util.d.js","names":[],"sources":["../../../src/types/util.d.ts"],"sourcesContent":["export type MaybePromise<T> = Promise<T> | T;\n\n\nexport type PlainJsonValue = string | number | boolean | PlainSimpleJsonObject | PlainSimpleJsonObject[] | PlainJsonValue[];\nexport type PlainSimpleJsonObject = {\n    [k: string]: PlainJsonValue | PlainJsonValue[];\n};\n\n/**\n * @link https://stackoverflow.com/a/49670389/3443137\n */\ntype DeepReadonly<T> =\n    T extends (infer R)[] ? DeepReadonlyArray<R> :\n    T extends Function ? T :\n    T extends object ? DeepReadonlyObject<T> :\n    T;\n\ninterface DeepReadonlyArray<T> extends ReadonlyArray<DeepReadonly<T>> { }\n\ntype DeepReadonlyObject<T> = {\n    readonly [P in keyof T]: DeepReadonly<T[P]>;\n};\n\nexport type MaybeReadonly<T> = T | Readonly<T>;\n\n\n/**\n * Opposite of DeepReadonly,\n * makes everything mutable again.\n */\ntype DeepMutable<T> = (\n    T extends object\n    ? {\n        -readonly [K in keyof T]: (\n            T[K] extends object\n            ? DeepMutable<T[K]>\n            : T[K]\n        )\n    }\n    : never\n);\n\n/**\n * Can be used like 'keyof'\n * but only represents the string keys, not the Symbols or numbers.\n * @link https://stackoverflow.com/a/51808262/3443137\n */\nexport type StringKeys<X> = Extract<keyof X, string>;\n\n\n/**\n * @link https://dev.to/vborodulin/ts-how-to-override-properties-with-type-intersection-554l\n */\nexport type Override<T1, T2> = Omit<T1, keyof T2> & T2;\n"],"mappings":""}
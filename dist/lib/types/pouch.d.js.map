{"version":3,"file":"pouch.d.js","names":[],"sources":["../../../src/types/pouch.d.ts"],"sourcesContent":["import { MangoQuery, MangoQuerySelector, MangoQuerySortPart } from './rx-query';\n\n/**\n * this file contains types that are pouchdb-specific\n * most of it is copied from @types/pouchdb\n * because it is outdated and strange\n */\n\nexport interface PouchReplicationOptions {\n    live?: boolean;\n    retry?: boolean;\n    filter?: Function;\n    doc_ids?: string[];\n    query_params?: any;\n    view?: any;\n    since?: number | 'now';\n    heartbeat?: number;\n    timeout?: number;\n    batch_size?: number;\n    batches_limit?: number;\n    back_off_function?: Function;\n    checkpoint?: false | 'source' | 'target';\n    include_docs?: boolean;\n    limit?: number;\n}\n\n/**\n * @link https://pouchdb.com/api.html#changes\n */\nexport interface PouchChangesOptionsBase {\n    include_docs?: boolean;\n    conflicts?: boolean;\n    attachments?: boolean;\n    binary?: boolean;\n    descending?: boolean;\n    since?: any;\n    limit?: number;\n    timeout?: any;\n    heartbeat?: number | boolean;\n    filter?: any;\n    doc_ids?: string | string[];\n    query_param?: any;\n    view?: any;\n    return_docs?: boolean;\n    batch_size?: number;\n    style?: string;\n}\n\nexport interface PouchChangesOptionsLive extends PouchChangesOptionsBase {\n    live: true;\n}\n\nexport interface PouchChangesOptionsNonLive extends PouchChangesOptionsBase {\n    live: false;\n}\ninterface PouchChangesOnChangeEvent {\n    on: (eventName: string, handler: Function) => void;\n    off: (eventName: string, handler: Function) => void;\n    cancel(): void;\n}\n\nexport type PouchWriteError = {\n    /**\n      * status code from pouchdb\n      * 409 for 'conflict'\n    */\n    status: number;\n    error: true;\n    /**\n     * primary key value of the errored document\n     */\n    id: string;\n};\n\n/**\n * possible pouch-settings\n * @link https://pouchdb.com/api.html#create_database\n */\nexport interface PouchSettings {\n    auto_compaction?: boolean;\n    revs_limit?: number;\n    ajax?: any;\n    fetch?: any;\n    auth?: any;\n    skip_setup?: boolean;\n    storage?: any;\n    size?: number;\n    location?: string;\n    iosDatabaseLocation?: string;\n}\n\n/**\n * options for pouch.allDocs()\n * @link https://pouchdb.com/api.html#batch_fetch\n */\nexport type PouchAllDocsOptions = {\n    include_docs?: boolean;\n    conflicts?: boolean;\n    attachments?: boolean;\n    binary?: boolean;\n    startkey?: string;\n    endkey?: string;\n    inclusive_end?: boolean;\n    limit?: number;\n    skip?: number;\n    descending?: boolean;\n    key?: string;\n    keys?: string[];\n    update_seq?: string;\n\n    // undocument but needed\n    revs?: boolean;\n    deleted?: 'ok';\n};\n\nexport type PouchSyncHandlerEvents = 'change' | 'paused' | 'active' | 'error' | 'complete';\nexport type PouchSyncHandler = {\n    on(ev: PouchSyncHandlerEvents, fn: (el: any) => void): void;\n    off(ev: PouchSyncHandlerEvents, fn: any): void;\n    cancel(): void;\n};\n\nexport type PouchChangeRow = {\n    id: string;\n    seq: number;\n    deleted?: true;\n    changes: {\n        rev: 'string'\n    }[],\n    /**\n     * only if include_docs === true\n     */\n    doc?: PouchChangeDoc\n}\n\nexport type PouchAttachmentMeta = {\n    digest: string;\n    content_type: string;\n    length: number;\n    stub: boolean;\n\n    /**\n     * 'revpos indicates the generation number (numeric prefix in the revID) at which the attachment was last altered'\n     *  @link https://github.com/couchbase/couchbase-lite-ios/issues/1200#issuecomment-206444554\n     */\n    revpos: number;\n};\n\nexport type BlobBuffer = Buffer | Blob;\n\nexport type PouchAttachmentWithData = PouchAttachmentMeta & {\n    /**\n     * Base64 string with the data\n     * or directly a buffer\n     */\n    data: BlobBuffer;\n    type: string;\n    /**\n     * If set, must be false\n     * because we have the full data and not only a stub.\n     */\n    stub?: false;\n}\n\nexport type PouchChangeDoc = {\n    _id: string;\n    _rev: string;\n    /**\n     * True if the document is deleted.\n     */\n    _deleted?: boolean;\n    _attachments: {\n        [attachmentId: string]: PouchAttachmentMeta\n    };\n}\n\nexport type WithAttachments<Data> = Data & {\n    /**\n     * Intentional optional,\n     * if the document has no attachments,\n     * we do NOT have an empty object.\n     */\n    _attachments?: {\n        [attachmentId: string]: PouchAttachmentMeta\n    };\n}\nexport type WithAttachmentsData<Data> = Data & {\n    /**\n     * Intentional optional,\n     * if the document has no attachments,\n     * we do NOT have an empty object.\n     */\n    _attachments?: {\n        [attachmentId: string]: PouchAttachmentWithData\n    };\n}\n\n\nexport type WithPouchMeta<Data> = Data & {\n    _rev: string;\n    _attachments?: {\n        [attachmentId: string]: PouchAttachmentMeta\n    };\n    _deleted?: boolean;\n}\n\nexport type PouchdbChangesResult = {\n    results: PouchChangeRow[];\n    last_seq: number;\n}\n\ndeclare type Debug = {\n    enable(what: string): void;\n    disable(): void;\n};\n\nexport type PouchDbSorting = (string | string[] | { [k: string]: 'asc' | 'desc' | 1 | -1 })[];\n\n// this is not equal to the standard MangoQuery\n// because of different sorting\nexport type PouchdbQuery = MangoQuery & {\n    sort?: PouchDbSorting\n};\n\nexport type PouchBulkDocResultRow = {\n    ok: boolean;\n    id: string;\n    rev: string;\n}\n\nexport type PouchChangedDocumentsSinceCheckpoint = {\n    sequence: number;\n}\n\nexport type PouchBulkDocOptions = {\n    new_edits?: boolean;\n\n    // custom options for RxDB\n    set_new_edit_as_latest_revision?: boolean;\n    isDeeper?: boolean;\n    custom?: any;\n}\n\nexport type PouchMangoQuery<DocType> = MangoQuery<DocType> & {\n    index: undefined;\n    use_index?: string;\n};\n\nexport type ExplainedPouchQuery<DocType> = {\n    dbname: string;\n    index: {\n        ddoc: string | null;\n        name: string; // 'idx-rxdb-index-age,_id'\n        type: 'json';\n        def: {\n            fields: MangoQuerySortPart<DocType>[];\n        }\n    };\n    selector: MangoQuerySelector<DocType>;\n    range: {\n        start_key: any[];\n        end_key: any[];\n    };\n    opts: {\n        use_index: string[];\n        bookmark: string;\n        sort: MangoQuerySortPart<DocType>[];\n        conflicts: boolean;\n        r: any[];\n    };\n    skip: number;\n}\n\nexport declare class PouchDBInstance {\n    constructor(\n        name: string,\n        options: { adapter: string }\n    );\n    readonly name: string;\n    readonly adapter: string;\n\n    readonly __opts: {\n        db: any | string; // contains the adapter function\n        deterministic_revs: boolean;\n        name: string;\n        adapter: string;\n    };\n\n    static debug: Debug;\n\n    static plugin(p: any): void;\n    static isInstanceOf(instance: any): boolean;\n    info(): Promise<any>;\n\n    allDocs(options?: PouchAllDocsOptions): Promise<{\n        offset: number;\n        rows: {\n            id: string;\n            doc: any;\n            key: string;\n            value: {\n                rev: string;\n                deleted?: boolean;\n            };\n            error?: 'not_found' | string;\n        }[];\n        total_rows: number;\n    }>;\n\n    bulkDocs(\n        docs: { docs: any[] } | any[],\n        options?: PouchBulkDocOptions,\n    ): Promise<(PouchBulkDocResultRow | PouchWriteError)[]>;\n\n\n    find<DocumentData>(mangoQuery: PouchdbQuery): Promise<{\n        docs: WithPouchMeta<DocumentData>[]\n    }>;\n    compact(options?: any): Promise<any>;\n    destroy(options?: any): Promise<void>;\n    get(\n        docId: string,\n        options?: any\n    ): Promise<null | ({\n        _id: string\n    } & any)>;\n    put(\n        doc: any,\n        options?: any,\n    ): Promise<PouchBulkDocResultRow>;\n    remove(\n        doc: any | string,\n        options?: any,\n    ): Promise<any>;\n\n    changes(options: PouchChangesOptionsNonLive): Promise<PouchdbChangesResult>;\n    changes(options: PouchChangesOptionsLive): PouchChangesOnChangeEvent;\n    changes(): Promise<PouchdbChangesResult>;\n\n    sync(remoteDb: string | any, options?: PouchReplicationOptions): PouchSyncHandler;\n    replicate(options?: PouchReplicationOptions): PouchSyncHandler;\n\n    close(): Promise<void>;\n    putAttachment(\n        docId: string,\n        attachmentId: string,\n        rev: string,\n        attachment: any,\n        type: string\n    ): Promise<any>;\n    getAttachment(\n        docId: string,\n        attachmentId: string,\n        options?: { rev?: string },\n    ): Promise<BlobBuffer>;\n    removeAttachment(\n        docId: string,\n        attachmentId: string,\n        rev: string\n    ): Promise<void>;\n\n    /**\n     * @link https://pouchdb.com/api.html#bulk_get\n     */\n    bulkGet(options: {\n        docs: {\n            // ID of the document to fetch\n            id: string;\n            // Revision of the document to fetch. If this is not specified, all available revisions are fetched\n            rev?: string;\n\n            //  I could not find out what this should be\n            atts_since?: any;\n        }[],\n        // Each returned revision body will include its revision history as a _revisions property. Default is false\n        revs?: boolean;\n        // what does this?\n        latest?: boolean;\n        // Include attachment data in the response. Default is false, resulting in only stubs being returned.\n        attachments?: boolean;\n        // Return attachment data as Blobs/Buffers, instead of as base64-encoded strings. Default is false\n        binary?: boolean;\n    }): Promise<{\n        results: {\n            id: string;\n            docs: {\n                ok?: {\n                    _id: string;\n                    _rev: string;\n                    _revisions: {\n                        ids: string[];\n                        start: number;\n                    }\n                }\n                error?: {\n                    error: string;\n                    id: string;\n                    reason: string;\n                    rev: string;\n                }\n            }[]\n        }[]\n    }>;\n\n    revsDiff(diff: any): Promise<any>;\n    explain<DocType = any>(query: PouchMangoQuery<DocType>): Promise<ExplainedPouchQuery<DocType>>;\n\n    getIndexes(): Promise<{\n        indexes: {\n            ddoc: any | null;\n            name: string;\n            type: string;\n            def: {\n                fields: {\n                    [key: string]: 'asc' | 'desc'\n                }[];\n            }\n        }[];\n        total_rows: number;\n    }>;\n\n    createIndex(opts: {\n        name: string;\n        ddoc: string;\n        index: any;\n    }): Promise<void>;\n\n    /**\n     * @link https://pouchdb.com/errors.html#event_emitter_limit\n     */\n    setMaxListeners(maxListenersAmount: number): void;\n    getMaxListeners(): number;\n}\n"],"mappings":""}
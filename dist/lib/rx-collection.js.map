{"version":3,"sources":["../../src/rx-collection.ts"],"names":[],"mappings":"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","file":"rx-collection.js","sourcesContent":["import {\n    filter,\n    startWith,\n    mergeMap,\n    shareReplay,\n    map\n} from 'rxjs/operators';\n\nimport {\n    ucfirst,\n    nextTick,\n    flatClone,\n    promiseSeries,\n    pluginMissing,\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    clone,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_VOID\n} from './util';\nimport {\n    _handleToStorageInstance,\n    _handleFromStorageInstance,\n    fillObjectDataBeforeInsert,\n    writeToStorageInstance,\n    createRxCollectionStorageInstances\n} from './rx-collection-helper';\nimport {\n    createRxQuery,\n    RxQueryBase,\n    _getDefaultQuery\n} from './rx-query';\nimport {\n    newRxError,\n    newRxTypeError\n} from './rx-error';\nimport type {\n    DataMigrator\n} from './plugins/migration';\nimport {\n    Crypter,\n    createCrypter\n} from './crypter';\nimport {\n    DocCache,\n    createDocCache\n} from './doc-cache';\nimport {\n    QueryCache,\n    createQueryCache,\n    defaultCacheReplacementPolicy\n} from './query-cache';\nimport {\n    ChangeEventBuffer,\n    createChangeEventBuffer\n} from './change-event-buffer';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from './hooks';\n\nimport type {\n    Subscription,\n    Observable\n} from 'rxjs';\n\nimport type {\n    KeyFunctionMap,\n    RxCouchDBReplicationState,\n    MigrationState,\n    SyncOptions,\n    RxCollection,\n    RxDatabase,\n    RxQuery,\n    RxDocument,\n    SyncOptionsGraphQL,\n    RxDumpCollection,\n    RxDumpCollectionAny,\n    MangoQuery,\n    MangoQueryNoLimit,\n    RxCacheReplacementPolicy,\n    RxStorageBulkWriteError,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxStorageInstanceCreationParams,\n    RxStorageKeyObjectInstance,\n    BulkWriteRow,\n    RxChangeEvent,\n    RxChangeEventInsert,\n    RxChangeEventUpdate,\n    RxChangeEventDelete,\n    RxStorageInstance,\n    CollectionsOfDatabase\n} from './types';\nimport type {\n    RxGraphQLReplicationState\n} from './plugins/replication-graphql';\n\nimport {\n    RxSchema\n} from './rx-schema';\nimport {\n    createWithConstructor as createRxDocumentWithConstructor,\n    isRxDocument\n} from './rx-document';\n\nimport {\n    createRxDocument,\n    getRxDocumentConstructor\n} from './rx-document-prototype-merge';\nimport { storageChangeEventToRxChangeEvent } from './rx-storage-helper';\nimport { validateDatabaseName } from './plugins/dev-mode/check-names';\nimport { overwritable } from './overwritable';\n\nconst HOOKS_WHEN = ['pre', 'post'];\nconst HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nlet hooksApplied = false;\n\nexport class RxCollectionBase<\n    InstanceCreationOptions,\n    RxDocumentType = { [prop: string]: any },\n    OrmMethods = {},\n    StaticMethods = { [key: string]: any }\n    > {\n\n    constructor(\n        public database: RxDatabase<CollectionsOfDatabase, any, InstanceCreationOptions>,\n        public name: string,\n        public schema: RxSchema<RxDocumentType>,\n        /**\n         * Stores all 'normal' documents\n         */\n        public storageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions>,\n        /**\n         * Stores the local documents so that they are not deleted\n         * when a migration runs.\n         */\n        public localDocumentsStore: RxStorageKeyObjectInstance<any, InstanceCreationOptions>,\n        public instanceCreationOptions: InstanceCreationOptions = {} as any,\n        public migrationStrategies: KeyFunctionMap = {},\n        public methods: KeyFunctionMap = {},\n        public attachments: KeyFunctionMap = {},\n        public options: any = {},\n        public cacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicy,\n        public statics: KeyFunctionMap = {}\n    ) {\n        _applyHookFunctions(this.asRxCollection);\n    }\n\n    /**\n     * returns observable\n     */\n    get $(): Observable<RxChangeEvent<any>> {\n        return this._observable$ as any;\n    }\n    get insert$(): Observable<RxChangeEventInsert<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'INSERT')\n        ) as any;\n    }\n    get update$(): Observable<RxChangeEventUpdate<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'UPDATE')\n        ) as any;\n    }\n    get remove$(): Observable<RxChangeEventDelete<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'DELETE')\n        ) as any;\n    }\n\n    get onDestroy() {\n        if (!this._onDestroy) {\n            this._onDestroy = new Promise(res => this._onDestroyCall = res);\n        }\n        return this._onDestroy;\n    }\n\n    public _isInMemory = false;\n    public destroyed = false;\n    public _atomicUpsertQueues = new Map(); // TODO type\n    // defaults\n    public synced: boolean = false;\n    public hooks: any = {};\n    public _subs: Subscription[] = [];\n\n    // TODO move _repStates into migration plugin\n    public _repStates: Set<RxCouchDBReplicationState> = new Set();\n\n    public _docCache: DocCache<\n        RxDocument<RxDocumentType, OrmMethods>\n    > = createDocCache();\n\n    public _queryCache: QueryCache = createQueryCache();\n    public _crypter: Crypter = {} as Crypter;\n    public _observable$: Observable<RxChangeEvent<RxDocumentType>> = {} as any;\n    public _changeEventBuffer: ChangeEventBuffer = {} as ChangeEventBuffer;\n\n    /**\n     * returns a promise that is resolved when the collection gets destroyed\n     */\n    private _onDestroy?: Promise<void>;\n\n    private _onDestroyCall?: () => void;\n    public async prepare(\n        /**\n         * set to true if the collection data already exists on this storage adapter\n         */\n        wasCreatedBefore: boolean\n    ): Promise<void> {\n        // we trigger the non-blocking things first and await them later so we can do stuff in the mean time\n\n        this._crypter = createCrypter(this.database.password, this.schema);\n\n        this._observable$ = this.database.$.pipe(\n            filter((event: RxChangeEvent<any>) => {\n                return event.collectionName === this.name;\n            })\n        );\n        this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n\n\n        const subDocs = this.storageInstance.changeStream().pipe(\n            map(storageEvent => storageChangeEventToRxChangeEvent(\n                false,\n                storageEvent,\n                this.database,\n                this as any\n            ))\n        ).subscribe(cE => {\n            this.$emit(cE);\n        });\n        this._subs.push(subDocs);\n        const subLocalDocs = this.localDocumentsStore.changeStream().pipe(\n            map(storageEvent => storageChangeEventToRxChangeEvent(\n                true,\n                storageEvent,\n                this.database,\n                this as any\n            ))\n        ).subscribe(cE => this.$emit(cE));\n        this._subs.push(subLocalDocs);\n\n\n        /**\n         * When a write happens to the collection\n         * we find the changed document in the docCache\n         * and tell it that it has to change its data.\n         */\n        this._subs.push(\n            this._observable$\n                .pipe(\n                    filter((cE: RxChangeEvent<RxDocumentType>) => !cE.isLocal)\n                )\n                .subscribe(cE => {\n                    // when data changes, send it to RxDocument in docCache\n                    const doc = this._docCache.get(cE.documentId);\n                    if (doc) {\n                        doc._handleChangeEvent(cE);\n                    }\n                })\n        );\n    }\n\n\n    // overwritte by migration-plugin\n    migrationNeeded(): Promise<boolean> {\n        throw pluginMissing('migration');\n    }\n    getDataMigrator(): DataMigrator {\n        throw pluginMissing('migration');\n    }\n    migrate(batchSize: number = 10): Observable<MigrationState> {\n        return this.getDataMigrator().migrate(batchSize);\n    }\n    migratePromise(batchSize: number = 10): Promise<any> {\n        return this.getDataMigrator().migratePromise(batchSize);\n    }\n\n    /**\n     * wrapps the query function of the storage instance.\n     */\n    async _queryStorageInstance(\n        rxQuery: RxQuery | RxQueryBase,\n        limit?: number,\n        noDecrypt: boolean = false\n    ): Promise<any[]> {\n        const preparedQuery = rxQuery.getPreparedQuery();\n        if (limit) {\n            preparedQuery['limit'] = limit;\n        }\n\n        const queryResult = await this.database.lockedRun(\n            () => this.storageInstance.query(preparedQuery)\n        );\n\n        const docs = queryResult.documents\n            .map((doc: any) => _handleFromStorageInstance(this, doc, noDecrypt));\n        return docs;\n    }\n\n    $emit(changeEvent: RxChangeEvent<any>) {\n        return this.database.$emit(changeEvent);\n    }\n\n\n    /**\n     * TODO internally call bulkInsert\n     * to not have duplicated code.\n     */\n    async insert(\n        json: RxDocumentType | RxDocument\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        // inserting a temporary-document\n        let tempDoc: RxDocument | null = null;\n        if (isRxDocument(json)) {\n            tempDoc = json as RxDocument;\n            if (!tempDoc._isTemporary) {\n                throw newRxError('COL1', {\n                    data: json\n                });\n            }\n            json = tempDoc.toJSON() as any;\n        }\n\n        const useJson: RxDocumentWriteData<RxDocumentType> = fillObjectDataBeforeInsert(this as any, json);\n        let newDoc = tempDoc;\n\n        await this._runHooks('pre', 'insert', useJson);\n        this.schema.validate(useJson);\n        const insertResult = await writeToStorageInstance(\n            this,\n            {\n                document: useJson\n            }\n        );\n\n        if (tempDoc) {\n            tempDoc._dataSync$.next(insertResult);\n        } else {\n            newDoc = createRxDocument(this as any, insertResult);\n        }\n\n        await this._runHooks('post', 'insert', useJson, newDoc);\n\n        return newDoc as any;\n    }\n\n    async bulkInsert(\n        docsData: RxDocumentType[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[],\n        error: RxStorageBulkWriteError<RxDocumentType>[]\n    }> {\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (docsData.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const useDocs: RxDocumentType[] = docsData.map(docData => {\n            const useDocData = fillObjectDataBeforeInsert(this as any, docData);\n            return useDocData;\n        });\n\n        const docs = await Promise.all(\n            useDocs.map(doc => {\n                return this._runHooks('pre', 'insert', doc).then(() => {\n                    this.schema.validate(doc);\n                    return doc;\n                });\n            })\n        );\n\n        const insertDocs: BulkWriteRow<RxDocumentType>[] = docs.map(d => ({\n            document: _handleToStorageInstance(this, d)\n        }));\n        const docsMap: Map<string, RxDocumentType> = new Map();\n        docs.forEach(d => {\n            docsMap.set((d as any)[this.schema.primaryPath] as any, d);\n        });\n\n        const results = await this.database.lockedRun(\n            () => this.storageInstance.bulkWrite(insertDocs)\n        );\n\n        // create documents\n        const successEntries: [string, RxDocumentData<RxDocumentType>][] = Array.from(results.success.entries());\n        const rxDocuments: any[] = successEntries\n            .map(([key, writtenDocData]) => {\n                const docData: RxDocumentData<RxDocumentType> = getFromMapOrThrow(docsMap, key) as any;\n                docData._rev = writtenDocData._rev;\n                const doc = createRxDocument(this as any, docData);\n                return doc;\n            });\n\n\n        await Promise.all(\n            rxDocuments.map(doc => {\n                return this._runHooks(\n                    'post',\n                    'insert',\n                    docsMap.get(doc.primary),\n                    doc\n                );\n            })\n        );\n\n        return {\n            success: rxDocuments,\n            error: Array.from(results.error.values())\n        };\n    }\n\n    async bulkRemove(\n        ids: string[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[],\n        error: RxStorageBulkWriteError<RxDocumentType>[]\n    }> {\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (ids.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const rxDocumentMap = await this.findByIds(ids);\n        const docsData: RxDocumentData<RxDocumentType>[] = [];\n        const docsMap: Map<string, RxDocumentData<RxDocumentType>> = new Map();\n        Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n            const data: RxDocumentData<RxDocumentType> = clone(rxDocument.toJSON(true)) as any;\n            docsData.push(data);\n            docsMap.set(rxDocument.primary, data);\n        });\n\n        await Promise.all(\n            docsData.map(doc => {\n                const primary = (doc as any)[this.schema.primaryPath];\n                return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n            })\n        );\n\n\n        const removeDocs: BulkWriteRow<RxDocumentType>[] = docsData.map(doc => {\n            const writeDoc = flatClone(doc);\n            writeDoc._deleted = true;\n            return {\n                previous: _handleToStorageInstance(this, doc),\n                document: _handleToStorageInstance(this, writeDoc)\n            };\n        });\n\n        const results = await this.database.lockedRun(\n            () => this.storageInstance.bulkWrite(removeDocs)\n        );\n\n        const successIds: string[] = Array.from(results.success.keys());\n\n        // run hooks\n        await Promise.all(\n            successIds.map(id => {\n                return this._runHooks(\n                    'post',\n                    'remove',\n                    docsMap.get(id),\n                    rxDocumentMap.get(id)\n                );\n            })\n        );\n\n        const rxDocuments: any[] = successIds.map(id => {\n            return rxDocumentMap.get(id);\n        });\n\n        return {\n            success: rxDocuments,\n            error: Array.from(results.error.values())\n        };\n    }\n\n    /**\n     * same as insert but overwrites existing document with same primary\n     */\n    upsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const useJson = fillObjectDataBeforeInsert(this as any, json);\n        const primary = useJson[this.schema.primaryPath];\n        if (!primary) {\n            throw newRxError('COL3', {\n                primaryPath: this.schema.primaryPath as string,\n                data: useJson,\n                schema: this.schema.jsonSchema\n            });\n        }\n\n        return this.findOne(primary).exec()\n            .then((existing: RxDocument<RxDocumentType, OrmMethods> | null) => {\n                if (existing && !existing.deleted) {\n                    useJson._rev = (existing as any)['_rev'];\n                    return existing.atomicUpdate(() => useJson as any)\n                        .then(() => existing);\n                } else {\n                    return this.insert(json as any);\n                }\n            });\n    }\n\n    /**\n     * upserts to a RxDocument, uses atomicUpdate if document already exists\n     */\n    atomicUpsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const useJson = fillObjectDataBeforeInsert(this as any, json);\n        const primary = useJson[this.schema.primaryPath];\n        if (!primary) {\n            throw newRxError('COL4', {\n                data: json\n            });\n        }\n\n        // ensure that it wont try 2 parallel runs\n        let queue;\n        if (!this._atomicUpsertQueues.has(primary)) {\n            queue = PROMISE_RESOLVE_VOID;\n        } else {\n            queue = this._atomicUpsertQueues.get(primary);\n        }\n        queue = queue\n            .then(() => _atomicUpsertEnsureRxDocumentExists(this as any, primary as any, useJson))\n            .then((wasInserted: any) => {\n                if (!wasInserted.inserted) {\n                    return _atomicUpsertUpdate(wasInserted.doc, useJson)\n                        /**\n                         * tick here so the event can propagate\n                         * TODO we should not need that here\n                         */\n                        .then(() => nextTick())\n                        .then(() => nextTick())\n                        .then(() => nextTick())\n                        .then(() => wasInserted.doc);\n                } else {\n                    return wasInserted.doc;\n                }\n            });\n        this._atomicUpsertQueues.set(primary, queue);\n        return queue;\n    }\n\n    find(queryObj?: MangoQuery<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>[]\n    > {\n        if (typeof queryObj === 'string') {\n            throw newRxError('COL5', {\n                queryObj\n            });\n        }\n\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n\n        const query = createRxQuery('find', queryObj, this as any);\n        return query as any;\n    }\n\n    findOne(queryObj?: MangoQueryNoLimit<RxDocumentType> | string): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>\n        | null\n    > {\n        let query;\n\n        if (typeof queryObj === 'string') {\n            query = createRxQuery('findOne', {\n                selector: {\n                    [this.schema.primaryPath]: queryObj\n                }\n            }, this as any);\n        } else {\n            if (!queryObj) {\n                queryObj = _getDefaultQuery();\n            }\n\n            // cannot have limit on findOne queries\n            if ((queryObj as MangoQuery).limit) {\n                throw newRxError('QU6');\n            }\n\n            query = createRxQuery('findOne', queryObj, this as any);\n        }\n\n        if (\n            typeof queryObj === 'number' ||\n            Array.isArray(queryObj)\n        ) {\n            throw newRxTypeError('COL6', {\n                queryObj\n            });\n        }\n\n        return query as any;\n    }\n\n    /**\n     * find a list documents by their primary key\n     * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n     */\n    async findByIds(\n        ids: string[]\n    ): Promise<Map<string, RxDocument<RxDocumentType, OrmMethods>>> {\n\n        const ret = new Map();\n        const mustBeQueried: string[] = [];\n\n        // first try to fill from docCache\n        ids.forEach(id => {\n            const doc = this._docCache.get(id);\n            if (doc) {\n                ret.set(id, doc);\n            } else {\n                mustBeQueried.push(id);\n            }\n        });\n\n        // find everything which was not in docCache\n        if (mustBeQueried.length > 0) {\n            const docs = await this.storageInstance.findDocumentsById(mustBeQueried, false);\n            Array.from(docs.values()).forEach(docData => {\n                docData = _handleFromStorageInstance(this, docData);\n                const doc = createRxDocument<RxDocumentType, OrmMethods>(this as any, docData);\n                ret.set(doc.primary, doc);\n            });\n        }\n        return ret;\n    }\n\n    /**\n     * like this.findByIds but returns an observable\n     * that always emitts the current state\n     */\n    findByIds$(\n        ids: string[]\n    ): Observable<Map<string, RxDocument<RxDocumentType, OrmMethods>>> {\n        let currentValue: Map<string, RxDocument<RxDocumentType, OrmMethods>> | null = null;\n        let lastChangeEvent: number = -1;\n\n        const initialPromise = this.findByIds(ids).then(docsMap => {\n            lastChangeEvent = this._changeEventBuffer.counter;\n            currentValue = docsMap;\n        });\n        return this.$.pipe(\n            startWith(null),\n            mergeMap(ev => initialPromise.then(() => ev)),\n            /**\n             * Because shareReplay with refCount: true\n             * will often subscribe/unsusbscribe\n             * we always ensure that we handled all missed events\n             * since the last subscription.\n             */\n            mergeMap(async (ev) => {\n                const resultMap = ensureNotFalsy(currentValue);\n                const missedChangeEvents = this._changeEventBuffer.getFrom(lastChangeEvent + 1);\n                if (missedChangeEvents === null) {\n                    /**\n                     * changeEventBuffer is of bounds -> we must re-execute over the database\n                     * because we cannot calculate the new results just from the events.\n                     */\n                    const newResult = await this.findByIds(ids);\n                    lastChangeEvent = this._changeEventBuffer.counter;\n                    Array.from(newResult.entries()).forEach(([k, v]) => resultMap.set(k, v));\n                } else {\n                    missedChangeEvents\n                        .filter(rxChangeEvent => ids.includes(rxChangeEvent.documentId))\n                        .forEach(rxChangeEvent => {\n                            const op = rxChangeEvent.operation;\n                            if (op === 'INSERT' || op === 'UPDATE') {\n                                resultMap.set(rxChangeEvent.documentId, this._docCache.get(rxChangeEvent.documentId) as any);\n                            } else {\n                                resultMap.delete(rxChangeEvent.documentId);\n                            }\n                        });\n                }\n                return resultMap;\n            }),\n            filter(x => !!x),\n            shareReplay({\n                bufferSize: 1,\n                refCount: true\n            })\n        );\n    }\n\n    /**\n     * Export collection to a JSON friendly format.\n     * @param _decrypted\n     * When true, all encrypted values will be decrypted.\n     * When false or omitted and an interface or type is loaded in this collection,\n     * all base properties of the type are typed as `any` since data could be encrypted.\n     */\n    exportJSON(_decrypted: boolean): Promise<RxDumpCollection<RxDocumentType>>;\n    exportJSON(_decrypted?: false): Promise<RxDumpCollectionAny<RxDocumentType>>;\n    exportJSON(_decrypted: boolean = false): Promise<any> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * Import the parsed JSON export into the collection.\n     * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n     */\n    importJSON(_exportedJSON: RxDumpCollectionAny<RxDocumentType>): Promise<void> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * sync with a CouchDB endpoint\n     */\n    syncCouchDB(_syncOptions: SyncOptions): RxCouchDBReplicationState {\n        throw pluginMissing('replication');\n    }\n\n    /**\n     * sync with a GraphQL endpoint\n     */\n    syncGraphQL(options: SyncOptionsGraphQL<RxDocumentType>): RxGraphQLReplicationState<RxDocumentType> {\n        throw pluginMissing('replication-graphql');\n    }\n\n    /**\n     * Create a replicated in-memory-collection\n     */\n    inMemory(): Promise<RxCollection<RxDocumentType, OrmMethods>> {\n        throw pluginMissing('in-memory');\n    }\n\n\n    /**\n     * HOOKS\n     */\n    addHook(when: string, key: string, fun: any, parallel = false) {\n        if (typeof fun !== 'function') {\n            throw newRxTypeError('COL7', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_WHEN.includes(when)) {\n            throw newRxTypeError('COL8', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_KEYS.includes(key)) {\n            throw newRxError('COL9', {\n                key\n            });\n        }\n\n        if (when === 'post' && key === 'create' && parallel === true) {\n            throw newRxError('COL10', {\n                when,\n                key,\n                parallel\n            });\n        }\n\n        // bind this-scope to hook-function\n        const boundFun = fun.bind(this);\n\n        const runName = parallel ? 'parallel' : 'series';\n\n        this.hooks[key] = this.hooks[key] || {};\n        this.hooks[key][when] = this.hooks[key][when] || {\n            series: [],\n            parallel: []\n        };\n        this.hooks[key][when][runName].push(boundFun);\n    }\n    getHooks(when: string, key: string) {\n        try {\n            return this.hooks[key][when];\n        } catch (e) {\n            return {\n                series: [],\n                parallel: []\n            };\n        }\n    }\n\n    _runHooks(when: string, key: string, data: any, instance?: any): Promise<any> {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) {\n            return PROMISE_RESOLVE_VOID;\n        }\n\n        // run parallel: false\n        const tasks = hooks.series.map((hook: any) => () => hook(data, instance));\n        return promiseSeries(tasks)\n            // run parallel: true\n            .then(() => Promise.all(\n                hooks.parallel\n                    .map((hook: any) => hook(data, instance))\n            ));\n    }\n\n    /**\n     * does the same as ._runHooks() but with non-async-functions\n     */\n    _runHooksSync(when: string, key: string, data: any, instance: any) {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) return;\n        hooks.series.forEach((hook: any) => hook(data, instance));\n    }\n\n    /**\n     * creates a temporaryDocument which can be saved later\n     */\n    newDocument(docData: Partial<RxDocumentType> = {}): RxDocument<RxDocumentType, OrmMethods> {\n        docData = this.schema.fillObjectWithDefaults(docData);\n        const doc: any = createRxDocumentWithConstructor(\n            getRxDocumentConstructor(this as any),\n            this as any,\n            docData\n        );\n        doc._isTemporary = true;\n\n        this._runHooksSync('post', 'create', docData, doc);\n        return doc as any;\n    }\n\n    destroy(): Promise<boolean> {\n        if (this.destroyed) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n        if (this._onDestroyCall) {\n            this._onDestroyCall();\n        }\n        this._subs.forEach(sub => sub.unsubscribe());\n        if (this._changeEventBuffer) {\n            this._changeEventBuffer.destroy();\n        }\n        Array.from(this._repStates).forEach(replicationState => replicationState.cancel());\n\n        return Promise\n            .all([\n                this.storageInstance.close(),\n                this.localDocumentsStore.close()\n            ])\n            .then(() => {\n                delete this.database.collections[this.name];\n                this.destroyed = true;\n                return runAsyncPluginHooks('postDestroyRxCollection', this).then(() => true);\n            });\n    }\n\n    /**\n     * remove all data of the collection\n     */\n    remove(): Promise<any> {\n        return this.database.removeCollection(this.name);\n    }\n\n    get asRxCollection(): RxCollection<RxDocumentType, OrmMethods, StaticMethods> {\n        return this as any;\n    }\n}\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(\n    collection: RxCollection<any, any>\n) {\n    if (hooksApplied) return; // already run\n    hooksApplied = true;\n    const colProto = Object.getPrototypeOf(collection);\n    HOOKS_KEYS.forEach(key => {\n        HOOKS_WHEN.map(when => {\n            const fnName = when + ucfirst(key);\n            colProto[fnName] = function (fun: string, parallel: boolean) {\n                return this.addHook(when, key, fun, parallel);\n            };\n        });\n    });\n}\n\nfunction _atomicUpsertUpdate(doc: any, json: any): Promise<any> {\n    return doc.atomicUpdate((innerDoc: any) => {\n        json._rev = innerDoc._rev;\n        innerDoc._data = json;\n        return innerDoc._data;\n    }).then(() => doc);\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _atomicUpsertEnsureRxDocumentExists(\n    rxCollection: RxCollection,\n    primary: string,\n    json: any\n): Promise<\n    {\n        doc: RxDocument,\n        inserted: boolean\n    }\n> {\n    /**\n     * Optimisation shortcut,\n     * first try to find the document in the doc-cache\n     */\n    const docFromCache = rxCollection._docCache.get(primary);\n    if (docFromCache) {\n        return Promise.resolve({\n            doc: docFromCache,\n            inserted: false\n        });\n    }\n    return rxCollection.findOne(primary).exec()\n        .then(doc => {\n            if (!doc) {\n                return rxCollection.insert(json).then(newDoc => ({\n                    doc: newDoc,\n                    inserted: true\n                }));\n            } else {\n                return {\n                    doc,\n                    inserted: false\n                };\n            }\n        });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection(\n    {\n        database,\n        name,\n        schema,\n        instanceCreationOptions = {},\n        migrationStrategies = {},\n        autoMigrate = true,\n        statics = {},\n        methods = {},\n        attachments = {},\n        options = {},\n        cacheReplacementPolicy = defaultCacheReplacementPolicy\n    }: any,\n    wasCreatedBefore: boolean\n): Promise<RxCollection> {\n    validateDatabaseName(name);\n\n    // TODO move this check to dev-mode plugin\n    if (overwritable.isDevMode()) {\n        Object.keys(methods)\n            .filter(funName => schema.topLevelFields.includes(funName))\n            .forEach(funName => {\n                throw newRxError('COL18', {\n                    funName\n                });\n            });\n    }\n\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseName: database.name,\n        collectionName: name,\n        schema: schema.jsonSchema,\n        options: instanceCreationOptions\n    };\n\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    return createRxCollectionStorageInstances(\n        name,\n        database,\n        storageInstanceCreationParams,\n        instanceCreationOptions\n    ).then(storageInstances => {\n        const collection = new RxCollectionBase(\n            database,\n            name,\n            schema,\n            storageInstances.storageInstance,\n            storageInstances.localDocumentsStore,\n            instanceCreationOptions,\n            migrationStrategies,\n            methods,\n            attachments,\n            options,\n            cacheReplacementPolicy,\n            statics\n        );\n\n        return collection\n            .prepare(wasCreatedBefore)\n            .then(() => {\n                // ORM add statics\n                Object\n                    .entries(statics)\n                    .forEach(([funName, fun]) => {\n                        Object.defineProperty(collection, funName, {\n                            get: () => (fun as any).bind(collection)\n                        });\n                    });\n\n                let ret = PROMISE_RESOLVE_VOID;\n                if (autoMigrate && collection.schema.version !== 0) {\n                    ret = collection.migratePromise();\n                }\n                return ret;\n            })\n            .then(() => {\n                runPluginHooks('createRxCollection', collection);\n                return collection as any;\n            })\n            /**\n             * If the collection creation fails,\n             * we yet have to close the storage instances.\n             */\n            .catch(err => {\n                return Promise\n                    .all([\n                        storageInstances.storageInstance.close(),\n                        storageInstances.localDocumentsStore.close()\n                    ])\n                    .then(() => Promise.reject(err));\n            });\n    });\n}\n\nexport function isRxCollection(obj: any): boolean {\n    return obj instanceof RxCollectionBase;\n}\n"]}
{"version":3,"file":"rx-collection.js","names":["HOOKS_WHEN","HOOKS_KEYS","hooksApplied","RxCollectionBase","database","name","schema","internalStorageInstance","instanceCreationOptions","migrationStrategies","methods","attachments","options","cacheReplacementPolicy","defaultCacheReplacementPolicy","statics","storageInstance","timeouts","Set","destroyed","_atomicUpsertQueues","Map","synced","hooks","_subs","_docCache","DocCache","_queryCache","createQueryCache","$","_changeEventBuffer","_applyHookFunctions","asRxCollection","prepare","getWrappedStorageInstance","jsonSchema","eventBulks$","pipe","filter","changeEventBulk","collectionName","mergeMap","events","createChangeEventBuffer","storageToken","databaseStorageToken","subDocs","changeStream","subscribe","eventBulk","id","internal","map","ev","storageChangeEventToRxChangeEvent","databaseToken","token","$emit","push","cE","isLocal","doc","get","documentId","_handleChangeEvent","PROMISE_RESOLVE_VOID","migrationNeeded","pluginMissing","getDataMigrator","migrate","batchSize","migratePromise","insert","json","tempDoc","isRxDocument","_isTemporary","newRxError","data","toJSON","useJson","fillObjectDataBeforeInsert","bulkInsert","writeResult","isError","error","throwIfIsStorageWriteError","primaryPath","insertResult","ensureNotFalsy","success","_dataSync$","next","_data","docsData","length","useDocs","docData","useDocData","Promise","all","_runHooks","then","validate","docs","docsMap","insertRows","set","Object","assign","_attachments","_meta","getDefaultRxDocumentMeta","_rev","getDefaultRevision","_deleted","createRevision","row","document","bulkWrite","results","successEntries","entries","rxDocuments","key","writtenDocData","getFromMapOrThrow","createRxDocument","primary","values","bulkRemove","ids","findByIds","rxDocumentMap","Array","from","forEach","rxDocument","clone","removeDocs","writeDoc","flatClone","previous","successIds","keys","bulkUpsert","insertData","useJsonByDocId","ret","slice","writeData","docDataInDb","documentInDb","atomicUpdate","updatedDocs","concat","upsert","result","atomicUpsert","queue","_atomicUpsertEnsureRxDocumentExists","wasInserted","inserted","_atomicUpsertUpdate","find","queryObj","_getDefaultQuery","query","createRxQuery","findOne","selector","limit","isArray","newRxTypeError","mustBeQueried","findDocumentsById","findByIds$","currentValue","lastChangeEvent","initialPromise","counter","firstEmitDone","startWith","changeEvent","includes","missedChangeEvents","getFrom","newResult","resultHasChanged","rxChangeEvent","docId","op","operation","documentData","has","x","shareReplay","RXJS_SHARE_REPLAY_DEFAULTS","exportJSON","importJSON","_exportedJSON","syncCouchDB","_syncOptions","syncGraphQL","_options","addHook","when","fun","parallel","boundFun","bind","runName","series","getHooks","e","instance","tasks","hook","promiseSeries","_runHooksSync","newDocument","filledDocData","fillObjectWithDefaults","createRxDocumentWithConstructor","getRxDocumentConstructor","promiseWait","time","res","timeout","setTimeout","add","destroy","PROMISE_RESOLVE_FALSE","_onDestroyCall","clearTimeout","sub","unsubscribe","requestIdlePromise","close","collections","runAsyncPluginHooks","remove","removeCollection","_onDestroy","collection","colProto","getPrototypeOf","fnName","ucfirst","_innerDoc","nextTick","rxCollection","docFromCache","resolve","exec","newDoc","createRxCollection","autoMigrate","localDocuments","storageInstanceCreationParams","databaseName","multiInstance","runPluginHooks","createRxCollectionStorageInstance","funName","defineProperty","version","creator","err","reject","isRxCollection","obj"],"sources":["../../src/rx-collection.ts"],"sourcesContent":["import {\n    filter,\n    startWith,\n    mergeMap,\n    shareReplay\n} from 'rxjs/operators';\n\nimport {\n    ucfirst,\n    flatClone,\n    promiseSeries,\n    pluginMissing,\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    clone,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_VOID,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    getDefaultRxDocumentMeta,\n    getDefaultRevision,\n    nextTick,\n    createRevision\n} from './util';\nimport {\n    fillObjectDataBeforeInsert,\n    createRxCollectionStorageInstance\n} from './rx-collection-helper';\nimport {\n    createRxQuery,\n    _getDefaultQuery\n} from './rx-query';\nimport {\n    newRxError,\n    newRxTypeError\n} from './rx-error';\nimport type {\n    DataMigrator\n} from './plugins/migration';\nimport {\n    DocCache\n} from './doc-cache';\nimport {\n    QueryCache,\n    createQueryCache,\n    defaultCacheReplacementPolicy\n} from './query-cache';\nimport {\n    ChangeEventBuffer,\n    createChangeEventBuffer\n} from './change-event-buffer';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from './hooks';\n\nimport {\n    Subscription,\n    Observable\n} from 'rxjs';\n\nimport type {\n    KeyFunctionMap,\n    RxCouchDBReplicationState,\n    MigrationState,\n    SyncOptions,\n    RxCollection,\n    RxDatabase,\n    RxQuery,\n    RxDocument,\n    SyncOptionsGraphQL,\n    RxDumpCollection,\n    RxDumpCollectionAny,\n    MangoQuery,\n    MangoQueryNoLimit,\n    RxCacheReplacementPolicy,\n    RxStorageBulkWriteError,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxStorageInstanceCreationParams,\n    BulkWriteRow,\n    RxChangeEvent,\n    RxChangeEventInsert,\n    RxChangeEventUpdate,\n    RxChangeEventDelete,\n    RxStorageInstance,\n    CollectionsOfDatabase,\n    RxChangeEventBulk,\n    RxLocalDocumentData,\n    RxDocumentBase\n} from './types';\nimport type {\n    RxGraphQLReplicationState\n} from './plugins/replication-graphql';\n\nimport {\n    RxSchema\n} from './rx-schema';\nimport {\n    createWithConstructor as createRxDocumentWithConstructor,\n    isRxDocument\n} from './rx-document';\n\nimport {\n    createRxDocument,\n    getRxDocumentConstructor\n} from './rx-document-prototype-merge';\nimport {\n    getWrappedStorageInstance,\n    storageChangeEventToRxChangeEvent,\n    throwIfIsStorageWriteError\n} from './rx-storage-helper';\n\nconst HOOKS_WHEN = ['pre', 'post'];\nconst HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nlet hooksApplied = false;\n\nexport class RxCollectionBase<\n    InstanceCreationOptions,\n    RxDocumentType = { [prop: string]: any },\n    OrmMethods = {},\n    StaticMethods = { [key: string]: any }\n    > {\n\n\n    /**\n     * Stores all 'normal' documents\n     */\n    public storageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions> = {} as any;\n    public readonly timeouts: Set<ReturnType<typeof setTimeout>> = new Set();\n\n    constructor(\n        public database: RxDatabase<CollectionsOfDatabase, any, InstanceCreationOptions>,\n        public name: string,\n        public schema: RxSchema<RxDocumentType>,\n        public internalStorageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions>,\n        public instanceCreationOptions: InstanceCreationOptions = {} as any,\n        public migrationStrategies: KeyFunctionMap = {},\n        public methods: KeyFunctionMap = {},\n        public attachments: KeyFunctionMap = {},\n        public options: any = {},\n        public cacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicy,\n        public statics: KeyFunctionMap = {}\n    ) {\n        _applyHookFunctions(this.asRxCollection);\n    }\n\n    get insert$(): Observable<RxChangeEventInsert<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'INSERT')\n        ) as any;\n    }\n    get update$(): Observable<RxChangeEventUpdate<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'UPDATE')\n        ) as any;\n    }\n    get remove$(): Observable<RxChangeEventDelete<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'DELETE')\n        ) as any;\n    }\n\n    get onDestroy() {\n        if (!this._onDestroy) {\n            this._onDestroy = new Promise(res => this._onDestroyCall = res);\n        }\n        return this._onDestroy;\n    }\n\n    public destroyed = false;\n    public _atomicUpsertQueues: Map<string, Promise<any>> = new Map();\n    // defaults\n    public synced: boolean = false;\n    public hooks: any = {};\n    public _subs: Subscription[] = [];\n\n    public _docCache: DocCache<\n        RxDocument<RxDocumentType, OrmMethods>\n    > = new DocCache();\n\n    public _queryCache: QueryCache = createQueryCache();\n    public $: Observable<RxChangeEvent<RxDocumentType>> = {} as any;\n    public _changeEventBuffer: ChangeEventBuffer = {} as ChangeEventBuffer;\n\n    /**\n     * returns a promise that is resolved when the collection gets destroyed\n     */\n    private _onDestroy?: Promise<void>;\n\n    private _onDestroyCall?: () => void;\n    public async prepare(): Promise<void> {\n        this.storageInstance = getWrappedStorageInstance(\n            this.database,\n            this.internalStorageInstance,\n            this.schema.jsonSchema\n        );\n\n        this.$ = this.database.eventBulks$.pipe(\n            filter(changeEventBulk => changeEventBulk.collectionName === this.name),\n            mergeMap(changeEventBulk => changeEventBulk.events),\n        );\n        this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n\n\n        /**\n         * Instead of resolving the EventBulk array here and spit it into\n         * single events, we should fully work with event bulks internally\n         * to save performance.\n         */\n        const databaseStorageToken = await this.database.storageToken;\n        const subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n            const changeEventBulk: RxChangeEventBulk<RxDocumentType | RxLocalDocumentData> = {\n                id: eventBulk.id,\n                internal: false,\n                collectionName: this.name,\n                storageToken: databaseStorageToken,\n                events: eventBulk.events.map(ev => storageChangeEventToRxChangeEvent(\n                    false,\n                    ev,\n                    this as any\n                )),\n                databaseToken: this.database.token\n            };\n            this.database.$emit(changeEventBulk);\n        });\n        this._subs.push(subDocs);\n\n        /**\n         * When a write happens to the collection\n         * we find the changed document in the docCache\n         * and tell it that it has to change its data.\n         */\n        this._subs.push(\n            this.$\n                .pipe(\n                    filter((cE: RxChangeEvent<RxDocumentType>) => !cE.isLocal)\n                )\n                .subscribe(cE => {\n                    // when data changes, send it to RxDocument in docCache\n                    const doc = this._docCache.get(cE.documentId);\n                    if (doc) {\n                        doc._handleChangeEvent(cE);\n                    }\n                })\n        );\n\n        return PROMISE_RESOLVE_VOID;\n    }\n\n\n    // overwritte by migration-plugin\n    migrationNeeded(): Promise<boolean> {\n        throw pluginMissing('migration');\n    }\n    getDataMigrator(): DataMigrator {\n        throw pluginMissing('migration');\n    }\n    migrate(batchSize: number = 10): Observable<MigrationState> {\n        return this.getDataMigrator().migrate(batchSize);\n    }\n    migratePromise(batchSize: number = 10): Promise<any> {\n        return this.getDataMigrator().migratePromise(batchSize);\n    }\n\n    async insert(\n        json: RxDocumentType | RxDocument\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        // inserting a temporary-document\n        let tempDoc: RxDocument | null = null;\n        if (isRxDocument(json)) {\n            tempDoc = json as RxDocument;\n            if (!tempDoc._isTemporary) {\n                throw newRxError('COL1', {\n                    data: json\n                });\n            }\n            json = tempDoc.toJSON() as any;\n        }\n\n        const useJson: RxDocumentWriteData<RxDocumentType> = fillObjectDataBeforeInsert(this.schema, json);\n        const writeResult = await this.bulkInsert([useJson]);\n\n        const isError = writeResult.error[0];\n        throwIfIsStorageWriteError(this as any, useJson[this.schema.primaryPath] as any, json, isError);\n        const insertResult = ensureNotFalsy(writeResult.success[0]);\n\n        if (tempDoc) {\n            tempDoc._dataSync$.next(insertResult._data);\n            return tempDoc as any;\n        } else {\n            return insertResult;\n        }\n    }\n\n    async bulkInsert(\n        docsData: RxDocumentType[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[],\n        error: RxStorageBulkWriteError<RxDocumentType>[]\n    }> {\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (docsData.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const useDocs: RxDocumentType[] = docsData.map(docData => {\n            const useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n            return useDocData;\n        });\n        const docs = await Promise.all(\n            useDocs.map(doc => {\n                return this._runHooks('pre', 'insert', doc).then(() => {\n                    this.schema.validate(doc);\n                    return doc;\n                });\n            })\n        );\n\n        const docsMap: Map<string, RxDocumentType> = new Map();\n        const insertRows: BulkWriteRow<RxDocumentType>[] = docs.map(doc => {\n            docsMap.set((doc as any)[this.schema.primaryPath] as any, doc);\n            const docData = Object.assign(doc, {\n                _attachments: {},\n                _meta: getDefaultRxDocumentMeta(),\n                _rev: getDefaultRevision(),\n                _deleted: false\n            });\n            docData._rev = createRevision(docData);\n            const row: BulkWriteRow<RxDocumentType> = { document: docData };\n            return row;\n        });\n\n        const results = await this.storageInstance.bulkWrite(insertRows);\n\n        // create documents\n        const successEntries: [string, RxDocumentData<RxDocumentType>][] = Object.entries(results.success);\n        const rxDocuments: any[] = successEntries\n            .map(([key, writtenDocData]) => {\n                const docData: RxDocumentData<RxDocumentType> = getFromMapOrThrow(docsMap, key) as any;\n                docData._rev = writtenDocData._rev;\n\n                const doc = createRxDocument(this as any, docData);\n                return doc;\n            });\n\n\n        await Promise.all(\n            rxDocuments.map(doc => {\n                return this._runHooks(\n                    'post', 'insert',\n                    docsMap.get(doc.primary),\n                    doc\n                );\n            })\n        );\n\n        return {\n            success: rxDocuments,\n            error: Object.values(results.error)\n        };\n    }\n\n    async bulkRemove(\n        ids: string[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[],\n        error: RxStorageBulkWriteError<RxDocumentType>[]\n    }> {\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (ids.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const rxDocumentMap = await this.findByIds(ids);\n        const docsData: RxDocumentData<RxDocumentType>[] = [];\n        const docsMap: Map<string, RxDocumentData<RxDocumentType>> = new Map();\n        Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n            const data: RxDocumentData<RxDocumentType> = clone(rxDocument.toJSON(true)) as any;\n            docsData.push(data);\n            docsMap.set(rxDocument.primary, data);\n        });\n\n        await Promise.all(\n            docsData.map(doc => {\n                const primary = (doc as any)[this.schema.primaryPath];\n                return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n            })\n        );\n\n\n        const removeDocs: BulkWriteRow<RxDocumentType>[] = docsData.map(doc => {\n            const writeDoc = flatClone(doc);\n            writeDoc._deleted = true;\n            writeDoc._rev = createRevision(writeDoc, doc);\n            return {\n                previous: doc,\n                document: writeDoc\n            };\n        });\n        const results = await this.storageInstance.bulkWrite(removeDocs);\n\n        const successIds: string[] = Object.keys(results.success);\n\n        // run hooks\n        await Promise.all(\n            successIds.map(id => {\n                return this._runHooks(\n                    'post',\n                    'remove',\n                    docsMap.get(id),\n                    rxDocumentMap.get(id)\n                );\n            })\n        );\n\n        const rxDocuments: any[] = successIds.map(id => {\n            return rxDocumentMap.get(id);\n        });\n\n        return {\n            success: rxDocuments,\n            error: Object.values(results.error)\n        };\n    }\n\n    /**\n     * same as bulkInsert but overwrites existing document with same primary\n     */\n    async bulkUpsert(docsData: Partial<RxDocumentType>[]): Promise<RxDocument<RxDocumentType, OrmMethods>[]> {\n        const insertData: RxDocumentType[] = [];\n        const useJsonByDocId: Map<string, RxDocumentType> = new Map();\n        docsData.forEach(docData => {\n            const useJson = fillObjectDataBeforeInsert(this.schema, docData);\n            const primary: string = useJson[this.schema.primaryPath] as any;\n            if (!primary) {\n                throw newRxError('COL3', {\n                    primaryPath: this.schema.primaryPath as string,\n                    data: useJson,\n                    schema: this.schema.jsonSchema\n                });\n            }\n            useJsonByDocId.set(primary, useJson);\n            insertData.push(useJson);\n        });\n\n        const insertResult = await this.bulkInsert(insertData);\n        let ret = insertResult.success.slice(0);\n        const updatedDocs = await Promise.all(\n            insertResult.error.map(error => {\n                const id = error.documentId;\n                const writeData = getFromMapOrThrow(useJsonByDocId, id);\n                const docDataInDb = ensureNotFalsy(error.documentInDb);\n                const doc = createRxDocument(this.asRxCollection, docDataInDb);\n                return doc.atomicUpdate(() => writeData);\n            })\n        );\n        ret = ret.concat(updatedDocs);\n        return ret;\n    }\n\n    /**\n     * same as insert but overwrites existing document with same primary\n     */\n    upsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        return this.bulkUpsert([json]).then(result => result[0]);\n    }\n\n    /**\n     * upserts to a RxDocument, uses atomicUpdate if document already exists\n     */\n    atomicUpsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const useJson = fillObjectDataBeforeInsert(this.schema, json);\n        const primary: string = useJson[this.schema.primaryPath] as any;\n        if (!primary) {\n            throw newRxError('COL4', {\n                data: json\n            });\n        }\n\n        // ensure that it wont try 2 parallel runs\n        let queue = this._atomicUpsertQueues.get(primary);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue\n            .then(() => _atomicUpsertEnsureRxDocumentExists(this as any, primary as any, useJson))\n            .then((wasInserted) => {\n                if (!wasInserted.inserted) {\n                    return _atomicUpsertUpdate(wasInserted.doc, useJson)\n                        .then(() => wasInserted.doc);\n                } else {\n                    return wasInserted.doc;\n                }\n            });\n        this._atomicUpsertQueues.set(primary, queue);\n        return queue;\n    }\n\n    find(queryObj?: MangoQuery<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>[]\n    > {\n        if (typeof queryObj === 'string') {\n            throw newRxError('COL5', {\n                queryObj\n            });\n        }\n\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n\n        const query = createRxQuery('find', queryObj, this as any);\n        return query as any;\n    }\n\n    findOne(queryObj?: MangoQueryNoLimit<RxDocumentType> | string): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>\n        | null\n    > {\n        let query;\n\n        if (typeof queryObj === 'string') {\n            query = createRxQuery('findOne', {\n                selector: {\n                    [this.schema.primaryPath]: queryObj\n                },\n                limit: 1\n            }, this as any);\n        } else {\n            if (!queryObj) {\n                queryObj = _getDefaultQuery();\n            }\n\n            // cannot have limit on findOne queries because it will be overwritte\n            if ((queryObj as MangoQuery).limit) {\n                throw newRxError('QU6');\n            }\n\n            (queryObj as any).limit = 1;\n            query = createRxQuery('findOne', queryObj, this as any);\n        }\n\n        if (\n            typeof queryObj === 'number' ||\n            Array.isArray(queryObj)\n        ) {\n            throw newRxTypeError('COL6', {\n                queryObj\n            });\n        }\n\n        return query as any;\n    }\n\n    /**\n     * find a list documents by their primary key\n     * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n     */\n    async findByIds(\n        ids: string[]\n    ): Promise<Map<string, RxDocument<RxDocumentType, OrmMethods>>> {\n\n        const ret = new Map();\n        const mustBeQueried: string[] = [];\n\n        // first try to fill from docCache\n        ids.forEach(id => {\n            const doc = this._docCache.get(id);\n            if (doc) {\n                ret.set(id, doc);\n            } else {\n                mustBeQueried.push(id);\n            }\n        });\n\n        // find everything which was not in docCache\n        if (mustBeQueried.length > 0) {\n            const docs = await this.storageInstance.findDocumentsById(mustBeQueried, false);\n            Object.values(docs).forEach(docData => {\n                const doc = createRxDocument<RxDocumentType, OrmMethods>(this as any, docData);\n                ret.set(doc.primary, doc);\n            });\n        }\n        return ret;\n    }\n\n    /**\n     * like this.findByIds but returns an observable\n     * that always emits the current state\n     */\n    findByIds$(\n        ids: string[]\n    ): Observable<Map<string, RxDocument<RxDocumentType, OrmMethods>>> {\n        let currentValue: Map<string, RxDocument<RxDocumentType, OrmMethods>> | null = null;\n        let lastChangeEvent: number = -1;\n\n        /**\n         * Ensure we do not process events in parallel\n         */\n        let queue: Promise<any> = PROMISE_RESOLVE_VOID;\n\n        const initialPromise = this.findByIds(ids).then(docsMap => {\n            lastChangeEvent = this._changeEventBuffer.counter;\n            currentValue = docsMap;\n        });\n        let firstEmitDone = false;\n\n        return this.$.pipe(\n            startWith(null),\n            /**\n             * Optimization shortcut.\n             * Do not proceed if the emited RxChangeEvent\n             * is not relevant for the query.\n             */\n            filter(changeEvent => {\n                if (\n                    // first emit has no event\n                    changeEvent &&\n                    (\n                        // local documents are not relevant for the query\n                        changeEvent.isLocal ||\n                        // document of the change is not in the ids list.\n                        !ids.includes(changeEvent.documentId)\n                    )\n                ) {\n                    return false;\n                } else {\n                    return true;\n                }\n            }),\n            mergeMap(() => initialPromise),\n            /**\n             * Because shareReplay with refCount: true\n             * will often subscribe/unsusbscribe\n             * we always ensure that we handled all missed events\n             * since the last subscription.\n             */\n            mergeMap(() => {\n                queue = queue.then(async () => {\n                    /**\n                     * We first have to clone the Map\n                     * to ensure we do not create side effects by mutating\n                     * a Map that has already been returned before.\n                     */\n                    currentValue = new Map(ensureNotFalsy(currentValue));\n                    const missedChangeEvents = this._changeEventBuffer.getFrom(lastChangeEvent + 1);\n                    lastChangeEvent = this._changeEventBuffer.counter;\n                    if (missedChangeEvents === null) {\n                        /**\n                         * changeEventBuffer is of bounds -> we must re-execute over the database\n                         * because we cannot calculate the new results just from the events.\n                         */\n                        const newResult = await this.findByIds(ids);\n                        lastChangeEvent = this._changeEventBuffer.counter;\n                        return newResult;\n                    } else {\n                        let resultHasChanged = false;\n                        missedChangeEvents\n                            .forEach(rxChangeEvent => {\n                                const docId = rxChangeEvent.documentId;\n                                if (!ids.includes(docId)) {\n                                    // document is not relevant for the result set\n                                    return;\n                                }\n                                const op = rxChangeEvent.operation;\n                                if (op === 'INSERT' || op === 'UPDATE') {\n                                    resultHasChanged = true;\n                                    const rxDocument = createRxDocument(\n                                        this.asRxCollection,\n                                        rxChangeEvent.documentData\n                                    );\n                                    ensureNotFalsy(currentValue).set(docId, rxDocument);\n                                } else {\n                                    if (ensureNotFalsy(currentValue).has(docId)) {\n                                        resultHasChanged = true;\n                                        ensureNotFalsy(currentValue).delete(docId);\n                                    }\n                                }\n                            });\n\n                        // nothing happened that affects the result -> do not emit\n                        if (!resultHasChanged && firstEmitDone) {\n                            return false as any;\n                        }\n                    }\n                    firstEmitDone = true;\n                    return currentValue;\n                });\n                return queue;\n            }),\n            filter(x => !!x),\n            shareReplay(RXJS_SHARE_REPLAY_DEFAULTS)\n        );\n    }\n\n    /**\n     * Export collection to a JSON friendly format.\n     * @param _decrypted\n     * When true, all encrypted values will be decrypted.\n     * When false or omitted and an interface or type is loaded in this collection,\n     * all base properties of the type are typed as `any` since data could be encrypted.\n     */\n    exportJSON(): Promise<RxDumpCollection<RxDocumentType>>;\n    exportJSON(): Promise<RxDumpCollectionAny<RxDocumentType>>;\n    exportJSON(): Promise<any> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * Import the parsed JSON export into the collection.\n     * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n     */\n    importJSON(_exportedJSON: RxDumpCollectionAny<RxDocumentType>): Promise<void> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * sync with a CouchDB endpoint\n     */\n    syncCouchDB(_syncOptions: SyncOptions): RxCouchDBReplicationState {\n        throw pluginMissing('replication');\n    }\n\n    /**\n     * sync with a GraphQL endpoint\n     */\n    syncGraphQL(_options: SyncOptionsGraphQL<RxDocumentType>): RxGraphQLReplicationState<RxDocumentType> {\n        throw pluginMissing('replication-graphql');\n    }\n\n    /**\n     * HOOKS\n     */\n    addHook(when: string, key: string, fun: any, parallel = false) {\n        if (typeof fun !== 'function') {\n            throw newRxTypeError('COL7', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_WHEN.includes(when)) {\n            throw newRxTypeError('COL8', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_KEYS.includes(key)) {\n            throw newRxError('COL9', {\n                key\n            });\n        }\n\n        if (when === 'post' && key === 'create' && parallel === true) {\n            throw newRxError('COL10', {\n                when,\n                key,\n                parallel\n            });\n        }\n\n        // bind this-scope to hook-function\n        const boundFun = fun.bind(this);\n\n        const runName = parallel ? 'parallel' : 'series';\n\n        this.hooks[key] = this.hooks[key] || {};\n        this.hooks[key][when] = this.hooks[key][when] || {\n            series: [],\n            parallel: []\n        };\n        this.hooks[key][when][runName].push(boundFun);\n    }\n\n    getHooks(when: string, key: string) {\n        try {\n            return this.hooks[key][when];\n        } catch (e) {\n            return {\n                series: [],\n                parallel: []\n            };\n        }\n    }\n\n    _runHooks(when: string, key: string, data: any, instance?: any): Promise<any> {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) {\n            return PROMISE_RESOLVE_VOID;\n        }\n\n        // run parallel: false\n        const tasks = hooks.series.map((hook: any) => () => hook(data, instance));\n        return promiseSeries(tasks)\n            // run parallel: true\n            .then(() => Promise.all(\n                hooks.parallel\n                    .map((hook: any) => hook(data, instance))\n            ));\n    }\n\n    /**\n     * does the same as ._runHooks() but with non-async-functions\n     */\n    _runHooksSync(when: string, key: string, data: any, instance: any) {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) return;\n        hooks.series.forEach((hook: any) => hook(data, instance));\n    }\n\n    /**\n     * creates a temporaryDocument which can be saved later\n     */\n    newDocument(docData: Partial<RxDocumentType> = {}): RxDocument<RxDocumentType, OrmMethods> {\n        const filledDocData: RxDocumentData<RxDocumentType> = this.schema.fillObjectWithDefaults(docData);\n        const doc: any = createRxDocumentWithConstructor(\n            getRxDocumentConstructor(this as any),\n            this as any,\n            filledDocData\n        );\n        doc._isTemporary = true;\n\n        this._runHooksSync('post', 'create', docData, doc);\n        return doc as any;\n    }\n\n    /**\n     * Returns a promise that resolves after the given time.\n     * Ensures that is properly cleans up when the collection is destroyed\n     * so that no running timeouts prevent the exit of the JavaScript process.\n     */\n    promiseWait(time: number): Promise<void> {\n        const ret = new Promise<void>(res => {\n            const timeout = setTimeout(() => {\n                this.timeouts.delete(timeout);\n                res();\n            }, time);\n            this.timeouts.add(timeout);\n        });\n        return ret;\n    }\n\n    async destroy(): Promise<boolean> {\n        if (this.destroyed) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        /**\n         * Settings destroyed = true\n         * must be the first thing to do,\n         * so for example the replication can directly stop\n         * instead of sending requests to a closed storage.\n         */\n        this.destroyed = true;\n\n        if (this._onDestroyCall) {\n            this._onDestroyCall();\n        }\n        Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n        this._subs.forEach(sub => sub.unsubscribe());\n        if (this._changeEventBuffer) {\n            this._changeEventBuffer.destroy();\n        }\n        /**\n         * First wait until the whole database is idle.\n         * This ensures that the storage does not get closed\n         * while some operation is running.\n         * It is important that we do not intercept a running call\n         * because it might lead to undefined behavior like when a doc is written\n         * but the change is not added to the changes collection.\n         */\n        return this.database.requestIdlePromise()\n            .then(() => this.storageInstance.close())\n            .then(() => {\n                delete this.database.collections[this.name];\n                return runAsyncPluginHooks('postDestroyRxCollection', this).then(() => true);\n            });\n    }\n\n    /**\n     * remove all data of the collection\n     */\n    remove(): Promise<any> {\n        return this.database.removeCollection(this.name);\n    }\n\n    get asRxCollection(): RxCollection<RxDocumentType, OrmMethods, StaticMethods> {\n        return this as any;\n    }\n}\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(\n    collection: RxCollection<any, any>\n) {\n    if (hooksApplied) return; // already run\n    hooksApplied = true;\n    const colProto = Object.getPrototypeOf(collection);\n    HOOKS_KEYS.forEach(key => {\n        HOOKS_WHEN.map(when => {\n            const fnName = when + ucfirst(key);\n            colProto[fnName] = function (fun: string, parallel: boolean) {\n                return this.addHook(when, key, fun, parallel);\n            };\n        });\n    });\n}\n\nfunction _atomicUpsertUpdate<RxDocType>(\n    doc: RxDocumentBase<RxDocType>,\n    json: RxDocumentData<RxDocType>\n): Promise<RxDocumentBase<RxDocType>> {\n    return doc.atomicUpdate((_innerDoc: RxDocumentData<RxDocType>) => {\n        return json;\n    })\n        .then(() => nextTick())\n        .then(() => {\n            return doc;\n        });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _atomicUpsertEnsureRxDocumentExists(\n    rxCollection: RxCollection,\n    primary: string,\n    json: any\n): Promise<\n    {\n        doc: RxDocument,\n        inserted: boolean\n    }\n> {\n    /**\n     * Optimisation shortcut,\n     * first try to find the document in the doc-cache\n     */\n    const docFromCache = rxCollection._docCache.get(primary);\n    if (docFromCache) {\n        return Promise.resolve({\n            doc: docFromCache,\n            inserted: false\n        });\n    }\n    return rxCollection.findOne(primary).exec()\n        .then(doc => {\n            if (!doc) {\n                return rxCollection.insert(json).then(newDoc => ({\n                    doc: newDoc,\n                    inserted: true\n                }));\n            } else {\n                return {\n                    doc,\n                    inserted: false\n                };\n            }\n        });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection(\n    {\n        database,\n        name,\n        schema,\n        instanceCreationOptions = {},\n        migrationStrategies = {},\n        autoMigrate = true,\n        statics = {},\n        methods = {},\n        attachments = {},\n        options = {},\n        localDocuments = false,\n        cacheReplacementPolicy = defaultCacheReplacementPolicy\n    }: any\n): Promise<RxCollection> {\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseName: database.name,\n        collectionName: name,\n        schema: schema.jsonSchema,\n        options: instanceCreationOptions,\n        multiInstance: database.multiInstance\n    };\n\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    return createRxCollectionStorageInstance(\n        database,\n        storageInstanceCreationParams\n    ).then(storageInstance => {\n        const collection = new RxCollectionBase(\n            database,\n            name,\n            schema,\n            storageInstance,\n            instanceCreationOptions,\n            migrationStrategies,\n            methods,\n            attachments,\n            options,\n            cacheReplacementPolicy,\n            statics\n        );\n\n        return collection\n            .prepare()\n            .then(() => {\n                // ORM add statics\n                Object\n                    .entries(statics)\n                    .forEach(([funName, fun]) => {\n                        Object.defineProperty(collection, funName, {\n                            get: () => (fun as any).bind(collection)\n                        });\n                    });\n\n                let ret = PROMISE_RESOLVE_VOID;\n                if (autoMigrate && collection.schema.version !== 0) {\n                    ret = collection.migratePromise();\n                }\n                return ret;\n            })\n            .then(() => {\n                runPluginHooks('createRxCollection', {\n                    collection,\n                    creator: {\n                        name,\n                        schema,\n                        storageInstance,\n                        instanceCreationOptions,\n                        migrationStrategies,\n                        methods,\n                        attachments,\n                        options,\n                        cacheReplacementPolicy,\n                        localDocuments,\n                        statics\n                    }\n                });\n                return collection as any;\n            })\n            /**\n             * If the collection creation fails,\n             * we yet have to close the storage instances.\n             */\n            .catch(err => {\n                return storageInstance.close()\n                    .then(() => Promise.reject(err));\n            });\n    });\n}\n\nexport function isRxCollection(obj: any): boolean {\n    return obj instanceof RxCollectionBase;\n}\n"],"mappings":"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"}
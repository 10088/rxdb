{"version":3,"sources":["../../src/rx-query.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;;AACA;;AAKA;;AAMA;;AAWA;;AAIA;;AAgBA;;AAGA;;AACA;;AAEA;;AAEA,IAAI,WAAW,GAAG,CAAlB;;AACA,IAAM,UAAU,GAAG,SAAb,UAAa,GAAoB;AACnC,SAAO,EAAE,WAAT;AACH,CAFD;;IAIa,W;AAQT;AACJ;AACA;AAKI;AAKA;AAGA,uBACW,EADX,EAEW,UAFX,EAGW,UAHX,EAIE;AAAA,SArBK,EAqBL,GArBkB,UAAU,EAqB5B;AAAA,SAhBK,sBAgBL,GAhBsC,CAgBtC;AAAA,SAfK,aAeL,GAfqB,gBAerB;AAAA,SAdK,gBAcL,GAdwB,CAcxB;AAAA,SAXK,KAWL,GAXkB,EAWlB;AAAA,SATK,QASL,GATgB,KAShB;AAAA,SANK,SAML,GANiB,IAAI,qBAAJ,CAAoB,IAApB,CAMjB;AAAA,SAkEK,kBAlEL,GAkEuC,CAAC,CAlExC;AAAA,SAqEK,YArEL,GAqEyB,IArEzB;AAAA,SAsEK,eAtEL,GAsEoD,IAAI,GAAJ,EAtEpD;AAAA,SA0EK,cA1EL,GA0E8B,CA1E9B;AAAA,SA2EK,YA3EL,GA2E4B,CA3E5B;AAAA,SA8EK,aA9EL,GA8E2C,IAAI,qBAAJ,CAAoB,IAApB,CA9E3C;AAAA,SAoFK,iBApFL,GAoF2C,2BApF3C;AAAA,SAHS,EAGT,GAHS,EAGT;AAAA,SAFS,UAET,GAFS,UAET;AAAA,SADS,UACT,GADS,UACT;;AACE,QAAI,CAAC,UAAL,EAAiB;AACb,MAAA,UAAU,GAAG,gBAAgB,EAA7B;AACH;AACJ;;;;AA2FD;AACJ;AACA;AACA;SACI,c,GAAA,wBAAe,aAAf,EAAmD;AAAA;;AAC/C,QAAM,IAAI,GAAG,iDACT,KAAK,UADI,EAET,aAFS,CAAb;AAKA;AACR;AACA;AACA;AACA;;AACQ,QAAM,QAAQ,GAAG,KAAK,UAAL,CAAgB,MAAhB,CAAuB,WAAxC;AACA,SAAK,eAAL,GAAuB,IAAI,GAAJ,EAAvB;AACA,SAAK,YAAL,GAAoB,IAAI,CAAC,GAAL,CAAS,UAAA,GAAG,EAAI;AAChC,UAAM,OAAuB,GAAG,GAAG,CAAC,UAAJ,CAAe,QAAf,EAAhC;;AACA,UAAM,EAAU,GAAG,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAA,KAAI,CAAC,eAAL,CAAqB,GAArB,CAAyB,EAAzB,EAA6B,OAA7B;;AACA,aAAO,OAAP;AACH,KALmB,CAApB;;AAQA,SAAK,aAAL,CAAmB,IAAnB,CAAwB,IAAxB;;AACA,WAAO,IAAP;AACH;AAED;AACJ;AACA;AACA;;;SACI,iB,GAAA,6BAAoC;AAAA;;AAChC,SAAK,sBAAL,GAA8B,KAAK,sBAAL,GAA8B,CAA5D;AACA,SAAK,cAAL,GAAsB,gBAAtB;AAEA,QAAI,WAAJ;;AACA,YAAQ,KAAK,EAAb;AACI,WAAK,MAAL;AACI,QAAA,WAAW,GAAG,KAAK,UAAL,CAAgB,qBAAhB,CAAsC,IAAtC,CAAd;AACA;;AACJ,WAAK,SAAL;AACI,QAAA,WAAW,GAAG,KAAK,UAAL,CAAgB,qBAAhB,CAAsC,IAAtC,EAAmD,CAAnD,CAAd;AACA;;AACJ;AACI,cAAM,yBAAW,KAAX,EAAkB;AACpB,UAAA,UAAU,EAAE,KAAK,UAAL,CAAgB,IADR;AAEpB,UAAA,EAAE,EAAE,KAAK;AAFW,SAAlB,CAAN;AARR;;AAcA,WAAO,WAAW,CAAC,IAAZ,CAAiB,UAAA,IAAI,EAAI;AAC5B,MAAA,MAAI,CAAC,YAAL,GAAoB,gBAApB;AACA,aAAO,IAAP;AACH,KAHM,CAAP;AAIH;AAED;AACJ;AACA;AACA;AACA;;;SAGW,I,GAAP,cAAY,cAAZ,EAAoD;AAAA;;AAChD;AACA,QAAI,cAAc,IAAI,KAAK,EAAL,KAAY,SAAlC,EAA6C;AACzC,YAAM,yBAAW,KAAX,EAAkB;AACpB,QAAA,UAAU,EAAE,KAAK,UAAL,CAAgB,IADR;AAEpB,QAAA,KAAK,EAAE,KAAK,UAFQ;AAGpB,QAAA,EAAE,EAAE,KAAK;AAHW,OAAlB,CAAN;AAKH;AAED;AACR;AACA;AACA;AACA;;;AACQ,WAAO,YAAY,CAAC,IAAD,CAAZ,CACF,IADE,CACG;AAAA,aAAM,0BAAe,MAAI,CAAC,CAApB,CAAN;AAAA,KADH,EAEF,IAFE,CAEG,UAAA,MAAM,EAAI;AACZ,UAAI,CAAC,MAAD,IAAW,cAAf,EAA+B;AAC3B,cAAM,yBAAW,MAAX,EAAmB;AACrB,UAAA,UAAU,EAAE,MAAI,CAAC,UAAL,CAAgB,IADP;AAErB,UAAA,KAAK,EAAE,MAAI,CAAC,UAFS;AAGrB,UAAA,EAAE,EAAE,MAAI,CAAC;AAHY,SAAnB,CAAN;AAKH,OAND,MAMO;AACH,eAAO,MAAP;AACH;AACJ,KAZE,CAAP;AAaH;AAID;AACJ;AACA;AACA;;;AAWI;AACJ;AACA;AACA;SACI,Q,GAAA,oBAAmB;AACf,QAAM,SAAS,GAAG,sBAAW;AACzB,MAAA,EAAE,EAAE,KAAK,EADgB;AAEzB,MAAA,KAAK,EAAE,KAAK,UAFa;AAGzB,MAAA,KAAK,EAAE,KAAK;AAHa,KAAX,EAIf,IAJe,CAAlB;AAKA,QAAM,KAAK,GAAG,IAAI,CAAC,SAAL,CAAe,SAAf,EAA0B,qBAA1B,CAAd;;AACA,SAAK,QAAL,GAAgB;AAAA,aAAM,KAAN;AAAA,KAAhB;;AACA,WAAO,KAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;SACI,gB,GAAA,4BAAkD;AAC9C,QAAM,SAAS,GAAG;AACd,MAAA,OAAO,EAAE,IADK;AAEd;AACA,MAAA,UAAU,EAAE,iBAAM,KAAK,UAAX;AAHE,KAAlB;AAKA,+BAAe,iBAAf,EAAkC,SAAlC;AAEA,QAAM,KAAK,GAAG,KAAK,UAAL,CAAgB,eAAhB,CAAgC,YAAhC,CACV,SAAS,CAAC,UADA,CAAd;;AAGA,SAAK,gBAAL,GAAwB;AAAA,aAAM,KAAN;AAAA,KAAxB;;AACA,WAAO,KAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;SACI,qB,GAAA,+BAAsB,OAAtB,EAA8D;AAC1D;AACA,QAAI,OAAO,CAAC,QAAZ,EAAsB;AAClB,aAAO,KAAP;AACH;;AAED,WAAO,KAAK,YAAL,CACH,kDAAyB,KAAK,UAA9B,EAA0C,OAA1C,CADG,CAAP;AAGH;AAED;AACJ;AACA;AACA;;;SACI,M,GAAA,kBAAiC;AAC7B,QAAI,GAAJ;AACA,WAAO,KACF,IADE,GAEF,IAFE,CAEG,UAAA,IAAI,EAAI;AACV,MAAA,GAAG,GAAG,IAAN;;AACA,UAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACrB,eAAO,OAAO,CAAC,GAAR,CAAY,IAAI,CAAC,GAAL,CAAS,UAAA,GAAG;AAAA,iBAAI,GAAG,CAAC,MAAJ,EAAJ;AAAA,SAAZ,CAAZ,CAAP;AACH,OAFD,MAEO;AACH,eAAQ,IAAD,CAAc,MAAd,EAAP;AACH;AACJ,KATE,EAUF,IAVE,CAUG;AAAA,aAAM,GAAN;AAAA,KAVH,CAAP;AAWH;AAGD;AACJ;AACA;;;AAKI;AACJ;AACA;AACA;SACI,M,GAAA,gBAAO,UAAP,EAAgD;AAC5C,UAAM,yBAAc,QAAd,CAAN;AACH,G,CAGD;AACA;;;SACA,K,GAAA,eAAM,SAAN,EAA6H;AACzH,UAAM,yBAAc,eAAd,CAAN;AACH,G;;SACD,I,GAAA,cAAK,OAAL,EAAmG;AAC/F,UAAM,yBAAc,eAAd,CAAN;AACH,G;;SACD,I,GAAA,cAAK,OAAL,EAAqE;AACjE,UAAM,yBAAc,eAAd,CAAN;AACH,G;;SACD,K,GAAA,eAAM,OAAN,EAAsE;AAClE,UAAM,yBAAc,eAAd,CAAN;AACH,G;;;;SA7SD,eAAwC;AAAA;;AACpC,UAAI,CAAC,KAAK,EAAV,EAAc;AACV;AACZ;AACA;AACA;AACY,YAAM,QAAQ,GAAI,KAAK,aAAN,CACZ,IADY,CAET,yBAAS,UAAC,IAAD,EAAiB;AACtB,iBAAO,YAAY,CAAC,MAAD,CAAZ,CACF,IADE,CACG,UAAC,UAAD,EAAqB;AACvB,gBAAI,UAAJ,EAAgB;AACZ;AACA,qBAAO,KAAP;AACH,aAHD,MAGO;AACH,qBAAO,IAAP;AACH;AACJ,WARE,CAAP;AASH,SAVD,CAFS,EAaT,uBAAO,UAAC,IAAD;AAAA,iBAAiB,CAAC,CAAC,IAAnB;AAAA,SAAP,CAbS,EAawB;AACjC,4BAAI,UAAC,IAAD,EAAiB;AACjB,cAAI,MAAI,CAAC,EAAL,KAAY,SAAhB,EAA2B;AACvB;AACA,gBAAM,GAAG,GAAG,IAAI,CAAC,MAAL,KAAgB,CAAhB,GAAoB,IAApB,GAA2B,IAAI,CAAC,CAAD,CAA3C;AACA,mBAAO,GAAP;AACH,WAJD,MAIO;AACH;AACA,mBAAO,IAAP;AACH;AACJ,SATD,CAdS,EAwBT,oBAAI,UAAA,IAAI,EAAI;AACR;AACA,cAAM,GAAG,GAAG,KAAK,CAAC,OAAN,CAAc,IAAd,IAAsB,IAAI,CAAC,KAAL,EAAtB,GAAqC,IAAjD;AACA,iBAAO,GAAP;AACH,SAJD,CAxBS,EA6BX,YA7BW,EAAjB;AA+BA;AACZ;AACA;;;AACY,YAAM,aAAa,GAAG,KAAK,UAAL,CAAgB,CAAhB,CACjB,IADiB,CAEd,oBAAI;AAAA,iBAAM,YAAY,CAAC,MAAD,CAAlB;AAAA,SAAJ,CAFc,EAGd,uBAAO;AAAA,iBAAM,KAAN;AAAA,SAAP,CAHc,CAAtB;AAMA,aAAK,EAAL,GACI;AACA,yBACI,QADJ,EAEI,aAFJ,EAGI,KAAK,SAAL,CAAe,IAAf,CACI,uBAAO;AAAA,iBAAM,KAAN;AAAA,SAAP,CADJ,CAHJ,CAFJ;AASH;;AACD,aAAO,KAAK,EAAZ;AACH,K,CAGD;;;;SAmIA,eAAsE;AAClE,aAAO,qCACH,IADG,EAEH,cAFG,EAGH,KAAK,UAAL,CAAgB,eAAhB,CAAgC,eAAhC,CACI,KAAK,gBAAL,EADJ,CAHG,CAAP;AAOH;;;SA4ED,eAAwD;AACpD,aAAO,IAAP;AACH;;;;;;;AA2BE,SAAS,gBAAT,GAAwC;AAC3C,SAAO;AACH,IAAA,QAAQ,EAAE;AADP,GAAP;AAGH;AAED;AACA;AACA;;;AACO,SAAS,gBAAT,CACH,OADG,EAEmC;AACtC,SAAO,OAAO,CAAC,UAAR,CAAmB,WAAnB,CAA+B,UAA/B,CAA0C,OAA1C,CAAP;AACH;;AAEM,SAAS,aAAT,CACH,EADG,EAEH,QAFG,EAGH,UAHG,EAIL;AACE;AACA,MAAI,QAAQ,IAAI,OAAO,QAAP,KAAoB,QAApC,EAA8C;AAC1C,UAAM,6BAAe,KAAf,EAAsB;AACxB,MAAA,QAAQ,EAAR;AADwB,KAAtB,CAAN;AAGH;;AACD,MAAI,KAAK,CAAC,OAAN,CAAc,QAAd,CAAJ,EAA6B;AACzB,UAAM,6BAAe,KAAf,EAAsB;AACxB,MAAA,QAAQ,EAAR;AADwB,KAAtB,CAAN;AAGH;;AAED,6BAAe,kBAAf,EAAmC;AAC/B,IAAA,EAAE,EAAF,EAD+B;AAE/B,IAAA,QAAQ,EAAR,QAF+B;AAG/B,IAAA,UAAU,EAAV;AAH+B,GAAnC;AAMA,MAAI,GAAG,GAAG,IAAI,WAAJ,CAAgB,EAAhB,EAAoB,QAApB,EAA8B,UAA9B,CAAV,CAnBF,CAqBE;;AACA,EAAA,GAAG,GAAG,gBAAgB,CAAC,GAAD,CAAtB;AAEA,6BAAe,eAAf,EAAgC,GAAhC;AAEA,2CAAwB,UAAxB;AAEA,SAAO,GAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAS,gBAAT,CAA0B,OAA1B,EAAyD;AACrD,MAAM,wBAAwB,GAAG,OAAO,CAAC,SAAR,CAAkB,UAAlB,CAA6B,kBAA7B,CAAgD,OAAjF;;AACA,MAAI,OAAO,CAAC,kBAAR,IAA8B,wBAAlC,EAA4D;AACxD,WAAO,IAAP;AACH,GAFD,MAEO;AACH,WAAO,KAAP;AACH;AACJ;AAGD;AACA;AACA;AACA;AACA;;;AACA,SAAS,YAAT,CAAsB,OAAtB,EAA8D;AAC1D;AACA,MACI,OAAO,CAAC,UAAR,CAAmB,QAAnB,CAA4B,SAA5B,IACA,gBAAgB,CAAC,OAAD,CAFpB,EAGE;AACE,WAAO,2BAAP;AACH;;AAED,EAAA,OAAO,CAAC,iBAAR,GAA4B,OAAO,CAAC,iBAAR,CACvB,IADuB,CAClB;AAAA,WAAM,aAAa,CAAC,OAAD,CAAnB;AAAA,GADkB,CAA5B;AAEA,SAAO,OAAO,CAAC,iBAAf;AACH;AAED;AACA;AACA;AACA;;;AACA,SAAS,aAAT,CAAuB,OAAvB,EAAyE;AACrE,EAAA,OAAO,CAAC,gBAAR,GAA2B,gBAA3B;AAEA;AACJ;AACA;;AACI,OACI;AACA,EAAA,OAAO,CAAC,UAAR,CAAmB,QAAnB,CAA4B,SAA5B,IACA;AACA,EAAA,gBAAgB,CAAC,OAAD,CAJpB,EAKE;AACE,WAAO,2BAAP;AACH;;AAED,MAAI,GAAG,GAAG,KAAV;AACA,MAAI,UAAU,GAAG,KAAjB,CAhBqE,CAgB7C;;AACxB,MAAI,OAAO,CAAC,kBAAR,KAA+B,CAAC,CAApC,EAAuC;AACnC;AACA,IAAA,UAAU,GAAG,IAAb;AACH;AAED;AACJ;AACA;;;AACI,MAAI,CAAC,UAAL,EAAiB;AACb,QAAI,kBAAkB,GAAG,OAAO,CAAC,SAAR,CAAkB,UAAlB,CAA6B,kBAA7B,CAAgD,OAAhD,CAAwD,OAAO,CAAC,kBAAR,GAA6B,CAArF,CAAzB;;AAEA,QAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC7B;AACA,MAAA,UAAU,GAAG,IAAb;AACH,KAHD,MAGO;AACH,MAAA,OAAO,CAAC,kBAAR,GAA6B,OAAO,CAAC,SAAR,CAAkB,UAAlB,CAA6B,kBAA7B,CAAgD,OAA7E;AAEA;AACZ;AACA;AACA;AACA;;AACY,MAAA,kBAAkB,GAAG,kBAAkB,CAAC,MAAnB,CAA0B,UAAC,EAAD,EAA4B;AACvE,eACI,CAAC,EAAE,CAAC,SAAJ,IACA,OAAO,CAAC,cAAR,GAAyB,EAAE,CAAC,SAA5B,KAEI,CAAC,EAAE,CAAC,OAAJ,IACA,OAAO,CAAC,YAAR,GAAuB,EAAE,CAAC,OAH9B,CAFJ;AAQH,OAToB,CAArB;;AAUA,UAAM,eAAqC,GAAG,OAAO,CAAC,SAAR,CAAkB,UAAlB,CACzC,kBADyC,CAEzC,iBAFyC,CAEvB,kBAFuB,CAA9C;;AAIA,UAAM,iBAAiB,GAAG,sCACtB,OADsB,EAEtB,eAFsB,CAA1B;;AAKA,UAAI,iBAAiB,CAAC,iBAAtB,EAAyC;AACrC;AACA,QAAA,UAAU,GAAG,IAAb;AACH,OAHD,MAGO,IAAI,iBAAiB,CAAC,OAAtB,EAA+B;AAClC;AACA,QAAA,GAAG,GAAG,IAAN,CAFkC,CAEtB;;AACZ,QAAA,OAAO,CAAC,cAAR,CAAuB,iBAAiB,CAAC,UAAzC;AACH;AACJ;AACJ,GAnEoE,CAqErE;;;AACA,MAAI,UAAJ,EAAgB;AACZ;AACA,QAAM,WAAmB,GAAI,OAAD,CAAiB,UAAjB,CAA4B,kBAA5B,CAA+C,OAA3E;AACA,WAAO,OAAO,CAAC,iBAAR,GACF,IADE,CACG,UAAA,aAAa,EAAI;AACnB,MAAA,OAAO,CAAC,kBAAR,GAA6B,WAA7B;;AACA,UAAI,CAAC,+BAAU,aAAV,EAAyB,OAAO,CAAC,YAAjC,CAAL,EAAqD;AACjD,QAAA,GAAG,GAAG,IAAN,CADiD,CACrC;;AACZ,QAAA,OAAO,CAAC,cAAR,CAAuB,aAAvB;AACH;;AACD,aAAO,GAAP;AACH,KARE,CAAP;AASH;;AAED,SAAO,GAAP,CApFqE,CAoFzD;AACf;;AAIM,SAAS,YAAT,CAAsB,GAAtB,EAAyC;AAC5C,SAAO,GAAG,YAAY,WAAtB;AACH","file":"rx-query.js","sourcesContent":["import deepEqual from 'fast-deep-equal';\nimport {\n    merge,\n    BehaviorSubject,\n    firstValueFrom\n} from 'rxjs';\nimport {\n    mergeMap,\n    filter,\n    map,\n    tap\n} from 'rxjs/operators';\nimport {\n    sortObject,\n    stringifyFilter,\n    pluginMissing,\n    clone,\n    overwriteGetterForCaching,\n    now,\n    promiseWait,\n    PROMISE_RESOLVE_FALSE,\n    flatClone\n} from './util';\nimport {\n    newRxError,\n    newRxTypeError\n} from './rx-error';\nimport {\n    runPluginHooks\n} from './hooks';\nimport type {\n    RxCollection,\n    RxDocument,\n    RxQueryOP,\n    RxQuery,\n    MangoQuery,\n    MangoQuerySortPart,\n    MangoQuerySelector,\n    PreparedQuery,\n    RxChangeEvent,\n    RxDocumentWriteData\n} from './types';\n\nimport {\n    createRxDocuments\n} from './rx-document-prototype-merge';\nimport { calculateNewResults } from './event-reduce';\nimport { triggerCacheReplacement } from './query-cache';\nimport { getStateSet, QueryMatcher } from 'event-reduce-js';\nimport { _handleToStorageInstance } from './rx-collection-helper';\n\nlet _queryCount = 0;\nconst newQueryID = function (): number {\n    return ++_queryCount;\n};\n\nexport class RxQueryBase<\n    RxDocumentType = any,\n    // TODO also pass DocMethods here\n    RxQueryResult = RxDocument<RxDocumentType[]> | RxDocument<RxDocumentType>\n    > {\n\n    public id: number = newQueryID();\n\n    /**\n     * Some stats then are used for debugging and cache replacement policies\n     */\n    public _execOverDatabaseCount: number = 0;\n    public _creationTime = now();\n    public _lastEnsureEqual = 0;\n\n    // used by some plugins\n    public other: any = {};\n\n    public uncached = false;\n\n    // used to count the subscribers to the query\n    public refCount$ = new BehaviorSubject(null);\n\n    constructor(\n        public op: RxQueryOP,\n        public mangoQuery: Readonly<MangoQuery>,\n        public collection: RxCollection<RxDocumentType>\n    ) {\n        if (!mangoQuery) {\n            mangoQuery = _getDefaultQuery();\n        }\n    }\n    get $(): BehaviorSubject<RxQueryResult> {\n        if (!this._$) {\n            /**\n             * We use _resultsDocs$ to emit new results\n             * This also ensures that there is a reemit on subscribe\n             */\n            const results$ = (this._resultsDocs$ as any)\n                .pipe(\n                    mergeMap((docs: any[]) => {\n                        return _ensureEqual(this as any)\n                            .then((hasChanged: any) => {\n                                if (hasChanged) {\n                                    // wait for next emit\n                                    return false;\n                                } else {\n                                    return docs;\n                                }\n                            });\n                    }),\n                    filter((docs: any[]) => !!docs), // not if previous returned false\n                    map((docs: any[]) => {\n                        if (this.op === 'findOne') {\n                            // findOne()-queries emit document or null\n                            const doc = docs.length === 0 ? null : docs[0];\n                            return doc;\n                        } else {\n                            // find()-queries emit RxDocument[]\n                            return docs;\n                        }\n                    }),\n                    map(docs => {\n                        // copy the array so it wont matter if the user modifies it\n                        const ret = Array.isArray(docs) ? docs.slice() : docs;\n                        return ret;\n                    })\n                ).asObservable();\n\n            /**\n             * subscribe to the changeEvent-stream so it detects changes if it has subscribers\n             */\n            const changeEvents$ = this.collection.$\n                .pipe(\n                    tap(() => _ensureEqual(this)),\n                    filter(() => false)\n                );\n\n            this._$ =\n                // tslint:disable-next-line\n                merge(\n                    results$,\n                    changeEvents$,\n                    this.refCount$.pipe(\n                        filter(() => false)\n                    )\n                ) as any;\n        }\n        return this._$ as any;\n    }\n\n\n    // stores the changeEvent-number of the last handled change-event\n    public _latestChangeEvent: -1 | number = -1;\n\n    // contains the results as plain json-data\n    public _resultsData: any = null;\n    public _resultsDataMap: Map<string, RxDocumentType> = new Map();\n\n    // time stamps on when the last full exec over the database has run\n    // used to properly handle events that happen while the find-query is running\n    public _lastExecStart: number = 0;\n    public _lastExecEnd: number = 0;\n\n    // contains the results as RxDocument[]\n    public _resultsDocs$: BehaviorSubject<any> = new BehaviorSubject(null);\n\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n    public _ensureEqualQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n\n    /**\n     * Returns an observable that emits the results\n     * This should behave like an rxjs-BehaviorSubject which means:\n     * - Emit the current result-set on subscribe\n     * - Emit the new result-set when an RxChangeEvent comes in\n     * - Do not emit anything before the first result-set was created (no null)\n     */\n    public _$?: BehaviorSubject<RxQueryResult>;\n\n    /**\n     * set the new result-data as result-docs of the query\n     * @param newResultData json-docs that were received from pouchdb\n     */\n    _setResultData(newResultData: any[]): RxDocument[] {\n        const docs = createRxDocuments(\n            this.collection,\n            newResultData\n        );\n\n        /**\n         * Instead of using the newResultData in the result cache,\n         * we directly use the objects that are stored in the RxDocument\n         * to ensure we do not store the same data twice and fill up the memory.\n         */\n        const primPath = this.collection.schema.primaryPath;\n        this._resultsDataMap = new Map();\n        this._resultsData = docs.map(doc => {\n            const docData: RxDocumentType = doc._dataSync$.getValue() as any;\n            const id: string = docData[primPath] as any;\n            this._resultsDataMap.set(id, docData);\n            return docData;\n        });\n\n\n        this._resultsDocs$.next(docs);\n        return docs as any;\n    }\n\n    /**\n     * executes the query on the database\n     * @return results-array with document-data\n     */\n    _execOverDatabase(): Promise<any[]> {\n        this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n        this._lastExecStart = now();\n\n        let docsPromise;\n        switch (this.op) {\n            case 'find':\n                docsPromise = this.collection._queryStorageInstance(this as any);\n                break;\n            case 'findOne':\n                docsPromise = this.collection._queryStorageInstance(this as any, 1);\n                break;\n            default:\n                throw newRxError('QU1', {\n                    collection: this.collection.name,\n                    op: this.op\n                });\n        }\n\n        return docsPromise.then(docs => {\n            this._lastExecEnd = now();\n            return docs;\n        });\n    }\n\n    /**\n     * Execute the query\n     * To have an easier implementations,\n     * just subscribe and use the first result\n     */\n    public exec(throwIfMissing: true): Promise<RxDocument<RxDocumentType>>;\n    public exec(): Promise<RxQueryResult>;\n    public exec(throwIfMissing?: boolean): Promise<any> {\n        // TODO this should be ensured by typescript\n        if (throwIfMissing && this.op !== 'findOne') {\n            throw newRxError('QU9', {\n                collection: this.collection.name,\n                query: this.mangoQuery,\n                op: this.op\n            });\n        }\n\n        /**\n         * run _ensureEqual() here,\n         * this will make sure that errors in the query which throw inside of pouchdb,\n         * will be thrown at this execution context\n         */\n        return _ensureEqual(this)\n            .then(() => firstValueFrom(this.$))\n            .then(result => {\n                if (!result && throwIfMissing) {\n                    throw newRxError('QU10', {\n                        collection: this.collection.name,\n                        query: this.mangoQuery,\n                        op: this.op\n                    });\n                } else {\n                    return result;\n                }\n            });\n    }\n\n\n\n    /**\n     * cached call to get the queryMatcher\n     * @overwrites itself with the actual value\n     */\n    get queryMatcher(): QueryMatcher<RxDocumentWriteData<RxDocumentType>> {\n        return overwriteGetterForCaching(\n            this,\n            'queryMatcher',\n            this.collection.storageInstance.getQueryMatcher(\n                this.getPreparedQuery()\n            )\n        );\n    }\n\n    /**\n     * returns a string that is used for equal-comparisons\n     * @overwrites itself with the actual value\n     */\n    toString(): string {\n        const stringObj = sortObject({\n            op: this.op,\n            query: this.mangoQuery,\n            other: this.other\n        }, true);\n        const value = JSON.stringify(stringObj, stringifyFilter);\n        this.toString = () => value;\n        return value;\n    }\n\n    /**\n     * returns the prepared query\n     * which can be send to the storage instance to query for documents.\n     * @overwrites itself with the actual value.\n     */\n    getPreparedQuery(): PreparedQuery<RxDocumentType> {\n        const hookInput = {\n            rxQuery: this,\n            // can be mutated by the hooks so we have to deep clone first.\n            mangoQuery: clone(this.mangoQuery)\n        };\n        runPluginHooks('prePrepareQuery', hookInput);\n\n        const value = this.collection.storageInstance.prepareQuery(\n            hookInput.mangoQuery\n        );\n        this.getPreparedQuery = () => value;\n        return value;\n    }\n\n    /**\n     * returns true if the document matches the query,\n     * does not use the 'skip' and 'limit'\n     * // TODO this was moved to rx-storage\n     */\n    doesDocumentDataMatch(docData: RxDocumentType | any): boolean {\n        // if doc is deleted, it cannot match\n        if (docData._deleted) {\n            return false;\n        }\n\n        return this.queryMatcher(\n            _handleToStorageInstance(this.collection, docData)\n        );\n    }\n\n    /**\n     * deletes all found documents\n     * @return promise with deleted documents\n     */\n    remove(): Promise<RxQueryResult> {\n        let ret: any;\n        return this\n            .exec()\n            .then(docs => {\n                ret = docs;\n                if (Array.isArray(docs)) {\n                    return Promise.all(docs.map(doc => doc.remove()));\n                } else {\n                    return (docs as any).remove();\n                }\n            })\n            .then(() => ret);\n    }\n\n\n    /**\n     * helper function to transform RxQueryBase to RxQuery type\n     */\n    get asRxQuery(): RxQuery<RxDocumentType, RxQueryResult> {\n        return this as any;\n    }\n\n    /**\n     * updates all found documents\n     * @overwritten by plugin (optional)\n     */\n    update(_updateObj: any): Promise<RxQueryResult> {\n        throw pluginMissing('update');\n    }\n\n\n    // we only set some methods of query-builder here\n    // because the others depend on these ones\n    where(_queryObj: MangoQuerySelector<RxDocumentType> | keyof RxDocumentType | string): RxQuery<RxDocumentType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    sort(_params: string | MangoQuerySortPart<RxDocumentType>): RxQuery<RxDocumentType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    skip(_amount: number | null): RxQuery<RxDocumentType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    limit(_amount: number | null): RxQuery<RxDocumentType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n}\n\nexport function _getDefaultQuery(): MangoQuery {\n    return {\n        selector: {}\n    };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache<RxDocumentType, RxQueryResult>(\n    rxQuery: RxQueryBase<RxDocumentType, RxQueryResult>\n): RxQuery<RxDocumentType, RxQueryResult> {\n    return rxQuery.collection._queryCache.getByQuery(rxQuery as any);\n}\n\nexport function createRxQuery(\n    op: RxQueryOP,\n    queryObj: MangoQuery,\n    collection: RxCollection\n) {\n    // checks\n    if (queryObj && typeof queryObj !== 'object') {\n        throw newRxTypeError('QU7', {\n            queryObj\n        });\n    }\n    if (Array.isArray(queryObj)) {\n        throw newRxTypeError('QU8', {\n            queryObj\n        });\n    }\n\n    runPluginHooks('preCreateRxQuery', {\n        op,\n        queryObj,\n        collection\n    });\n\n    let ret = new RxQueryBase(op, queryObj, collection);\n\n    // ensure when created with same params, only one is created\n    ret = tunnelQueryCache(ret);\n\n    runPluginHooks('createRxQuery', ret);\n\n    triggerCacheReplacement(collection);\n\n    return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery: RxQueryBase): boolean {\n    const currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n    if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nfunction _ensureEqual(rxQuery: RxQueryBase): Promise<boolean> {\n    // Optimisation shortcut\n    if (\n        rxQuery.collection.database.destroyed ||\n        _isResultsInSync(rxQuery)\n    ) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue\n        .then(() => __ensureEqual(rxQuery));\n    return rxQuery._ensureEqualQueue;\n}\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nfunction __ensureEqual(rxQuery: RxQueryBase): Promise<boolean> | boolean {\n    rxQuery._lastEnsureEqual = now();\n\n    /**\n     * Optimisation shortcuts\n     */\n    if (\n        // db is closed\n        rxQuery.collection.database.destroyed ||\n        // nothing happend since last run\n        _isResultsInSync(rxQuery)\n    ) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    let ret = false;\n    let mustReExec = false; // if this becomes true, a whole execution over the database is made\n    if (rxQuery._latestChangeEvent === -1) {\n        // have not executed yet -> must run\n        mustReExec = true;\n    }\n\n    /**\n     * try to use the queryChangeDetector to calculate the new results\n     */\n    if (!mustReExec) {\n        let missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n\n        if (missedChangeEvents === null) {\n            // changeEventBuffer is of bounds -> we must re-execute over the database\n            mustReExec = true;\n        } else {\n            rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n\n            /**\n             * because pouchdb prefers writes over reads,\n             * we have to filter out the events that happend before the read has started\n             * so that we do not fill event-reduce with the wrong data\n             */\n            missedChangeEvents = missedChangeEvents.filter((cE: RxChangeEvent<any>) => {\n                return (\n                    !cE.startTime ||\n                    rxQuery._lastExecStart < cE.startTime &&\n                    (\n                        !cE.endTime ||\n                        rxQuery._lastExecEnd < cE.endTime\n                    )\n                );\n            });\n            const runChangeEvents: RxChangeEvent<any>[] = rxQuery.asRxQuery.collection\n                ._changeEventBuffer\n                .reduceByLastOfDoc(missedChangeEvents);\n\n            const eventReduceResult = calculateNewResults(\n                rxQuery as any,\n                runChangeEvents\n            );\n\n            if (eventReduceResult.runFullQueryAgain) {\n                // could not calculate the new results, execute must be done\n                mustReExec = true;\n            } else if (eventReduceResult.changed) {\n                // we got the new results, we do not have to re-execute, mustReExec stays false\n                ret = true; // true because results changed\n                rxQuery._setResultData(eventReduceResult.newResults);\n            }\n        }\n    }\n\n    // oh no we have to re-execute the whole query over the database\n    if (mustReExec) {\n        // counter can change while _execOverDatabase() is running so we save it here\n        const latestAfter: number = (rxQuery as any).collection._changeEventBuffer.counter;\n        return rxQuery._execOverDatabase()\n            .then(newResultData => {\n                rxQuery._latestChangeEvent = latestAfter;\n                if (!deepEqual(newResultData, rxQuery._resultsData)) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newResultData);\n                }\n                return ret;\n            });\n    }\n\n    return ret; // true if results have changed\n}\n\n\n\nexport function isInstanceOf(obj: any): boolean {\n    return obj instanceof RxQueryBase;\n}\n"]}
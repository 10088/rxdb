{"version":3,"file":"custom-index.js","names":["getIndexableStringMonad","schema","index","fieldNameProperties","map","fieldName","schemaPart","getSchemaByObjectPath","type","parsedLengths","getStringLengthOfIndexNumber","hasComplexPath","includes","getValueFn","objectPathMonad","ret","docData","str","forEach","props","fieldValue","padStart","maxLength","boolToStr","ensureNotFalsy","getNumberIndexString","minimum","Math","floor","maximum","ceil","multipleOf","valueSpan","nonDecimals","toString","length","multipleOfParts","split","decimals","roundedMinimum","nonDecimalsValueAsString","splittedByDecimalPoint","decimalValueAsString","padEnd","getStartIndexStringFromLowerBound","lowerBound","idx","bound","repeat","Error","getStartIndexStringFromUpperBound","upperBound","INDEX_MAX"],"sources":["../../src/custom-index.ts"],"sourcesContent":["/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n */\n\nimport { getSchemaByObjectPath } from './rx-schema-helper';\nimport type {\n    JsonSchema,\n    RxDocumentData,\n    RxJsonSchema\n} from './types';\nimport {\n    ensureNotFalsy,\n    objectPathMonad,\n    ObjectPathMonadFunction\n} from './util';\nimport { INDEX_MAX } from './query-planner';\n\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above \n * another documents, dependent on the index values.\n * @monad for better performance\n * \n * IMPORTANT: Performance is really important here\n * which is why we code so 'strange'.\n * Always run performance tests when you want to\n * change something in this method.\n */\nexport function getIndexableStringMonad<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n): (docData: RxDocumentData<RxDocType>) => string {\n\n    /**\n     * Prepare all relevant information\n     * outside of the returned function\n     * to save performance when the returned\n     * function is called many times.\n     */\n    const fieldNameProperties: {\n        fieldName: string;\n        schemaPart: JsonSchema;\n        /*\n         * Only in number fields.\n         */\n        parsedLengths?: ParsedLengths;\n        getValueFn: ObjectPathMonadFunction<RxDocType>;\n    }[] = index.map(fieldName => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const type = schemaPart.type;\n        let parsedLengths: ParsedLengths | undefined;\n        if (type === 'number' || type === 'integer') {\n            parsedLengths = getStringLengthOfIndexNumber(\n                schemaPart\n            );\n        }\n\n        return {\n            fieldName,\n            schemaPart,\n            parsedLengths,\n            hasComplexPath: fieldName.includes('.'),\n            getValueFn: objectPathMonad(fieldName)\n        }\n    });\n\n\n    const ret = function (docData: RxDocumentData<RxDocType>): string {\n        let str = '';\n        fieldNameProperties.forEach(props => {\n            const schemaPart = props.schemaPart;\n            const type = schemaPart.type;\n\n            let fieldValue = props.getValueFn(docData);\n\n            if (type === 'string') {\n                if (!fieldValue) {\n                    fieldValue = '';\n                }\n                str += fieldValue.padStart(schemaPart.maxLength as number, ' ');\n            } else if (type === 'boolean') {\n                const boolToStr = fieldValue ? '1' : '0';\n                str += boolToStr;\n            } else {\n                const parsedLengths = ensureNotFalsy(props.parsedLengths);\n                if (!fieldValue) {\n                    fieldValue = 0;\n                }\n                str += getNumberIndexString(\n                    parsedLengths,\n                    fieldValue\n                );\n            }\n        });\n        return str;\n    }\n    return ret;\n}\n\ndeclare type ParsedLengths = {\n    nonDecimals: number;\n    decimals: number;\n    roundedMinimum: number;\n};\nexport function getStringLengthOfIndexNumber(\n    schemaPart: JsonSchema\n): ParsedLengths {\n    const minimum = Math.floor(schemaPart.minimum as number);\n    const maximum = Math.ceil(schemaPart.maximum as number);\n    const multipleOf: number = schemaPart.multipleOf as number;\n\n    const valueSpan = maximum - minimum;\n    const nonDecimals = valueSpan.toString().length;\n\n    const multipleOfParts = multipleOf.toString().split('.');\n    let decimals = 0;\n    if (multipleOfParts.length > 1) {\n        decimals = multipleOfParts[1].length;\n    }\n    return {\n        nonDecimals,\n        decimals,\n        roundedMinimum: minimum\n    };\n}\n\n\nexport function getNumberIndexString(\n    parsedLengths: ParsedLengths,\n    fieldValue: number\n): string {\n    let str: string = '';\n    const nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n    str += nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n\n    const splittedByDecimalPoint = fieldValue.toString().split('.');\n    const decimalValueAsString = splittedByDecimalPoint.length > 1 ? splittedByDecimalPoint[1] : '0';\n\n    str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n    return str;\n}\n\nexport function getStartIndexStringFromLowerBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    lowerBound: (string | boolean | number | null | undefined)[]\n): string {\n    let str = '';\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = lowerBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength);\n                if (typeof bound === 'string') {\n                    str += (bound as string).padStart(maxLength, ' ');\n                } else {\n                    str += ''.padStart(maxLength, ' ');\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += '0';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null) {\n                    str += '0'.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n\n\nexport function getStartIndexStringFromUpperBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    upperBound: (string | boolean | number | null | undefined)[]\n): string {\n    let str = '';\n\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = upperBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength);\n                if (typeof bound === 'string') {\n                    str += (bound as string).padStart(maxLength, INDEX_MAX);\n                } else {\n                    str += ''.padStart(maxLength, INDEX_MAX);\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += '1';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null || bound === INDEX_MAX) {\n                    str += '9'.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n"],"mappings":"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"}
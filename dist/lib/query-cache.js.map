{"version":3,"sources":["../../src/query-cache.ts"],"names":[],"mappings":"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","file":"query-cache.js","sourcesContent":["/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\nimport type {\n    RxQuery,\n    RxCacheReplacementPolicy,\n    RxCollection\n} from './types';\nimport {\n    nextTick,\n    now,\n    requestIdlePromise\n} from './util';\n\nexport class QueryCache {\n    public _map: Map<string, RxQuery> = new Map();\n\n    /**\n     * check if an equal query is in the cache,\n     * if true, return the cached one,\n     * if false, save the given one and return it\n     */\n    getByQuery(rxQuery: RxQuery): RxQuery {\n        const stringRep = rxQuery.toString();\n        if (!this._map.has(stringRep)) {\n            this._map.set(stringRep, rxQuery);\n        }\n        return this._map.get(stringRep) as RxQuery;\n    }\n}\n\nexport function createQueryCache() {\n    return new QueryCache();\n}\n\n\nexport function uncacheRxQuery(queryCache: QueryCache, rxQuery: RxQuery) {\n    rxQuery.uncached = true;\n    const stringRep = rxQuery.toString();\n    queryCache._map.delete(stringRep);\n\n}\n\n\nexport function countRxQuerySubscribers(rxQuery: RxQuery): number {\n    return rxQuery.refCount$.observers.length;\n}\n\n\nexport const DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport const DEFAULT_UNEXECUTED_LIFETME = 30 * 1000;\n\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\nexport const defaultCacheReplacementPolicyMonad: (\n    tryToKeepMax: number,\n    unExecutedLifetime: number\n) => RxCacheReplacementPolicy = (\n    tryToKeepMax,\n    unExecutedLifetime\n) => (\n    _collection: RxCollection,\n    queryCache: QueryCache\n) => {\n            if (queryCache._map.size < tryToKeepMax) {\n                return;\n            }\n\n            const minUnExecutedLifetime = now() - unExecutedLifetime;\n            const maybeUncash: RxQuery[] = [];\n\n            const queriesInCache = Array.from(queryCache._map.values());\n            for (const rxQuery of queriesInCache) {\n                // filter out queries with subscribers\n                if (countRxQuerySubscribers(rxQuery) > 0) {\n                    continue;\n                }\n                // directly uncache queries that never executed and are older then unExecutedLifetime\n                if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n                    uncacheRxQuery(queryCache, rxQuery);\n                    continue;\n                }\n                maybeUncash.push(rxQuery);\n            }\n\n            const mustUncache = maybeUncash.length - tryToKeepMax;\n            if (mustUncache <= 0) {\n                return;\n            }\n\n            const sortedByLastUsage = maybeUncash.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\n            const toRemove = sortedByLastUsage.slice(0, mustUncache);\n            toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\n        };\n\n\nexport const defaultCacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(\n    DEFAULT_TRY_TO_KEEP_MAX,\n    DEFAULT_UNEXECUTED_LIFETME\n);\n\nexport const COLLECTIONS_WITH_RUNNING_CLEANUP: WeakSet<RxCollection> = new WeakSet();\n\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\nexport function triggerCacheReplacement(\n    rxCollection: RxCollection\n) {\n    if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\n        // already started\n        return;\n    }\n\n    COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\n\n    /**\n     * Do not run directly to not reduce result latency of a new query\n     */\n    nextTick() // wait at least one tick\n        .then(() => requestIdlePromise(200)) // and then wait for the CPU to be idle\n        .then(() => {\n            if (!rxCollection.destroyed) {\n                rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n            }\n            COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\n        });\n}\n"]}
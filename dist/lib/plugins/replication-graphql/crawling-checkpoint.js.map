{"version":3,"sources":["../../../../src/plugins/replication-graphql/crawling-checkpoint.ts"],"names":["pushSequenceId","endpointHash","GRAPHQL_REPLICATION_PLUGIN_IDENT","getLastPushSequence","collection","database","lockedRun","localDocumentsStore","doc","value","setLastPushSequence","sequence","_id","document","_attachments","res","newDoc","previous","getChangesSinceLastPushSequence","batchSize","lastPushSequence","retry","lastSequence","changedDocs","Map","storageInstance","getChangedDocuments","sinceSequence","limit","direction","changesResults","changedDocuments","length","findDocumentsById","map","row","id","plainDocs","docs","Object","entries","forEach","docId","docData","hookParams","set","has","changedDoc","get","args","_rev","size","pullLastDocumentId","getLastPullDocument","localDoc","setLastPullDocument"],"mappings":"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","sourcesContent":["import {\n    wasRevisionfromPullReplication,\n    GRAPHQL_REPLICATION_PLUGIN_IDENT\n} from './helper';\nimport type {\n    RxCollection,\n    RxLocalDocumentData,\n    RxDocumentData\n} from '../../types';\nimport {\n    findLocalDocument,\n    writeSingleLocal\n} from '../../rx-storage-helper';\nimport { flatClone } from '../../util';\nimport { newRxError } from '../../rx-error';\nimport { runPluginHooks } from '../../hooks';\n\n/**\n * when the replication starts,\n * we need a way to find out where it ended the last time.\n *\n * For push-replication, we use the storageInstance-sequence:\n * We get the documents newer then the last sequence-id\n * and push them to the server.\n *\n * For pull-replication, we use the last document we got from the server:\n * We send the last document to the queryBuilder()\n * and recieve newer documents sorted in a batch\n */\n\n\n\n//\n// things for the push-checkpoint\n//\n\nconst pushSequenceId = (endpointHash: string) => GRAPHQL_REPLICATION_PLUGIN_IDENT + '-push-checkpoint-' + endpointHash;\n\n/**\n * @return last sequence checkpoint\n */\nexport async function getLastPushSequence(\n    collection: RxCollection,\n    endpointHash: string\n): Promise<number> {\n    const doc = await collection.database.lockedRun(\n        () => findLocalDocument<CheckpointDoc>(\n            collection.localDocumentsStore,\n            pushSequenceId(endpointHash)\n        )\n    );\n    if (!doc) {\n        return 0;\n    } else {\n        return doc.value;\n    }\n}\n\ndeclare type CheckpointDoc = { _id: string; value: number; };\n\nexport async function setLastPushSequence(\n    collection: RxCollection,\n    endpointHash: string,\n    sequence: number\n): Promise<CheckpointDoc> {\n    const _id = pushSequenceId(endpointHash);\n\n    const doc = await collection.database.lockedRun(\n        () => findLocalDocument<CheckpointDoc>(\n            collection.localDocumentsStore,\n            _id\n        )\n    );\n\n    if (!doc) {\n        const res = await collection.database.lockedRun(\n            () => writeSingleLocal<CheckpointDoc>(\n                collection.localDocumentsStore,\n                {\n                    document: {\n                        _id,\n                        value: sequence,\n                        _attachments: {}\n                    }\n                }\n            )\n        );\n        return res as any;\n    } else {\n        const newDoc = flatClone(doc);\n        newDoc.value = sequence;\n        const res = await collection.database.lockedRun(\n            () => writeSingleLocal<CheckpointDoc>(\n                collection.localDocumentsStore,\n                {\n                    previous: doc,\n                    document: {\n                        _id,\n                        value: sequence,\n                        _attachments: {}\n                    }\n                }\n            )\n        );\n        return res as any;\n    }\n}\n\n\nexport async function getChangesSinceLastPushSequence<RxDocType>(\n    collection: RxCollection<RxDocType, any>,\n    endpointHash: string,\n    batchSize = 10\n): Promise<{\n    changedDocs: Map<string, {\n        id: string;\n        doc: RxDocumentData<RxDocType>;\n        sequence: number;\n    }>;\n    lastSequence: number;\n}> {\n    let lastPushSequence = await getLastPushSequence(\n        collection,\n        endpointHash\n    );\n\n    let retry = true;\n    let lastSequence: number = lastPushSequence;\n    const changedDocs: Map<string, {\n        id: string;\n        doc: RxDocumentData<RxDocType>;\n        sequence: number;\n    }> = new Map();\n\n    /**\n     * it can happen that all docs in the batch\n     * do not have to be replicated.\n     * Then we have to continue grapping the feed\n     * until we reach the end of it\n     */\n    while (retry) {\n        const changesResults = await collection.database.lockedRun(\n            () => collection.storageInstance.getChangedDocuments({\n                sinceSequence: lastPushSequence,\n                limit: batchSize,\n                direction: 'after'\n            })\n        );\n        lastSequence = changesResults.lastSequence;\n\n        // optimisation shortcut, do not proceed if there are no changed documents\n        if (changesResults.changedDocuments.length === 0) {\n            retry = false;\n            continue;\n        }\n\n        const plainDocs = await collection.database.lockedRun(\n            () => collection.storageInstance.findDocumentsById(\n                changesResults.changedDocuments.map(row => row.id),\n                true\n            )\n        );\n\n        const docs: Map<string, RxDocumentData<RxDocType>> = new Map();\n\n        Object.entries(plainDocs).forEach(([docId, docData]) => {\n            const hookParams = {\n                collection,\n                doc: docData\n            };\n            runPluginHooks('postReadFromInstance', hookParams);\n            docs.set(docId, hookParams.doc);\n        });\n\n        changesResults.changedDocuments.forEach((row) => {\n            const id = row.id;\n            if (changedDocs.has(id)) {\n                return;\n            }\n            const changedDoc = docs.get(id);\n            if (!changedDoc) {\n                throw newRxError('SNH', { args: { docs } });\n            }\n\n            /**\n             * filter out changes with revisions resulting from the pull-stream\n             * so that they will not be upstreamed again\n             */\n            if (wasRevisionfromPullReplication(\n                endpointHash,\n                changedDoc._rev\n            )) {\n                return false;\n            }\n\n            changedDocs.set(id, {\n                id,\n                doc: changedDoc,\n                sequence: row.sequence\n            });\n        });\n\n\n        if (changedDocs.size < batchSize && changesResults.changedDocuments.length === batchSize) {\n            // no pushable docs found but also not reached the end -> re-run\n            lastPushSequence = lastSequence;\n            retry = true;\n        } else {\n            retry = false;\n        }\n    }\n\n    return {\n        changedDocs,\n        lastSequence\n    };\n}\n\n\n//\n// things for pull-checkpoint\n//\n\n\nconst pullLastDocumentId = (endpointHash: string) => GRAPHQL_REPLICATION_PLUGIN_IDENT + '-pull-checkpoint-' + endpointHash;\n\nexport async function getLastPullDocument<RxDocType>(\n    collection: RxCollection<RxDocType>,\n    endpointHash: string\n): Promise<RxDocType | null> {\n    const localDoc = await collection.database.lockedRun(\n        () => findLocalDocument<any>(\n            collection.localDocumentsStore,\n            pullLastDocumentId(endpointHash)\n        )\n    );\n\n    if (!localDoc) {\n        return null;\n    } else {\n        return localDoc.doc;\n    }\n}\n\nexport async function setLastPullDocument(\n    collection: RxCollection,\n    endpointHash: string,\n    doc: any\n): Promise<{ _id: string }> {\n    const _id = pullLastDocumentId(endpointHash);\n\n    const localDoc: RxLocalDocumentData = await collection.database.lockedRun(\n        () => findLocalDocument<any>(\n            collection.localDocumentsStore,\n            _id\n        )\n    );\n\n    if (!localDoc) {\n        return collection.database.lockedRun(\n            () => writeSingleLocal(\n                collection.localDocumentsStore,\n                {\n                    document: {\n                        _id,\n                        doc,\n                        _attachments: {}\n                    }\n                }\n            )\n        );\n    } else {\n        const newDoc = flatClone(localDoc);\n        newDoc.doc = doc;\n        return collection.database.lockedRun(\n            () => writeSingleLocal(\n                collection.localDocumentsStore,\n                {\n                    previous: localDoc,\n                    document: newDoc\n                }\n            )\n        );\n    }\n}\n"],"file":"crawling-checkpoint.js"}
{"version":3,"sources":["../../../../src/plugins/replication-graphql/crawling-checkpoint.ts"],"names":[],"mappings":"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","file":"crawling-checkpoint.js","sourcesContent":["import {\n    wasRevisionfromPullReplication,\n    GRAPHQL_REPLICATION_PLUGIN_IDENT\n} from './helper';\nimport type {\n    RxCollection,\n    RxLocalDocumentData,\n    RxDocumentData\n} from '../../types';\nimport {\n    findLocalDocument,\n    writeSingleLocal\n} from '../../rx-storage-helper';\nimport { flatClone } from '../../util';\nimport { newRxError } from '../../rx-error';\nimport { runPluginHooks } from '../../hooks';\n\n/**\n * when the replication starts,\n * we need a way to find out where it ended the last time.\n *\n * For push-replication, we use the storageInstance-sequence:\n * We get the documents newer then the last sequence-id\n * and push them to the server.\n *\n * For pull-replication, we use the last document we got from the server:\n * We send the last document to the queryBuilder()\n * and recieve newer documents sorted in a batch\n */\n\n\n\n//\n// things for the push-checkpoint\n//\n\nconst pushSequenceId = (endpointHash: string) => GRAPHQL_REPLICATION_PLUGIN_IDENT + '-push-checkpoint-' + endpointHash;\n\n/**\n * @return last sequence checkpoint\n */\nexport async function getLastPushSequence(\n    collection: RxCollection,\n    endpointHash: string\n): Promise<number> {\n    const doc = await findLocalDocument<CheckpointDoc>(\n        collection.localDocumentsStore,\n        pushSequenceId(endpointHash)\n    );\n    if (!doc) {\n        return 0;\n    } else {\n        return doc.value;\n    }\n}\n\ndeclare type CheckpointDoc = { _id: string; value: number; };\n\nexport async function setLastPushSequence(\n    collection: RxCollection,\n    endpointHash: string,\n    sequence: number\n): Promise<CheckpointDoc> {\n    const _id = pushSequenceId(endpointHash);\n\n    const doc = await findLocalDocument<CheckpointDoc>(\n        collection.localDocumentsStore,\n        _id\n    );\n    if (!doc) {\n        const res = await writeSingleLocal<CheckpointDoc>(\n            collection.localDocumentsStore,\n            {\n                document: {\n                    _id,\n                    value: sequence,\n                    _attachments: {}\n                }\n            }\n        );\n        return res as any;\n    } else {\n        const newDoc = flatClone(doc);\n        newDoc.value = sequence;\n        const res = await writeSingleLocal<CheckpointDoc>(\n            collection.localDocumentsStore,\n            {\n                previous: doc,\n                document: {\n                    _id,\n                    value: sequence,\n                    _attachments: {}\n                }\n            }\n        );\n        return res as any;\n    }\n}\n\n\nexport async function getChangesSinceLastPushSequence<RxDocType>(\n    collection: RxCollection<RxDocType, any>,\n    endpointHash: string,\n    batchSize = 10\n): Promise<{\n    changedDocs: Map<string, {\n        id: string;\n        doc: RxDocumentData<RxDocType>;\n        sequence: number;\n    }>;\n    lastSequence: number;\n}> {\n    let lastPushSequence = await getLastPushSequence(\n        collection,\n        endpointHash\n    );\n\n    let retry = true;\n    let lastSequence: number = lastPushSequence;\n    const changedDocs: Map<string, {\n        id: string;\n        doc: RxDocumentData<RxDocType>;\n        sequence: number;\n    }> = new Map();\n\n    /**\n     * it can happen that all docs in the batch\n     * do not have to be replicated.\n     * Then we have to continue grapping the feed\n     * until we reach the end of it\n     */\n    while (retry) {\n\n        const changesResults = await collection.storageInstance.getChangedDocuments({\n            sinceSequence: lastPushSequence,\n            limit: batchSize,\n            direction: 'after'\n        });\n        lastSequence = changesResults.lastSequence;\n\n        // optimisation shortcut, do not proceed if there are no changed documents\n        if (changesResults.changedDocuments.length === 0) {\n            retry = false;\n            continue;\n        }\n\n        const plainDocs = await collection.storageInstance.findDocumentsById(\n            changesResults.changedDocuments.map(row => row.id),\n            true\n        );\n        const docs: Map<string, RxDocumentData<RxDocType>> = new Map();\n        Array.from(plainDocs.entries()).map(([docId, docData]) => {\n            const hookParams = {\n                collection,\n                doc: docData\n            };\n            runPluginHooks('postReadFromInstance', hookParams);\n            docs.set(docId, hookParams.doc);\n        });\n\n\n        changesResults.changedDocuments.forEach((row) => {\n            const id = row.id;\n            if (changedDocs.has(id)) {\n                return;\n            }\n            const changedDoc = docs.get(id);\n            if (!changedDoc) {\n                throw newRxError('SNH', { args: { docs } });\n            }\n\n            /**\n             * filter out changes with revisions resulting from the pull-stream\n             * so that they will not be upstreamed again\n             */\n            if (wasRevisionfromPullReplication(\n                endpointHash,\n                changedDoc._rev\n            )) {\n                return false;\n            }\n\n            changedDocs.set(id, {\n                id,\n                doc: changedDoc,\n                sequence: row.sequence\n            });\n        });\n\n\n        if (changedDocs.size < batchSize && changesResults.changedDocuments.length === batchSize) {\n            // no pushable docs found but also not reached the end -> re-run\n            lastPushSequence = lastSequence;\n            retry = true;\n        } else {\n            retry = false;\n        }\n    }\n\n    return {\n        changedDocs,\n        lastSequence\n    };\n}\n\n\n//\n// things for pull-checkpoint\n//\n\n\nconst pullLastDocumentId = (endpointHash: string) => GRAPHQL_REPLICATION_PLUGIN_IDENT + '-pull-checkpoint-' + endpointHash;\n\nexport async function getLastPullDocument<RxDocType>(\n    collection: RxCollection<RxDocType>,\n    endpointHash: string\n): Promise<RxDocType | null> {\n    const localDoc = await findLocalDocument<any>(\n        collection.localDocumentsStore,\n        pullLastDocumentId(endpointHash)\n    );\n    if (!localDoc) {\n        return null;\n    } else {\n        return localDoc.doc;\n    }\n}\n\nexport async function setLastPullDocument(\n    collection: RxCollection,\n    endpointHash: string,\n    doc: any\n): Promise<{ _id: string }> {\n    const _id = pullLastDocumentId(endpointHash);\n\n    const localDoc: RxLocalDocumentData = await findLocalDocument<any>(\n        collection.localDocumentsStore,\n        _id\n    );\n\n    if (!localDoc) {\n        return writeSingleLocal(\n            collection.localDocumentsStore,\n            {\n                document: {\n                    _id,\n                    doc,\n                    _attachments: {}\n                }\n            }\n        );\n    } else {\n        const newDoc = flatClone(localDoc);\n        newDoc.doc = doc;\n        return writeSingleLocal(\n            collection.localDocumentsStore,\n            {\n                previous: localDoc,\n                document: newDoc\n            }\n        );\n    }\n}\n"]}
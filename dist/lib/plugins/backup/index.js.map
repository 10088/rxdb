{"version":3,"sources":["../../../../src/plugins/backup/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import * as path from 'path';\nimport {\n    BehaviorSubject,\n    firstValueFrom,\n    Observable,\n    Subject,\n    Subscription\n} from 'rxjs';\nimport {\n    filter,\n    map\n} from 'rxjs/operators';\nimport { newRxError } from '../../rx-error';\nimport { getNewestSequence } from '../../rx-storage-helper';\nimport type {\n    BackupOptions,\n    RxBackupWriteEvent,\n    RxCollection,\n    RxDatabase,\n    RxDocument,\n    RxPlugin\n} from '../../types';\nimport { getFromMapOrThrow, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_TRUE, PROMISE_RESOLVE_VOID } from '../../util';\nimport {\n    clearFolder,\n    deleteFolder,\n    documentFolder,\n    ensureFolderExists,\n    getMeta,\n    prepareFolders,\n    setMeta,\n    writeJsonToFile,\n    writeToFile\n} from './file-util';\n\n\n/**\n * Backups a single documents,\n * returns the paths to all written files\n */\nexport async function backupSingleDocument(\n    rxDocument: RxDocument<any, any>,\n    options: BackupOptions\n): Promise<string[]> {\n    const data = rxDocument.toJSON(true);\n    const writtenFiles: string[] = [];\n\n    const docFolder = documentFolder(options, rxDocument.primary);\n    await clearFolder(docFolder);\n\n    const fileLocation = path.join(\n        docFolder,\n        'document.json'\n    );\n    await writeJsonToFile(fileLocation, data);\n    writtenFiles.push(fileLocation);\n\n    if (options.attachments) {\n        const attachmentsFolder = path.join(\n            docFolder,\n            'attachments'\n        );\n        ensureFolderExists(attachmentsFolder);\n        const attachments = (rxDocument as RxDocument).allAttachments();\n        await Promise.all(\n            attachments\n                .map(async (attachment) => {\n                    const content = await attachment.getData();\n                    const attachmentFileLocation = path.join(\n                        attachmentsFolder,\n                        attachment.id\n                    );\n                    await writeToFile(attachmentFileLocation, content as Buffer);\n                    writtenFiles.push(attachmentFileLocation);\n                })\n        );\n    }\n\n    return writtenFiles;\n}\n\nconst BACKUP_STATES_BY_DB: WeakMap<RxDatabase, RxBackupState[]> = new WeakMap();\nfunction addToBackupStates(db: RxDatabase, state: RxBackupState) {\n    if (!BACKUP_STATES_BY_DB.has(db)) {\n        BACKUP_STATES_BY_DB.set(db, []);\n    }\n    const ar = getFromMapOrThrow(BACKUP_STATES_BY_DB, db);\n    if (!ar) {\n        throw newRxError('SNH');\n    }\n    ar.push(state);\n}\n\nexport class RxBackupState {\n    public isStopped: boolean = false;\n    private subs: Subscription[] = [];\n    private persistRunning: Promise<void> = PROMISE_RESOLVE_VOID;\n    private initialReplicationDone$: BehaviorSubject<boolean> = new BehaviorSubject(false as any);\n\n    private readonly internalWriteEvents$: Subject<RxBackupWriteEvent> = new Subject();\n    public readonly writeEvents$: Observable<RxBackupWriteEvent> = this.internalWriteEvents$.asObservable();\n\n    constructor(\n        public readonly database: RxDatabase,\n        public readonly options: BackupOptions\n    ) {\n        if (!this.options.batchSize) {\n            this.options.batchSize = 10;\n        }\n        addToBackupStates(database, this);\n        prepareFolders(database, options);\n    }\n\n    /**\n     * Persists all data from all collections,\n     * beginning from the last sequence checkpoint\n     * to the newest one.\n     * Do not call this while it is already running.\n     * Returns true if there are more documents to process\n     */\n    public async persistOnce() {\n        return this.persistRunning = this.persistRunning.then(() => this._persistOnce());\n    }\n\n    public async _persistOnce() {\n        const meta = await getMeta(this.options);\n\n        await Promise.all(\n            Object\n                .keys(this.database.collections)\n                .map(async (collectionName) => {\n                    const processedDocuments: Set<string> = new Set();\n                    const collection: RxCollection = this.database.collections[collectionName];\n\n                    await this.database.requestIdlePromise();\n                    const newestSeq = await getNewestSequence(collection.storageInstance);\n\n                    if (!meta.collectionStates[collectionName]) {\n                        meta.collectionStates[collectionName] = {\n                            newestKnownSequence: newestSeq,\n                            lastSequence: 0\n                        };\n                    }\n                    let lastSequence = meta.collectionStates[collectionName].lastSequence;\n\n                    let hasMore = true;\n                    while (hasMore && !this.isStopped) {\n                        await this.database.requestIdlePromise();\n\n                        const changesResult = await collection.storageInstance.getChangedDocuments({\n                            startSequence: lastSequence,\n                            limit: this.options.batchSize,\n                            order: 'asc'\n                        });\n                        lastSequence = changesResult.lastSequence;\n\n                        meta.collectionStates[collectionName].lastSequence = lastSequence;\n\n                        const docIds: string[] = changesResult.changedDocuments\n                            .filter(changedDocument => {\n                                if (\n                                    processedDocuments.has(changedDocument.id) &&\n                                    changedDocument.sequence < newestSeq\n                                ) {\n                                    return false;\n                                } else {\n                                    processedDocuments.add(changedDocument.id);\n                                    return true;\n                                }\n                            })\n                            .map(r => r.id)\n                            // unique\n                            .filter((elem, pos, arr) => arr.indexOf(elem) === pos);\n                        await this.database.requestIdlePromise();\n\n                        const docs: Map<string, RxDocument> = await collection.findByIds(docIds);\n                        if (docs.size === 0) {\n                            hasMore = false;\n                            continue;\n                        }\n                        await Promise.all(\n                            Array\n                                .from(docs.values())\n                                .map(async (doc) => {\n                                    const writtenFiles = await backupSingleDocument(doc, this.options);\n                                    this.internalWriteEvents$.next({\n                                        collectionName: collection.name,\n                                        documentId: doc.primary,\n                                        files: writtenFiles,\n                                        deleted: false\n                                    });\n                                })\n                        );\n                        // handle deleted documents\n                        await Promise.all(\n                            docIds\n                                .filter(docId => !docs.has(docId))\n                                .map(async (docId) => {\n                                    await deleteFolder(documentFolder(this.options, docId));\n                                    this.internalWriteEvents$.next({\n                                        collectionName: collection.name,\n                                        documentId: docId,\n                                        files: [],\n                                        deleted: true\n                                    });\n                                })\n                        );\n\n                    }\n\n                    meta.collectionStates[collectionName].lastSequence = lastSequence;\n                    await setMeta(this.options, meta);\n                })\n        );\n\n        if (!this.initialReplicationDone$.getValue()) {\n            this.initialReplicationDone$.next(true);\n        }\n    }\n\n    public watchForChanges() {\n        const collections: RxCollection[] = Object.values(this.database.collections);\n        collections.forEach(collection => {\n            const changes$ = collection.storageInstance.changeStream();\n            const sub = changes$.subscribe(() => {\n                this.persistOnce();\n            });\n            this.subs.push(sub);\n        });\n    }\n\n    /**\n     * Returns a promise that resolves when the initial backup is done\n     * and the filesystem is in sync with the database state\n     */\n    public awaitInitialBackup(): Promise<boolean> {\n        return firstValueFrom(\n            this.initialReplicationDone$.pipe(\n                filter(v => !!v),\n                map(() => true)\n            )\n        );\n    }\n\n    cancel(): Promise<boolean> {\n        if (this.isStopped) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n        this.isStopped = true;\n        this.subs.forEach(sub => sub.unsubscribe());\n        return PROMISE_RESOLVE_TRUE;\n    }\n}\n\n\nexport function backup(\n    this: RxDatabase,\n    options: BackupOptions\n): RxBackupState {\n    const backupState = new RxBackupState(this, options);\n    backupState.persistOnce();\n\n    if (options.live) {\n        backupState.watchForChanges();\n    }\n\n    return backupState;\n}\n\nexport * from './file-util';\nexport const RxDBBackupPlugin: RxPlugin = {\n    name: 'backup',\n    rxdb: true,\n    prototypes: {\n        RxDatabase(proto: any) {\n            proto.backup = backup;\n        }\n    },\n    hooks: {\n        preDestroyRxDatabase(db: RxDatabase) {\n            const states = BACKUP_STATES_BY_DB.get(db);\n            if (states) {\n                states.forEach(state => state.cancel());\n            }\n        }\n    }\n};\n"]}
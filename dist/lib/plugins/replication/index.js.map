{"version":3,"sources":["../../../../src/plugins/replication/index.ts"],"names":["RxReplicationStateBase","replicationIdentifier","collection","pull","push","live","liveInterval","retryTime","subs","initialReplicationComplete$","undefined","subjects","received","Subject","send","error","canceled","BehaviorSubject","active","initialReplicationComplete","runningPromise","PROMISE_RESOLVE_VOID","runQueueCount","runCount","onDestroy","then","cancel","Object","keys","forEach","key","defineProperty","get","asObservable","isStopped","destroyed","getValue","awaitInitialReplication","pipe","v","PROMISE_RESOLVE_FALSE","sub","unsubscribe","next","PROMISE_RESOLVE_TRUE","run","retryOnFail","_run","willRetry","runPush","ok","setTimeout","runPull","latestDocument","handler","result","pulledDocuments","documents","length","overwritable","isDevMode","doc","withoutDeleteFlag","_deleted","schema","validate","handleDocumentsFromRemote","map","newLatestDocument","hasMoreDocuments","docs","toStorageDocs","docIds","primaryPath","storageInstance","findDocumentsById","docsFromLocal","originalDoc","documentId","docStateInLocalStorageInstance","newRevision","hasHeight","_rev","newRevisionHeight","database","lockedRun","bulkAddRevisions","batchSize","changesResult","pushDocs","Array","from","changedDocs","values","row","hasOwnProperty","_attachments","pushDoc","lastSequence","size","replicateRxCollection","waitForLeadership","multiInstance","replicationState","changeEventsSub","$","cE","isLocal","subscribe","changeEvent","rev"],"mappings":"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","sourcesContent":["import {\n    BehaviorSubject,\n    firstValueFrom,\n    Observable,\n    Subject,\n    Subscription\n} from 'rxjs';\nimport {\n    filter\n} from 'rxjs/operators';\nimport type {\n    DeepReadonlyObject,\n    ReplicationOptions,\n    ReplicationPullHandlerResult,\n    ReplicationPullOptions,\n    ReplicationPushOptions,\n    RxCollection,\n    RxDocumentData,\n    RxReplicationState,\n    WithDeleted\n} from '../../types';\nimport {\n    getChangesSinceLastPushSequence,\n    getLastPullDocument,\n    setLastPullDocument,\n    setLastPushSequence\n} from './replication-checkpoint';\nimport {\n    flatClone,\n    getHeightOfRevision,\n    lastOfArray,\n    promiseWait,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_TRUE,\n    PROMISE_RESOLVE_VOID\n} from '../../util';\nimport { overwritable } from '../../overwritable';\nimport {\n    createRevisionForPulledDocument,\n    wasRevisionfromPullReplication\n} from './revision-flag';\nimport { _handleToStorageInstance } from '../../rx-collection-helper';\nimport { newRxError } from '../../rx-error';\nimport { getDocumentDataOfRxChangeEvent } from '../../rx-change-event';\n\n\nexport class RxReplicationStateBase<RxDocType> {\n    public readonly subs: Subscription[] = [];\n    public initialReplicationComplete$: Observable<any> = undefined as any;\n\n    private subjects = {\n        received: new Subject(), // all documents that are received from the endpoint\n        send: new Subject(), // all documents that are send to the endpoint\n        error: new Subject(), // all errors that are received from the endpoint, emits new Error() objects\n        canceled: new BehaviorSubject(false), // true when the replication was canceled\n        active: new BehaviorSubject(false), // true when something is running, false when not\n        initialReplicationComplete: new BehaviorSubject(false) // true the initial replication-cycle is over\n    };\n\n    private runningPromise: Promise<void> = PROMISE_RESOLVE_VOID;\n    private runQueueCount: number = 0;\n    /**\n     * Counts how many times the run() method\n     * has been called. Used in tests.\n     */\n    public runCount: number = 0;\n\n    constructor(\n        public readonly replicationIdentifier: string,\n        public readonly collection: RxCollection<RxDocType>,\n        public readonly pull?: ReplicationPullOptions<RxDocType>,\n        public readonly push?: ReplicationPushOptions<RxDocType>,\n        public readonly live?: boolean,\n        public liveInterval?: number,\n        public retryTime?: number,\n    ) {\n\n        // stop the replication when the collection gets destroyed\n        this.collection.onDestroy.then(() => {\n            this.cancel();\n        });\n\n        // create getters for the observables\n        Object.keys(this.subjects).forEach(key => {\n            Object.defineProperty(this, key + '$', {\n                get: function () {\n                    return this.subjects[key].asObservable();\n                }\n            });\n        });\n    }\n\n    isStopped(): boolean {\n        if (this.collection.destroyed) {\n            return true;\n        }\n        if (!this.live && this.subjects.initialReplicationComplete.getValue()) {\n            return true;\n        }\n        if (this.subjects.canceled['_value']) {\n            return true;\n        }\n\n        return false;\n    }\n\n    awaitInitialReplication(): Promise<true> {\n        return firstValueFrom(\n            this.initialReplicationComplete$.pipe(\n                filter(v => v === true),\n            )\n        );\n    }\n\n    cancel(): Promise<any> {\n        if (this.isStopped()) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n        this.subs.forEach(sub => sub.unsubscribe());\n        this.subjects.canceled.next(true);\n        return PROMISE_RESOLVE_TRUE;\n    }\n\n    /**\n     * Ensures that this._run() does not run in parallel\n     */\n    async run(retryOnFail = true): Promise<void> {\n        if (this.isStopped()) {\n            return;\n        }\n\n        if (this.runQueueCount > 2) {\n            return this.runningPromise;\n        }\n\n        this.runQueueCount++;\n        this.runningPromise = this.runningPromise.then(async () => {\n            this.subjects.active.next(true);\n            const willRetry = await this._run(retryOnFail);\n            this.subjects.active.next(false);\n            if (\n                retryOnFail &&\n                !willRetry &&\n                this.subjects.initialReplicationComplete.getValue() === false\n            ) {\n                this.subjects.initialReplicationComplete.next(true);\n            }\n            this.runQueueCount--;\n        });\n        return this.runningPromise;\n    }\n\n    /**\n     * Runs the whole cycle once,\n     * first pushes the local changes to the remote,\n     * then pulls the remote changes to the local.\n     * Returns true if a retry must be done\n     */\n    async _run(retryOnFail = true): Promise<boolean> {\n        this.runCount++;\n\n        if (this.push) {\n            const ok = await this.runPush();\n            if (!ok && retryOnFail) {\n                setTimeout(() => this.run(), this.retryTime);\n                /*\n                    Because we assume that conflicts are solved on the server side,\n                    if push failed, do not attempt to pull before push was successful\n                    otherwise we do not know how to merge changes with the local state\n                */\n                return true;\n            }\n        }\n\n        if (this.pull) {\n            const ok = await this.runPull();\n            if (!ok && retryOnFail) {\n                setTimeout(() => this.run(), this.retryTime);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Pull all changes from the server,\n     * start from the last pulled change.\n     * @return true if successfully, false if something errored\n     */\n    async runPull(): Promise<boolean> {\n        if (!this.pull) {\n            throw newRxError('SNH');\n        }\n        if (this.isStopped()) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        const latestDocument = await getLastPullDocument(this.collection, this.replicationIdentifier);\n\n        let result: ReplicationPullHandlerResult<RxDocType>;\n\n        try {\n            result = await this.pull.handler(latestDocument);\n        } catch (err) {\n            this.subjects.error.next(err);\n            return false;\n        }\n\n        const pulledDocuments = result.documents;\n\n        // optimization shortcut, do not proceed if there are no documents.\n        if (pulledDocuments.length === 0) {\n            return true;\n        }\n\n        /**\n         * Run schema validation in dev-mode\n         */\n        if (overwritable.isDevMode()) {\n            try {\n                pulledDocuments.forEach((doc: any) => {\n                    const withoutDeleteFlag = flatClone(doc);\n                    delete withoutDeleteFlag._deleted;\n                    this.collection.schema.validate(withoutDeleteFlag);\n                });\n            } catch (err) {\n                this.subjects.error.next(err);\n                return false;\n            }\n        }\n\n        if (this.isStopped()) {\n            return true;\n        }\n        await this.handleDocumentsFromRemote(pulledDocuments);\n        pulledDocuments.map((doc: any) => this.subjects.received.next(doc));\n\n\n        if (pulledDocuments.length === 0) {\n            if (this.live) {\n                // console.log('no more docs, wait for ping');\n            } else {\n                // console.log('RxGraphQLReplicationState._run(): no more docs and not live; complete = true');\n            }\n        } else {\n            const newLatestDocument = lastOfArray(pulledDocuments);\n            await setLastPullDocument(\n                this.collection,\n                this.replicationIdentifier,\n                newLatestDocument\n            );\n\n            /**\n             * We have more documents on the remote,\n             * So re-run the pulling.\n             */\n            if (result.hasMoreDocuments) {\n                await this.runPull();\n            }\n        }\n\n        return true;\n    }\n\n    async handleDocumentsFromRemote(\n        docs: (WithDeleted<RxDocType> | DeepReadonlyObject<WithDeleted<RxDocType>>)[]\n    ): Promise<boolean> {\n        const toStorageDocs: RxDocumentData<RxDocType>[] = [];\n        const docIds: string[] = docs.map(doc => doc[this.collection.schema.primaryPath]) as any;\n        const docsFromLocal = await this.collection.storageInstance.findDocumentsById(docIds, true);\n\n        for (const originalDoc of docs) {\n            const doc: any = flatClone(originalDoc);\n            const documentId: string = doc[this.collection.schema.primaryPath];\n\n            const docStateInLocalStorageInstance = docsFromLocal.get(documentId);\n            let newRevision = createRevisionForPulledDocument(\n                this.replicationIdentifier,\n                doc\n            );\n            if (docStateInLocalStorageInstance) {\n                const hasHeight = getHeightOfRevision(docStateInLocalStorageInstance._rev);\n                const newRevisionHeight = hasHeight + 1;\n                newRevision = newRevisionHeight + '-' + newRevision;\n            } else {\n                newRevision = '1-' + newRevision;\n            }\n            doc._rev = newRevision;\n\n            toStorageDocs.push(doc);\n        }\n\n        if (toStorageDocs.length > 0) {\n            await this.collection.database.lockedRun(\n                async () => {\n                    await this.collection.storageInstance.bulkAddRevisions(\n                        toStorageDocs.map(doc => _handleToStorageInstance(this.collection, doc))\n                    );\n                }\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Pushes unreplicated local changes to the remote.\n     * @return true if successfull, false if not\n     */\n    async runPush(): Promise<boolean> {\n        if (!this.push) {\n            throw newRxError('SNH');\n        }\n\n        const batchSize = this.push.batchSize ? this.push.batchSize : 5;\n        const changesResult = await getChangesSinceLastPushSequence<RxDocType>(\n            this.collection,\n            this.replicationIdentifier,\n            batchSize,\n        );\n\n        const pushDocs: WithDeleted<RxDocType>[] = Array\n            .from(changesResult.changedDocs.values())\n            .map(row => {\n                const doc: WithDeleted<RxDocType> = flatClone(row.doc) as any;\n                // TODO _deleted should be required on type RxDocumentData\n                // so we do not need this check here\n                if (!doc.hasOwnProperty('_deleted')) {\n                    doc._deleted = false;\n                }\n\n                delete (doc as any)._rev;\n                delete (doc as any)._attachments;\n\n                return doc;\n            });\n\n        try {\n            await this.push.handler(pushDocs);\n        } catch (err) {\n            this.subjects.error.next(err);\n            return false;\n        }\n\n        pushDocs.forEach(pushDoc => this.subjects.send.next(pushDoc));\n\n        await setLastPushSequence(\n            this.collection,\n            this.replicationIdentifier,\n            changesResult.lastSequence\n        );\n\n        // batch had documents so there might be more changes to replicate\n        if (changesResult.changedDocs.size !== 0) {\n            await this.runPush();\n        }\n\n        return true;\n    }\n}\n\n\nexport async function replicateRxCollection<RxDocType>(\n    {\n        replicationIdentifier,\n        collection,\n        pull,\n        push,\n        live = false,\n        liveInterval = 1000 * 10,\n        retryTime = 1000 * 5,\n        waitForLeadership\n    }: ReplicationOptions<RxDocType>\n): Promise<RxReplicationState<RxDocType>> {\n\n    if (\n        waitForLeadership &&\n        // do not await leadership if not multiInstance\n        collection.database.multiInstance\n    ) {\n        await collection.database.waitForLeadership();\n    }\n\n    const replicationState = new RxReplicationStateBase<RxDocType>(\n        replicationIdentifier,\n        collection,\n        pull,\n        push,\n        live,\n        liveInterval,\n        retryTime,\n    );\n\n    // trigger run once\n    replicationState.run();\n\n    // start sync-interval\n    if (replicationState.live) {\n        if (pull) {\n            (async () => {\n                while (!replicationState.isStopped()) {\n                    await promiseWait(replicationState.liveInterval);\n                    if (replicationState.isStopped()) {\n                        return;\n                    }\n                    await replicationState.run(\n                        // do not retry on liveInterval-runs because they might stack up\n                        // when failing\n                        false\n                    );\n                }\n            })();\n        }\n\n        if (push) {\n            /**\n             * When a document is written to the collection,\n             * we might have to run the replication run() once\n             */\n            const changeEventsSub = collection.$.pipe(\n                filter(cE => !cE.isLocal)\n            )\n                .subscribe(changeEvent => {\n                    if (replicationState.isStopped()) {\n                        return;\n                    }\n                    const doc = getDocumentDataOfRxChangeEvent(changeEvent);\n                    const rev = doc._rev;\n                    if (\n                        rev &&\n                        !wasRevisionfromPullReplication(\n                            replicationIdentifier,\n                            rev\n                        )\n                    ) {\n                        replicationState.run();\n                    }\n                });\n            replicationState.subs.push(changeEventsSub);\n        }\n    }\n\n    return replicationState as any;\n}\n\nexport * from './replication-checkpoint';\nexport * from './revision-flag';\n"],"file":"index.js"}
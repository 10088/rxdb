{"version":3,"sources":["../../../../src/plugins/replication/replication-checkpoint.ts"],"names":[],"mappings":"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","file":"replication-checkpoint.js","sourcesContent":["import type {\n    RxCollection,\n    RxLocalDocumentData,\n    RxDocumentData,\n    ReplicationCheckpointDocument\n} from '../../types';\nimport {\n    findLocalDocument,\n    writeSingleLocal\n} from '../../rx-storage-helper';\nimport { flatClone } from '../../util';\nimport { newRxError } from '../../rx-error';\nimport { wasRevisionfromPullReplication } from './revision-flag';\n\n//\n// things for the push-checkpoint\n//\n\nconst pushSequenceId = (replicationIdentifier: string) => 'replication-checkpoint-push-' + replicationIdentifier;\nconst pullLastDocumentId = (replicationIdentifier: string) => 'replication-checkpoint-pull-' + replicationIdentifier;\n\n\n/**\n * Get the last push checkpoint\n */\nexport async function getLastPushSequence(\n    collection: RxCollection,\n    replicationIdentifier: string\n): Promise<number> {\n    const doc = await findLocalDocument<ReplicationCheckpointDocument>(\n        collection.localDocumentsStore,\n        pushSequenceId(replicationIdentifier)\n    );\n    if (!doc) {\n        return 0;\n    } else {\n        return doc.value;\n    }\n}\n\nexport async function setLastPushSequence(\n    collection: RxCollection,\n    replicationIdentifier: string,\n    sequence: number\n): Promise<ReplicationCheckpointDocument> {\n    const _id = pushSequenceId(replicationIdentifier);\n\n    const doc = await findLocalDocument<ReplicationCheckpointDocument>(\n        collection.localDocumentsStore,\n        _id\n    );\n    if (!doc) {\n        const res = await writeSingleLocal<ReplicationCheckpointDocument>(\n            collection.localDocumentsStore,\n            {\n                document: {\n                    _id,\n                    value: sequence,\n                    _attachments: {}\n                }\n            }\n        );\n        return res as any;\n    } else {\n        const newDoc = flatClone(doc);\n        newDoc.value = sequence;\n        const res = await writeSingleLocal<ReplicationCheckpointDocument>(\n            collection.localDocumentsStore,\n            {\n                previous: doc,\n                document: {\n                    _id,\n                    value: sequence,\n                    _attachments: {}\n                }\n            }\n        );\n        return res as any;\n    }\n}\n\n\n\nexport async function getChangesSinceLastPushSequence<RxDocType>(\n    collection: RxCollection<RxDocType, any>,\n    replicationIdentifier: string,\n    batchSize = 10\n): Promise<{\n    changedDocs: Map<string, {\n        id: string;\n        doc: RxDocumentData<RxDocType>;\n        sequence: number;\n    }>;\n    lastSequence: number;\n}> {\n    let lastPushSequence = await getLastPushSequence(\n        collection,\n        replicationIdentifier\n    );\n\n    let retry = true;\n    let lastSequence: number = lastPushSequence;\n    const changedDocs: Map<string, {\n        id: string;\n        doc: RxDocumentData<RxDocType>;\n        sequence: number;\n    }> = new Map();\n\n    /**\n     * it can happen that all docs in the batch\n     * do not have to be replicated.\n     * Then we have to continue grapping the feed\n     * until we reach the end of it\n     */\n    while (retry) {\n\n        const changesResults = await collection.storageInstance.getChangedDocuments({\n            sinceSequence: lastPushSequence,\n            limit: batchSize,\n            direction: 'after'\n        });\n        lastSequence = changesResults.lastSequence;\n\n        // optimisation shortcut, do not proceed if there are no changed documents\n        if (changesResults.changedDocuments.length === 0) {\n            retry = false;\n            continue;\n        }\n\n        const docs = await collection.storageInstance.findDocumentsById(\n            changesResults.changedDocuments.map(row => row.id),\n            true\n        );\n\n        changesResults.changedDocuments.forEach((row) => {\n            const id = row.id;\n            if (changedDocs.has(id)) {\n                return;\n            }\n            const changedDoc = docs.get(id);\n            if (!changedDoc) {\n                throw newRxError('SNH', { args: { docs } });\n            }\n\n            /**\n             * filter out changes with revisions resulting from the pull-stream\n             * so that they will not be upstreamed again\n             */\n            if (\n                wasRevisionfromPullReplication(\n                    replicationIdentifier,\n                    changedDoc._rev\n                )\n            ) {\n                return false;\n            }\n\n            changedDocs.set(id, {\n                id,\n                doc: changedDoc,\n                sequence: row.sequence\n            });\n        });\n\n\n        if (changedDocs.size < batchSize && changesResults.changedDocuments.length === batchSize) {\n            // no pushable docs found but also not reached the end -> re-run\n            lastPushSequence = lastSequence;\n            retry = true;\n        } else {\n            retry = false;\n        }\n    }\n\n    return {\n        changedDocs,\n        lastSequence\n    };\n}\n\n\n\n//\n// things for pull-checkpoint\n//\n\nexport async function getLastPullDocument<RxDocType>(\n    collection: RxCollection<RxDocType>,\n    replicationIdentifier: string,\n): Promise<RxDocumentData<RxDocType> | null> {\n    const localDoc = await findLocalDocument<any>(\n        collection.localDocumentsStore,\n        pullLastDocumentId(replicationIdentifier)\n    );\n    if (!localDoc) {\n        return null;\n    } else {\n        return localDoc.doc;\n    }\n}\n\nexport async function setLastPullDocument(\n    collection: RxCollection,\n    replicationIdentifier: string,\n    doc: any\n): Promise<{ _id: string }> {\n    const _id = pullLastDocumentId(replicationIdentifier);\n\n    const localDoc: RxLocalDocumentData = await findLocalDocument<any>(\n        collection.localDocumentsStore,\n        _id\n    );\n\n    if (!localDoc) {\n        return writeSingleLocal(\n            collection.localDocumentsStore,\n            {\n                document: {\n                    _id,\n                    doc,\n                    _attachments: {}\n                }\n            }\n        );\n    } else {\n        const newDoc = flatClone(localDoc);\n        newDoc.doc = doc;\n        return writeSingleLocal(\n            collection.localDocumentsStore,\n            {\n                previous: localDoc,\n                document: newDoc\n            }\n        );\n    }\n}\n"]}
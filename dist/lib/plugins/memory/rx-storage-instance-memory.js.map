{"version":3,"file":"rx-storage-instance-memory.js","names":["createMemoryStorageInstance","storage","params","settings","collectionKey","getMemoryCollectionKey","databaseName","collectionName","internals","collectionStates","get","removed","refCount","documents","Map","attachments","schema","undefined","byIndex","conflictResultionTasks$","Subject","addIndexesToInternalsState","set","instance","RxStorageInstanceMemory","options","changes$","closed","primaryPath","getPrimaryFieldOfPrimaryKey","primaryKey","bulkWrite","documentWrites","context","ensureNotRemoved","ret","success","error","categorized","categorizeBulkWriteRows","errors","forEach","err","documentId","stateByIndex","Object","values","bulkInsertDocs","writeRow","docId","document","putWriteRowToState","bulkUpdateDocs","attachmentsMap","attachmentsAdd","attachment","attachmentMapKey","attachmentId","attachmentData","attachmentsUpdate","attachmentsRemove","eventBulk","events","length","lastState","getNewestOfDocumentStates","checkpoint","id","lwt","_meta","next","Promise","resolve","findDocumentsById","docIds","withDeleted","docInDb","_deleted","query","preparedQuery","queryPlan","skip","limit","Infinity","skipPlusLimit","queryMatcher","RxStorageDexieStatics","getQueryMatcher","sortComparator","getSortComparator","queryPlanFields","index","mustManuallyResort","sortFieldsSameAsIndexFields","concat","lowerBound","startKeys","lowerBoundString","getStartIndexStringFromLowerBound","upperBound","endKeys","upperBoundString","getStartIndexStringFromUpperBound","indexName","getMemoryIndexName","docsWithIndex","indexOfLower","boundGE","indexString","compareDocsWithIndex","rows","done","currentDoc","doc","push","sort","slice","getChangedDocumentsSince","sinceLwt","RX_META_LWT_MINIMUM","sinceId","boundGT","lastDoc","lastOfArray","cleanup","minimumDeletedTime","maxDeletionTime","now","removeDocFromState","getAttachmentData","data","getFromMapOrThrow","changeStream","asObservable","remove","close","newRxError","database","collection","complete","conflictResultionTasks","resolveConflictResultionTask","_taskSolution","PROMISE_RESOLVE_VOID"],"sources":["../../../../src/plugins/memory/rx-storage-instance-memory.ts"],"sourcesContent":["import {\n    Observable,\n    Subject\n} from 'rxjs';\nimport {\n    getStartIndexStringFromLowerBound,\n    getStartIndexStringFromUpperBound\n} from '../../custom-index';\nimport { newRxError } from '../../rx-error';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport { categorizeBulkWriteRows, getNewestOfDocumentStates } from '../../rx-storage-helper';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxDocumentData,\n    RxDocumentDataById,\n    RxJsonSchema,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageDefaultCheckpoint,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult,\n    StringKeys\n} from '../../types';\nimport {\n    getFromMapOrThrow,\n    lastOfArray,\n    now,\n    PROMISE_RESOLVE_VOID,\n    RX_META_LWT_MINIMUM\n} from '../../util';\nimport { RxStorageDexieStatics } from '../dexie/rx-storage-dexie';\nimport {\n    boundGE,\n    boundGT\n} from './binary-search-bounds';\nimport {\n    attachmentMapKey,\n    compareDocsWithIndex,\n    ensureNotRemoved,\n    getMemoryCollectionKey,\n    putWriteRowToState,\n    removeDocFromState\n} from './memory-helper';\nimport {\n    addIndexesToInternalsState,\n    getMemoryIndexName\n} from './memory-indexes';\nimport type {\n    MemoryPreparedQuery,\n    MemoryStorageInternals,\n    RxStorageMemory,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageMemorySettings\n} from './memory-types';\n\nexport class RxStorageInstanceMemory<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    MemoryStorageInternals<RxDocType>,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageDefaultCheckpoint\n> {\n\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = new Subject();\n    public closed = false;\n\n    constructor(\n        public readonly storage: RxStorageMemory,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: MemoryStorageInternals<RxDocType>,\n        public readonly options: Readonly<RxStorageMemoryInstanceCreationOptions>,\n        public readonly settings: RxStorageMemorySettings\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n    }\n\n    bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        ensureNotRemoved(this);\n\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            success: {},\n            error: {}\n        };\n\n        const categorized = categorizeBulkWriteRows<RxDocType>(\n            this,\n            this.primaryPath as any,\n            this.internals.documents,\n            documentWrites,\n            context\n        );\n        categorized.errors.forEach(err => {\n            ret.error[err.documentId] = err;\n        });\n\n        /**\n         * Do inserts/updates\n         */\n        const stateByIndex = Object.values(this.internals.byIndex);\n\n        categorized.bulkInsertDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                docId as any,\n                this.internals,\n                stateByIndex,\n                writeRow,\n                undefined\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        categorized.bulkUpdateDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                docId as any,\n                this.internals,\n                stateByIndex,\n                writeRow,\n                this.internals.documents.get(docId as any)\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        /**\n         * Handle attachments\n         */\n        const attachmentsMap = this.internals.attachments;\n        categorized.attachmentsAdd.forEach(attachment => {\n            attachmentsMap.set(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                attachment.attachmentData\n            );\n        });\n        categorized.attachmentsUpdate.forEach(attachment => {\n            attachmentsMap.set(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                attachment.attachmentData\n            );\n        });\n        categorized.attachmentsRemove.forEach(attachment => {\n            attachmentsMap.delete(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId)\n            );\n        });\n\n        if (categorized.eventBulk.events.length > 0) {\n            const lastState = getNewestOfDocumentStates(\n                this.primaryPath as any,\n                Object.values(ret.success)\n            );\n            categorized.eventBulk.checkpoint = {\n                id: lastState[this.primaryPath],\n                lwt: lastState._meta.lwt\n            };\n            this.changes$.next(categorized.eventBulk);\n        }\n        return Promise.resolve(ret);\n    }\n\n    async findDocumentsById(\n        docIds: string[],\n        withDeleted: boolean\n    ): Promise<RxDocumentDataById<RxDocType>> {\n        const ret: RxDocumentDataById<RxDocType> = {};\n        docIds.forEach(docId => {\n            const docInDb = this.internals.documents.get(docId);\n            if (\n                docInDb &&\n                (\n                    !docInDb._deleted ||\n                    withDeleted\n                )\n            ) {\n                ret[docId] = docInDb;\n            }\n        });\n        return Promise.resolve(ret);\n    }\n\n    async query(preparedQuery: MemoryPreparedQuery<RxDocType>): Promise<RxStorageQueryResult<RxDocType>> {\n        const queryPlan = preparedQuery.queryPlan;\n        const query = preparedQuery.query;\n        const skip = query.skip ? query.skip : 0;\n        const limit = query.limit ? query.limit : Infinity;\n        const skipPlusLimit = skip + limit;\n\n        const queryMatcher = RxStorageDexieStatics.getQueryMatcher(\n            this.schema,\n            preparedQuery\n        );\n        const sortComparator = RxStorageDexieStatics.getSortComparator(this.schema, preparedQuery);\n\n        const queryPlanFields: string[] = queryPlan.index;\n        const mustManuallyResort = !queryPlan.sortFieldsSameAsIndexFields;\n        const index: string[] | undefined = ['_deleted'].concat(queryPlanFields);\n        let lowerBound: any[] = queryPlan.startKeys;\n        lowerBound = [false].concat(lowerBound);\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            lowerBound\n        );\n\n        let upperBound: any[] = queryPlan.endKeys;\n        upperBound = [false].concat(upperBound);\n        const upperBoundString = getStartIndexStringFromUpperBound(\n            this.schema,\n            index,\n            upperBound\n        );\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n        let indexOfLower = boundGE(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let rows: RxDocumentData<RxDocType>[] = [];\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n\n            if (\n                !currentDoc ||\n                currentDoc.indexString > upperBoundString\n            ) {\n                break;\n            }\n\n            if (queryMatcher(currentDoc.doc)) {\n                rows.push(currentDoc.doc);\n            }\n\n            if (\n                (rows.length >= skipPlusLimit && !mustManuallyResort) ||\n                indexOfLower >= docsWithIndex.length\n            ) {\n                done = true;\n            }\n\n            indexOfLower++;\n        }\n\n        if (mustManuallyResort) {\n            rows = rows.sort(sortComparator);\n        }\n\n        // apply skip and limit boundaries.\n        rows = rows.slice(skip, skipPlusLimit);\n\n        return {\n            documents: rows\n        };\n    }\n\n    async getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: RxStorageDefaultCheckpoint\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        checkpoint: RxStorageDefaultCheckpoint;\n    }> {\n        const sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n        const sinceId = checkpoint ? checkpoint.id : '';\n\n        const index = ['_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            ['_meta.lwt', this.primaryPath as any],\n            [\n                sinceLwt,\n                sinceId\n            ]\n        );\n\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        // TODO use array.slice() so we do not have to iterate here\n        const rows: RxDocumentData<RxDocType>[] = [];\n        while (rows.length < limit && indexOfLower < docsWithIndex.length) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            rows.push(currentDoc.doc);\n            indexOfLower++;\n        }\n\n        const lastDoc = lastOfArray(rows);\n        return {\n            documents: rows,\n            checkpoint: lastDoc ? {\n                id: lastDoc[this.primaryPath] as any,\n                lwt: lastDoc._meta.lwt\n            } : {\n                id: '',\n                lwt: 0\n            }\n        };\n    }\n\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        const maxDeletionTime = now() - minimumDeletedTime;\n        const index = ['_deleted', '_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            [\n                true,\n                0,\n                ''\n            ]\n        );\n\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            if (!currentDoc || currentDoc.doc._meta.lwt > maxDeletionTime) {\n                done = true;\n            } else {\n                removeDocFromState(\n                    this.primaryPath as any,\n                    this.schema,\n                    this.internals,\n                    currentDoc.doc\n                );\n                indexOfLower++;\n            }\n        }\n        return true;\n    }\n\n    getAttachmentData(documentId: string, attachmentId: string): Promise<string> {\n        ensureNotRemoved(this);\n        const data = getFromMapOrThrow(\n            this.internals.attachments,\n            attachmentMapKey(documentId, attachmentId)\n        );\n        return Promise.resolve(data.data);\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\n        ensureNotRemoved(this);\n        return this.changes$.asObservable();\n    }\n\n    async remove(): Promise<void> {\n        ensureNotRemoved(this);\n\n        this.internals.removed = true;\n        this.storage.collectionStates.delete(\n            getMemoryCollectionKey(this.databaseName, this.collectionName)\n        );\n        await this.close();\n    }\n\n    async close(): Promise<void> {\n        if (this.closed) {\n            throw newRxError('SNH', {\n                database: this.databaseName,\n                collection: this.collectionName\n            });\n        }\n        this.closed = true;\n        this.changes$.complete();\n\n        this.internals.refCount = this.internals.refCount - 1;\n        if (this.internals.refCount === 0) {\n            this.storage.collectionStates.delete(\n                getMemoryCollectionKey(this.databaseName, this.collectionName)\n            );\n        }\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return this.internals.conflictResultionTasks$.asObservable();\n    }\n    resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> {\n        return PROMISE_RESOLVE_VOID;\n    }\n}\n\nexport async function createMemoryStorageInstance<RxDocType>(\n    storage: RxStorageMemory,\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMemoryInstanceCreationOptions>,\n    settings: RxStorageMemorySettings\n): Promise<RxStorageInstanceMemory<RxDocType>> {\n    const collectionKey = getMemoryCollectionKey(params.databaseName, params.collectionName);\n\n    let internals = storage.collectionStates.get(collectionKey);\n    if (!internals) {\n        internals = {\n            removed: false,\n            refCount: 1,\n            documents: new Map(),\n            attachments: params.schema.attachments ? new Map() : undefined as any,\n            byIndex: {},\n            conflictResultionTasks$: new Subject()\n        };\n        addIndexesToInternalsState(internals, params.schema);\n        storage.collectionStates.set(collectionKey, internals);\n    } else {\n        internals.refCount = internals.refCount + 1;\n    }\n\n    const instance = new RxStorageInstanceMemory(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n    return instance;\n}\n"],"mappings":"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"}
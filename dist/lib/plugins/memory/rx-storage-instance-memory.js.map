{"version":3,"file":"rx-storage-instance-memory.js","names":["createMemoryStorageInstance","storage","params","settings","collectionKey","databaseName","collectionName","internals","collectionStates","get","removed","refCount","documents","Map","attachments","schema","undefined","byIndex","set","instance","RxStorageInstanceMemory","options","IDBKeyRange","require","changes$","Subject","closed","primaryPath","primaryKey","bulkWrite","documentWrites","ret","success","error","docsInDb","forEach","writeRow","docId","document","docInDb","categorized","errors","err","documentId","bulkInsertDocs","bulkUpdateDocs","attachmentsMap","attachmentsAdd","attachment","attachmentId","attachmentData","attachmentsUpdate","attachmentsRemove","next","eventBulk","Promise","resolve","findDocumentsById","docIds","withDeleted","_deleted","query","preparedQuery","skip","limit","Infinity","skipPlusLimit","queryPlan","pouchQueryPlan","queryMatcher","RxStorageDexieStatics","getQueryMatcher","sortComparator","getSortComparator","keyRange","Number","NEGATIVE_INFINITY","MAX_CHAR","queryPlanFields","index","def","fields","map","fieldObj","Object","keys","field","sortFields","sort","sortPart","sortFieldsSameAsIndexFields","join","isOneSortDescending","find","values","mustManuallyResort","concat","lowerBound","Array","isArray","lower","lowerBoundString","upperBound","upper","upperBoundString","indexName","docsWithIndex","indexOfLower","indexString","compareDocsWithIndex","rows","done","currentDoc","doc","push","length","slice","getChangedDocumentsSince","checkpoint","sinceLwt","lwt","RX_META_LWT_MINIMUM","sinceId","id","docData","_meta","cleanup","minimumDeletedTime","maxDeletionTime","getAttachmentData","data","changeStream","asObservable","remove","close","database","collection","complete"],"sources":["../../../../src/plugins/memory/rx-storage-instance-memory.ts"],"sourcesContent":["import { Observable, Subject } from 'rxjs';\nimport {\n    getStartIndexStringFromLowerBound,\n    getStartIndexStringFromUpperBound,\n    MAX_CHAR\n} from '../../custom-index';\nimport { newRxError } from '../../rx-error';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport { categorizeBulkWriteRows } from '../../rx-storage-helper';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    MangoQuery,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult,\n    StringKeys\n} from '../../types';\nimport { ensureNotFalsy, getFromMapOrThrow, now, RX_META_LWT_MINIMUM } from '../../util';\nimport { getDexieKeyRange } from '../dexie/query/dexie-query';\nimport { RxStorageDexieStatics } from '../dexie/rx-storage-dexie';\nimport { pouchSwapIdToPrimaryString } from '../pouchdb';\nimport { boundGE, boundGT } from './binary-search-bounds';\nimport {\n    attachmentMapKey,\n    compareDocsWithIndex,\n    ensureNotRemoved,\n    getMemoryCollectionKey,\n    putWriteRowToState,\n    removeDocFromState\n} from './memory-helper';\nimport { addIndexesToInternalsState, getMemoryIndexName } from './memory-indexes';\nimport type {\n    MemoryChangesCheckpoint,\n    MemoryPreparedQuery,\n    MemoryStorageInternals,\n    RxStorageMemory,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageMemorySettings\n} from './memory-types';\n\nconst IDBKeyRange = require('fake-indexeddb/lib/FDBKeyRange');\n\nexport class RxStorageInstanceMemory<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    MemoryStorageInternals<RxDocType>,\n    RxStorageMemoryInstanceCreationOptions\n> {\n\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>>> = new Subject();\n    public closed = false;\n\n    constructor(\n        public readonly storage: RxStorageMemory,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: MemoryStorageInternals<RxDocType>,\n        public readonly options: Readonly<RxStorageMemoryInstanceCreationOptions>,\n        public readonly settings: RxStorageMemorySettings\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n    }\n\n    bulkWrite(documentWrites: BulkWriteRow<RxDocType>[]): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        ensureNotRemoved(this);\n\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            success: {},\n            error: {}\n        };\n\n        const docsInDb: Map<RxDocumentData<RxDocType>[StringKeys<RxDocType>], RxDocumentData<RxDocType>> = new Map();\n        documentWrites.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            const docInDb = this.internals.documents.get(docId as any);\n            if (docInDb) {\n                docsInDb.set(docId as any, docInDb);\n            }\n        });\n\n        const categorized = categorizeBulkWriteRows<RxDocType>(\n            this,\n            this.primaryPath as any,\n            docsInDb,\n            documentWrites\n        );\n        categorized.errors.forEach(err => {\n            ret.error[err.documentId] = err;\n        });\n\n        /**\n         * Do inserts/updates\n         */\n        categorized.bulkInsertDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                this.primaryPath as any,\n                this.schema,\n                this.internals,\n                writeRow,\n                undefined\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        categorized.bulkUpdateDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                this.primaryPath as any,\n                this.schema,\n                this.internals,\n                writeRow,\n                docsInDb.get(docId as any)\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        /**\n         * Handle attachments\n         */\n        const attachmentsMap = this.internals.attachments;\n        categorized.attachmentsAdd.forEach(attachment => {\n            attachmentsMap.set(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                attachment.attachmentData\n            );\n        });\n        categorized.attachmentsUpdate.forEach(attachment => {\n            attachmentsMap.set(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                attachment.attachmentData\n            );\n        });\n        categorized.attachmentsRemove.forEach(attachment => {\n            attachmentsMap.delete(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId)\n            );\n        });\n\n        this.changes$.next(categorized.eventBulk);\n\n        return Promise.resolve(ret);\n    }\n\n    async findDocumentsById(\n        docIds: string[],\n        withDeleted: boolean\n    ): Promise<{ [documentId: string]: RxDocumentData<RxDocType>; }> {\n        const ret: { [documentId: string]: RxDocumentData<RxDocType>; } = {};\n        docIds.forEach(docId => {\n            const docInDb = this.internals.documents.get(docId);\n            if (\n                docInDb &&\n                (\n                    !docInDb._deleted ||\n                    withDeleted\n                )\n            ) {\n                ret[docId] = docInDb;\n            }\n        });\n        return Promise.resolve(ret);\n    }\n\n    async query(preparedQuery: MemoryPreparedQuery<RxDocType>): Promise<RxStorageQueryResult<RxDocType>> {\n        const skip = preparedQuery.skip ? preparedQuery.skip : 0;\n        const limit = preparedQuery.limit ? preparedQuery.limit : Infinity;\n        const skipPlusLimit = skip + limit;\n        const queryPlan = (preparedQuery as any).pouchQueryPlan;\n\n        const queryMatcher = RxStorageDexieStatics.getQueryMatcher(\n            this.schema,\n            preparedQuery\n        );\n        const sortComparator = RxStorageDexieStatics.getSortComparator(this.schema, preparedQuery);\n\n\n        const keyRange = getDexieKeyRange(\n            queryPlan,\n            Number.NEGATIVE_INFINITY,\n            MAX_CHAR,\n            IDBKeyRange\n        );\n\n        const queryPlanFields: string[] = queryPlan.index.def.fields\n            .map((fieldObj: any) => Object.keys(fieldObj)[0])\n            .map((field: any) => pouchSwapIdToPrimaryString(this.primaryPath, field));\n\n        const sortFields = ensureNotFalsy((preparedQuery as MangoQuery<RxDocType>).sort)\n            .map(sortPart => Object.keys(sortPart)[0]);\n\n        /**\n         * If the cursor iterated over the same index that\n         * would be used for sorting, we do not have to sort the results.\n         */\n        const sortFieldsSameAsIndexFields = queryPlanFields.join(',') === sortFields.join(',');\n        /**\n         * Also manually sort if one part of the sort is in descending order\n         * because all our indexes are ascending.\n         * TODO should we be able to define descending indexes?\n         */\n        const isOneSortDescending = preparedQuery.sort.find((sortPart: any) => Object.values(sortPart)[0] === 'desc');\n        const mustManuallyResort = isOneSortDescending || !sortFieldsSameAsIndexFields;\n\n\n        const index: string[] | undefined = ['_deleted'].concat(queryPlanFields);\n        let lowerBound = Array.isArray(keyRange.lower) ? keyRange.lower : [keyRange.lower];\n        lowerBound = [false].concat(lowerBound);\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            lowerBound\n        );\n\n        let upperBound = Array.isArray(keyRange.upper) ? keyRange.upper : [keyRange.upper];\n        upperBound = [false].concat(upperBound);\n        const upperBoundString = getStartIndexStringFromUpperBound(\n            this.schema,\n            index,\n            upperBound\n        );\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n        let indexOfLower = boundGE(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let rows: RxDocumentData<RxDocType>[] = [];\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n\n            if (\n                !currentDoc ||\n                currentDoc.indexString > upperBoundString\n            ) {\n                break;\n            }\n\n            if (queryMatcher(currentDoc.doc)) {\n                rows.push(currentDoc.doc);\n            }\n\n            if (\n                (rows.length >= skipPlusLimit && !isOneSortDescending) ||\n                indexOfLower >= docsWithIndex.length\n            ) {\n                done = true;\n            }\n\n            indexOfLower++;\n        }\n\n        if (mustManuallyResort) {\n            rows = rows.sort(sortComparator);\n        }\n\n        // apply skip and limit boundaries.\n        rows = rows.slice(skip, skipPlusLimit);\n\n\n        return {\n            documents: rows\n        };\n    }\n\n    async getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: MemoryChangesCheckpoint\n    ): Promise<{\n        document: RxDocumentData<RxDocType>;\n        checkpoint: MemoryChangesCheckpoint;\n    }[]> {\n        const sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n        const sinceId = checkpoint ? checkpoint.id : '';\n\n        const index = ['_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            ['_meta.lwt', this.primaryPath as any],\n            [\n                sinceLwt,\n                sinceId\n            ]\n        );\n\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n\n\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        // TODO use array.slice() so we do not have to iterate here\n        const rows: RxDocumentData<RxDocType>[] = [];\n        while (rows.length < limit && indexOfLower < docsWithIndex.length) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            rows.push(currentDoc.doc);\n            indexOfLower++;\n        }\n\n        return rows.map(docData => ({\n            document: docData,\n            checkpoint: {\n                id: docData[this.primaryPath] as any,\n                lwt: docData._meta.lwt\n            }\n        }));\n    }\n\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        const maxDeletionTime = now() - minimumDeletedTime;\n        const index = ['_deleted', '_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            [\n                true,\n                0,\n                ''\n            ]\n        );\n\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            if (!currentDoc || currentDoc.doc._meta.lwt > maxDeletionTime) {\n                done = true;\n            } else {\n                removeDocFromState(\n                    this.primaryPath as any,\n                    this.schema,\n                    this.internals,\n                    currentDoc.doc\n                );\n                indexOfLower++;\n            }\n        }\n\n        return true;\n    }\n\n\n    getAttachmentData(documentId: string, attachmentId: string): Promise<string> {\n        ensureNotRemoved(this);\n        const data = getFromMapOrThrow(\n            this.internals.attachments,\n            attachmentMapKey(documentId, attachmentId)\n        );\n        return Promise.resolve(data.data);\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>>> {\n        ensureNotRemoved(this);\n        return this.changes$.asObservable();\n    }\n\n    async remove(): Promise<void> {\n        ensureNotRemoved(this);\n\n        this.internals.removed = true;\n        this.storage.collectionStates.delete(\n            getMemoryCollectionKey(this.databaseName, this.collectionName)\n        );\n        await this.close();\n    }\n\n    async close(): Promise<void> {\n        if (this.closed) {\n            throw newRxError('SNH', {\n                database: this.databaseName,\n                collection: this.collectionName\n            });\n        }\n        this.closed = true;\n        this.changes$.complete();\n\n        this.internals.refCount = this.internals.refCount - 1;\n        if (this.internals.refCount === 0) {\n            this.storage.collectionStates.delete(\n                getMemoryCollectionKey(this.databaseName, this.collectionName)\n            );\n        }\n    }\n}\n\n\n\nexport async function createMemoryStorageInstance<RxDocType>(\n    storage: RxStorageMemory,\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMemoryInstanceCreationOptions>,\n    settings: RxStorageMemorySettings\n): Promise<RxStorageInstanceMemory<RxDocType>> {\n\n    const collectionKey = getMemoryCollectionKey(params.databaseName, params.collectionName);\n\n\n    let internals = storage.collectionStates.get(collectionKey);\n    if (!internals) {\n        internals = {\n            removed: false,\n            refCount: 1,\n            documents: new Map(),\n            attachments: params.schema.attachments ? new Map() : undefined as any,\n            byIndex: {}\n        };\n        addIndexesToInternalsState(internals, params.schema);\n        storage.collectionStates.set(collectionKey, internals);\n    } else {\n        internals.refCount = internals.refCount + 1;\n    }\n\n    const instance = new RxStorageInstanceMemory(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n    return instance;\n}\n"],"mappings":"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"}
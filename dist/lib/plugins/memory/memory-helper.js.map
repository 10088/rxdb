{"version":3,"file":"memory-helper.js","names":["getMemoryCollectionKey","databaseName","collectionName","ensureNotRemoved","instance","internals","removed","Error","attachmentMapKey","documentId","attachmentId","SORT_BY_INDEX_STRING","a","b","indexString","putWriteRowToState","docId","state","stateByIndex","row","docInState","documents","set","document","forEach","byIndex","docsWithIndex","newIndexString","getIndexableString","pushAtSortPosition","id","doc","insertPosition","previousIndexString","prev","splice","next","newRxError","args","indexBefore","boundEQ","compareDocsWithIndex","removeDocFromState","primaryPath","schema","Object","values","positionInIndex"],"sources":["../../../../src/plugins/memory/memory-helper.ts"],"sourcesContent":["import type {\n    BulkWriteRow,\n    RxDocumentData,\n    RxJsonSchema\n} from '../../types';\nimport type {\n    DocWithIndexString,\n    MemoryStorageInternals,\n    MemoryStorageInternalsByIndex\n} from './memory-types';\nimport type { RxStorageInstanceMemory } from './rx-storage-instance-memory';\nimport {\n    pushAtSortPosition\n} from 'array-push-at-sort-position';\nimport { newRxError } from '../../rx-error';\nimport { boundEQ } from './binary-search-bounds';\n\n\nexport function getMemoryCollectionKey(\n    databaseName: string,\n    collectionName: string\n): string {\n    return databaseName + '--memory--' + collectionName;\n}\n\n\nexport function ensureNotRemoved(\n    instance: RxStorageInstanceMemory<any>\n) {\n    if (instance.internals.removed) {\n        throw new Error('removed');\n    }\n}\n\nexport function attachmentMapKey(documentId: string, attachmentId: string): string {\n    return documentId + '||' + attachmentId;\n}\n\nconst SORT_BY_INDEX_STRING = (a: DocWithIndexString<any>, b: DocWithIndexString<any>) => {\n    if (a.indexString < b.indexString) {\n        return -1;\n    } else {\n        return 1;\n    }\n};\n\n\n\nexport function putWriteRowToState<RxDocType>(\n    docId: string,\n    state: MemoryStorageInternals<RxDocType>,\n    stateByIndex: MemoryStorageInternalsByIndex<RxDocType>[],\n    row: BulkWriteRow<RxDocType>,\n    docInState?: RxDocumentData<RxDocType>\n) {\n    state.documents.set(docId, row.document);\n    stateByIndex.forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const newIndexString = byIndex.getIndexableString(row.document);\n        const [, insertPosition] = pushAtSortPosition(\n            docsWithIndex,\n            {\n                id: docId,\n                doc: row.document,\n                indexString: newIndexString\n            },\n            SORT_BY_INDEX_STRING,\n            true\n        );\n\n        /**\n         * Remove previous if it was in the state\n         */\n        if (docInState) {\n            const previousIndexString = byIndex.getIndexableString(docInState);\n            if (previousIndexString === newIndexString) {\n                /**\n                 * Index not changed -> The old doc must be before or after the new one.\n                 */\n                const prev = docsWithIndex[insertPosition - 1];\n                if (prev && prev.id === docId) {\n                    docsWithIndex.splice(insertPosition - 1, 1)\n                } else {\n                    const next = docsWithIndex[insertPosition + 1];\n                    if (next.id === docId) {\n                        docsWithIndex.splice(insertPosition + 1, 1)\n                    } else {\n                        throw newRxError('SNH', {\n                            args: {\n                                row,\n                                byIndex\n                            }\n                        });\n                    }\n                }\n            } else {\n                /**\n                 * Index changed, we must search for the old one and remove it.\n                 */\n                const indexBefore = boundEQ(\n                    docsWithIndex,\n                    {\n                        indexString: previousIndexString\n                    } as any,\n                    compareDocsWithIndex\n                );\n                docsWithIndex.splice(indexBefore, 1)\n            }\n        }\n    });\n}\n\n\nexport function removeDocFromState<RxDocType>(\n    primaryPath: string,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    state: MemoryStorageInternals<RxDocType>,\n    doc: RxDocumentData<RxDocType>\n) {\n    const docId: string = (doc as any)[primaryPath];\n    state.documents.delete(docId);\n\n    Object.values(state.byIndex).forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const indexString = byIndex.getIndexableString(doc);\n\n        const positionInIndex = boundEQ(\n            docsWithIndex,\n            {\n                indexString\n            } as any,\n            compareDocsWithIndex\n        );\n        docsWithIndex.splice(positionInIndex, 1);\n    });\n}\n\n\nexport function compareDocsWithIndex<RxDocType>(\n    a: DocWithIndexString<RxDocType>,\n    b: DocWithIndexString<RxDocType>\n): 1 | 0 | -1 {\n    if (a.indexString < b.indexString) {\n        return -1;\n    } else if (a.indexString === b.indexString) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n"],"mappings":"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"}
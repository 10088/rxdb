{"version":3,"file":"memory-helper.js","names":["getMemoryCollectionKey","databaseName","collectionName","ensureNotRemoved","instance","internals","removed","Error","putWriteRowToState","primaryPath","schema","state","row","docInState","docId","document","documents","set","Object","values","byIndex","forEach","docsWithIndex","newIndexString","index","id","doc","indexString","a","b","insertPosition","previousIndexString","prev","splice","next","args","indexBefore","compareDocsWithIndex","removeDocFromState","positionInIndex"],"sources":["../../../../src/plugins/memory/memory-helper.ts"],"sourcesContent":["import { getIndexableString } from '../../custom-index';\nimport type { BulkWriteRow, RxDocumentData, RxJsonSchema } from '../../types';\nimport type { DocWithIndexString, MemoryStorageInternals } from './memory-types';\nimport type { RxStorageInstanceMemory } from './rx-storage-instance-memory';\nimport {\n    pushAtSortPosition\n} from 'array-push-at-sort-position';\nimport { newRxError } from '../../rx-error';\nimport { boundEQ } from './binary-search-bounds';\n\n\nexport function getMemoryCollectionKey(\n    databaseName: string,\n    collectionName: string\n): string {\n    return databaseName + '--memory--' + collectionName;\n}\n\n\nexport function ensureNotRemoved(\n    instance: RxStorageInstanceMemory<any>\n) {\n    if (instance.internals.removed) {\n        throw new Error('removed');\n    }\n}\n\nexport function putWriteRowToState<RxDocType>(\n    primaryPath: string,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    state: MemoryStorageInternals<RxDocType>,\n    row: BulkWriteRow<RxDocType>,\n    docInState?: RxDocumentData<RxDocType>\n) {\n    const docId: string = (row.document as any)[primaryPath];\n    state.documents.set(docId, row.document);\n\n\n    Object.values(state.byIndex).forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const newIndexString = getIndexableString(schema, byIndex.index, row.document);\n\n        const [, insertPosition] = pushAtSortPosition(\n            docsWithIndex,\n            {\n                id: docId,\n                doc: row.document,\n                indexString: newIndexString\n            },\n            (a: DocWithIndexString<RxDocType>, b: DocWithIndexString<RxDocType>) => {\n                if (a.indexString < b.indexString) {\n                    return -1;\n                } else {\n                    return 1;\n                }\n            },\n            true\n        );\n\n\n        /**\n         * Remove previous if it was in the state\n         */\n        if (docInState) {\n            const previousIndexString = getIndexableString(schema, byIndex.index, docInState);\n            if (previousIndexString === newIndexString) {\n                /**\n                 * Index not changed -> The old doc must be before or after the new one.\n                 */\n                const prev = docsWithIndex[insertPosition - 1];\n                if (prev && prev.id === docId) {\n                    docsWithIndex.splice(insertPosition - 1, 1)\n                } else {\n                    const next = docsWithIndex[insertPosition + 1];\n                    if (next.id === docId) {\n                        docsWithIndex.splice(insertPosition + 1, 1)\n                    } else {\n                        throw newRxError('SNH', {\n                            args: {\n                                row,\n                                byIndex\n                            }\n                        });\n                    }\n                }\n            } else {\n                /**\n                 * Index changed, we must search for the old one and remove it.\n                 */\n                const indexBefore = boundEQ(\n                    docsWithIndex,\n                    {\n                        indexString: previousIndexString\n                    } as any,\n                    compareDocsWithIndex\n                );\n                docsWithIndex.splice(indexBefore, 1)\n            }\n        }\n    });\n}\n\n\nexport function removeDocFromState<RxDocType>(\n    primaryPath: string,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    state: MemoryStorageInternals<RxDocType>,\n    doc: RxDocumentData<RxDocType>\n) {\n    const docId: string = (doc as any)[primaryPath];\n    state.documents.delete(docId);\n\n    Object.values(state.byIndex).forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const indexString = getIndexableString(schema, byIndex.index, doc);\n\n        const positionInIndex = boundEQ(\n            docsWithIndex,\n            {\n                indexString\n            } as any,\n            compareDocsWithIndex\n        );\n        docsWithIndex.splice(positionInIndex, 1);\n    });\n}\n\n\nexport function compareDocsWithIndex<RxDocType>(\n    a: DocWithIndexString<RxDocType>,\n    b: DocWithIndexString<RxDocType>\n): 1 | 0 | -1 {\n    if (a.indexString < b.indexString) {\n        return -1;\n    } else if (a.indexString === b.indexString) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n"],"mappings":"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"}
{"version":3,"sources":["../../../../src/plugins/migration/data-migrator.ts"],"names":[],"mappings":"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","file":"data-migrator.js","sourcesContent":["/**\n * The DataMigrator handles the documents from collections with older schemas\n * and transforms/saves them into the newest collection\n */\n/**\n * TODO this should be completely rewritten because:\n * - The current implemetation does not use bulkDocs which is much faster\n * - This could have been done in much less code which would be easier to uderstand\n *\n */\nimport {\n    Subject,\n    Observable\n} from 'rxjs';\nimport deepEqual from 'deep-equal';\nimport {\n    clone,\n    toPromise,\n    flatClone,\n    getHeightOfRevision,\n    createRevision,\n    PROMISE_RESOLVE_VOID,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_NULL,\n    ensureNotFalsy\n} from '../../util';\nimport {\n    createRxSchema\n} from '../../rx-schema';\nimport {\n    RxError,\n    newRxError\n} from '../../rx-error';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from '../../hooks';\nimport type {\n    RxCollection,\n    RxDatabase,\n    MigrationState,\n    NumberFunctionMap,\n    OldRxCollection,\n    WithAttachmentsData,\n    RxJsonSchema,\n    RxDocumentData\n} from '../../types';\nimport {\n    RxSchema,\n    getPreviousVersions\n} from '../../rx-schema';\nimport {\n    createCrypter\n} from '../../crypter';\nimport {\n    getMigrationStateByDatabase,\n    MigrationStateWithCollection\n} from './migration-state';\nimport { map } from 'rxjs/operators';\nimport {\n    countAllUndeleted,\n    getBatch,\n    getSingleDocument\n} from '../../rx-storage-helper';\nimport { InternalStoreDocumentData } from '../../rx-database';\nimport {\n    _handleFromStorageInstance,\n    _handleToStorageInstance\n} from '../../rx-collection-helper';\n\nexport class DataMigrator {\n\n    constructor(\n        public newestCollection: RxCollection,\n        public migrationStrategies: NumberFunctionMap\n    ) {\n        this.currentSchema = newestCollection.schema;\n        this.database = newestCollection.database;\n        this.name = newestCollection.name;\n    }\n\n    public currentSchema: RxSchema;\n    public database: RxDatabase;\n    public name: string;\n\n\n    private _migrated: boolean = false;\n    private _migratePromise?: Promise<any>;\n    private nonMigratedOldCollections: OldRxCollection[] = [];\n    private allOldCollections: OldRxCollection[] = [];\n    migrate(batchSize: number = 10): Observable<MigrationState> {\n        if (this._migrated) {\n            throw newRxError('DM1');\n        }\n        this._migrated = true;\n\n        const state = {\n            done: false, // true if finished\n            total: 0, // will be the doc-count\n            handled: 0, // amount of handled docs\n            success: 0, // handled docs which successed\n            deleted: 0, // handled docs which got deleted\n            percent: 0 // percentage\n        };\n\n        const stateSubject: Subject<MigrationStateWithCollection> = new Subject();\n\n        /**\n         * Add to output of RxDatabase.migrationStates\n         */\n        const allSubject = getMigrationStateByDatabase(this.newestCollection.database);\n        const allList = allSubject.getValue().slice(0);\n        allList.push(stateSubject.asObservable());\n        allSubject.next(allList);\n\n        /**\n         * TODO this is a side-effect which might throw\n         * We did this because it is not possible to create new Observer(async(...))\n         * @link https://github.com/ReactiveX/rxjs/issues/4074\n         * In the future the whole migration plugin should be rewritten without rxjs\n         * so we do not have this problem.\n         */\n        (() => {\n            return _getOldCollections(this)\n                .then(ret => {\n                    this.nonMigratedOldCollections = ret;\n                    this.allOldCollections = this.nonMigratedOldCollections.slice(0);\n                    const countAll: Promise<number[]> = Promise.all(\n                        this.nonMigratedOldCollections.map(oldCol => countAllUndeleted(oldCol.storageInstance))\n                    );\n                    return countAll;\n                })\n                .then(countAll => {\n                    const totalCount: number = countAll\n                        .reduce((cur, prev) => prev = cur + prev, 0);\n                    state.total = totalCount;\n                    stateSubject.next({\n                        collection: this.newestCollection,\n                        state: flatClone(state)\n                    });\n                    let currentCol = this.nonMigratedOldCollections.shift();\n                    let currentPromise = PROMISE_RESOLVE_VOID;\n                    while (currentCol) {\n                        const migrationState$ = migrateOldCollection(\n                            currentCol,\n                            batchSize\n                        );\n                        currentPromise = currentPromise.then(() => {\n                            return new Promise(res => {\n                                const sub = migrationState$.subscribe(\n                                    (subState: any) => {\n                                        state.handled++;\n                                        (state as any)[subState.type] = (state as any)[subState.type] + 1;\n                                        state.percent = Math.round(state.handled / state.total * 100);\n                                        stateSubject.next({\n                                            collection: this.newestCollection,\n                                            state: flatClone(state)\n                                        });\n                                    },\n                                    (e: any) => {\n                                        sub.unsubscribe();\n                                        this.allOldCollections.forEach(c => c.storageInstance.close());\n                                        stateSubject.error(e);\n                                    }, () => {\n                                        if (currentCol) {\n                                            currentCol.storageInstance.close();\n                                        }\n                                        sub.unsubscribe();\n                                        res();\n                                    });\n                            });\n                        });\n                        currentCol = this.nonMigratedOldCollections.shift();\n                    }\n                    return currentPromise;\n                })\n                .then(() => {\n                    state.done = true;\n                    state.percent = 100;\n                    stateSubject.next({\n                        collection: this.newestCollection,\n                        state: flatClone(state)\n                    });\n                    stateSubject.complete();\n                });\n        })();\n\n\n        return stateSubject.pipe(\n            map(withCollection => withCollection.state)\n        );\n    }\n\n    migratePromise(batchSize: number): Promise<any> {\n        if (!this._migratePromise) {\n            this._migratePromise = mustMigrate(this)\n                .then(must => {\n                    if (!must) {\n                        return PROMISE_RESOLVE_FALSE;\n                    } else {\n                        return new Promise((res, rej) => {\n                            const state$ = this.migrate(batchSize);\n                            (state$ as any).subscribe(null, rej, res);\n                            this.allOldCollections.forEach(c => c.storageInstance.close());\n                        })\n                            .catch(err => {\n                                this.allOldCollections.forEach(c => c.storageInstance.close());\n                                throw err;\n                            });\n                    }\n                });\n        }\n        return this._migratePromise;\n    }\n}\n\nexport async function createOldCollection(\n    version: number,\n    schemaObj: RxJsonSchema<any>,\n    dataMigrator: DataMigrator\n): Promise<OldRxCollection> {\n    const database = dataMigrator.newestCollection.database;\n    const schema = createRxSchema(schemaObj, false);\n\n    const storageInstanceCreationParams = {\n        databaseName: database.name,\n        collectionName: dataMigrator.newestCollection.name,\n        schema: schemaObj,\n        options: dataMigrator.newestCollection.instanceCreationOptions\n    };\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    const storageInstance = await database.storage.createStorageInstance(\n        storageInstanceCreationParams\n    );\n    const ret: OldRxCollection = {\n        version,\n        dataMigrator,\n        newestCollection: dataMigrator.newestCollection,\n        database,\n        schema: createRxSchema(schemaObj, false),\n        storageInstance,\n        _crypter: createCrypter(\n            database.password,\n            schema\n        )\n    };\n\n    return ret;\n}\n\n\nexport async function getOldCollectionDocs(\n    dataMigrator: DataMigrator\n): Promise<RxDocumentData<InternalStoreDocumentData>[]> {\n    return Promise.all(\n        getPreviousVersions(dataMigrator.currentSchema.jsonSchema)\n            .map(v => getSingleDocument<InternalStoreDocumentData>(dataMigrator.database.internalStore, dataMigrator.name + '-' + v))\n            .map(fun => fun.catch(() => null)) // auto-catch so Promise.all continues\n    )\n        .then(oldCollectionDocs => (oldCollectionDocs as any).filter((d: any) => !!d));\n}\n\n/**\n * get an array with OldCollection-instances from all existing old storage-instances\n */\nexport async function _getOldCollections(\n    dataMigrator: DataMigrator\n): Promise<OldRxCollection[]> {\n    const oldColDocs = await getOldCollectionDocs(dataMigrator);\n\n    return Promise.all(\n        oldColDocs\n            .map(colDoc => {\n                if (!colDoc) {\n                    return null as any;\n                }\n                return createOldCollection(\n                    colDoc.schema.version,\n                    colDoc.schema,\n                    dataMigrator\n                );\n            })\n            .filter(colDoc => colDoc !== null)\n    );\n}\n\n\n/**\n * returns true if a migration is needed\n */\nexport function mustMigrate(dataMigrator: DataMigrator): Promise<boolean> {\n    if (dataMigrator.currentSchema.version === 0) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n    return getOldCollectionDocs(dataMigrator)\n        .then(oldColDocs => {\n            if (oldColDocs.length === 0) {\n                return false;\n            } else {\n                return true;\n            }\n        });\n}\n\nexport function runStrategyIfNotNull(\n    oldCollection: OldRxCollection,\n    version: number,\n    docOrNull: any | null\n): Promise<any | null> {\n    if (docOrNull === null) {\n        return PROMISE_RESOLVE_NULL;\n    } else {\n        const ret = oldCollection.dataMigrator.migrationStrategies[version](docOrNull, oldCollection);\n        const retPromise = toPromise(ret);\n        return retPromise;\n    }\n}\n\nexport function getBatchOfOldCollection(\n    oldCollection: OldRxCollection,\n    batchSize: number\n): Promise<any[]> {\n    return getBatch(\n        oldCollection.storageInstance,\n        batchSize\n    )\n        .then(docs => docs\n            .map(doc => {\n                doc = flatClone(doc);\n                doc = _handleFromStorageInstance(oldCollection as any, doc);\n                return doc;\n            })\n        );\n}\n\n/**\n * runs the doc-data through all following migrationStrategies\n * so it will match the newest schema.\n * @throws Error if final doc does not match final schema or migrationStrategy crashes\n * @return final object or null if migrationStrategy deleted it\n */\nexport function migrateDocumentData(\n    oldCollection: OldRxCollection,\n    docData: any\n): Promise<any | null> {\n    /**\n     * We cannot deep-clone Blob or Buffer\n     * so we just flat clone it here\n     * and attach it to the deep cloned document data.\n     */\n    const attachmentsBefore = flatClone(docData._attachments);\n    const mutateableDocData = clone(docData);\n    mutateableDocData._attachments = attachmentsBefore;\n\n    let nextVersion = oldCollection.version + 1;\n\n    // run the document throught migrationStrategies\n    let currentPromise = Promise.resolve(mutateableDocData);\n    while (nextVersion <= oldCollection.newestCollection.schema.version) {\n        const version = nextVersion;\n        currentPromise = currentPromise.then(docOrNull => runStrategyIfNotNull(\n            oldCollection,\n            version,\n            docOrNull\n        ));\n        nextVersion++;\n    }\n\n    return currentPromise.then(doc => {\n        if (doc === null) {\n            return PROMISE_RESOLVE_NULL;\n        }\n\n        // check final schema\n        try {\n            oldCollection.newestCollection.schema.validate(doc);\n        } catch (err) {\n            const asRxError: RxError = err as any;\n            throw newRxError('DM2', {\n                fromVersion: oldCollection.version,\n                toVersion: oldCollection.newestCollection.schema.version,\n                originalDoc: docData,\n                finalDoc: doc,\n                /**\n                 * pass down data from parent error,\n                 * to make it better understandable what did not work\n                 */\n                errors: asRxError.parameters.errors,\n                schema: asRxError.parameters.schema\n            });\n        }\n        return doc;\n    });\n}\n\n\nexport function isDocumentDataWithoutRevisionEqual<T>(doc1: T, doc2: T): boolean {\n    const doc1NoRev = Object.assign({}, doc1, {\n        _attachments: undefined,\n        _rev: undefined\n    });\n    const doc2NoRev = Object.assign({}, doc2, {\n        _attachments: undefined,\n        _rev: undefined\n    });\n    return deepEqual(doc1NoRev, doc2NoRev);\n}\n\n/**\n * transform documents data and save them to the new collection\n * @return status-action with status and migrated document\n */\nexport async function _migrateDocuments(\n    oldCollection: OldRxCollection,\n    documentsData: any[]\n): Promise<{ type: string, doc: any }[]> {\n\n    // run hooks that might mutate documentsData\n    await Promise.all(\n        documentsData.map(docData => runAsyncPluginHooks(\n            'preMigrateDocument',\n            {\n                docData,\n                oldCollection\n            }\n        ))\n    );\n    // run the migration strategies on each document\n    const migratedDocuments: (any | null)[] = await Promise.all(\n        documentsData.map(docData => migrateDocumentData(oldCollection, docData))\n    );\n\n\n    const bulkWriteToStorageInput: any[] = [];\n    const actions: any[] = [];\n\n    documentsData.forEach((docData, idx) => {\n        const migratedDocData: any | null = migratedDocuments[idx];\n        const action = {\n            res: null as any,\n            type: '',\n            migrated: migratedDocData,\n            doc: docData,\n            oldCollection,\n            newestCollection: oldCollection.newestCollection\n        };\n        actions.push(action);\n\n        /**\n         * Determiniticly handle the revision\n         * so migrating the same data on multiple instances\n         * will result in the same output.\n         */\n        if (isDocumentDataWithoutRevisionEqual(docData, migratedDocData)) {\n            /**\n             * Data not changed by migration strategies, keep the same revision.\n             * This ensures that other replicated instances that did not migrate already\n             * will still have the same document.\n             */\n            migratedDocData._rev = docData._rev;\n        } else if (migratedDocData !== null) {\n            /**\n             * data changed, increase revision height\n             * so replicating instances use our new document data\n             */\n            const newHeight = getHeightOfRevision(docData._rev) + 1;\n            const newRevision = newHeight + '-' + createRevision(migratedDocData, true);\n            migratedDocData._rev = newRevision;\n        }\n\n\n        if (migratedDocData) {\n            /**\n             * save to newest collection\n             * notice that this data also contains the attachments data\n             */\n            const attachmentsBefore = migratedDocData._attachments;\n            const saveData: WithAttachmentsData<any> = _handleToStorageInstance(oldCollection.newestCollection, migratedDocData);\n            saveData._attachments = attachmentsBefore;\n            bulkWriteToStorageInput.push(saveData);\n            action.res = saveData;\n            action.type = 'success';\n        } else {\n            /**\n             * Migration strategy returned null\n             * which means we should not migrate this document,\n             * just drop it.\n             */\n            action.type = 'deleted';\n        }\n    });\n\n\n    /**\n     * Write the documents to the newest collection.\n     * We need to add as revision\n     * because we provide the _rev by our own\n     * to have deterministic revisions in case the migration\n     * runs on multiple nodes which must lead to the equal storage state.\n     */\n    if (bulkWriteToStorageInput.length) {\n        await oldCollection.newestCollection.storageInstance.bulkAddRevisions(bulkWriteToStorageInput);\n    }\n\n    // run hooks\n    await Promise.all(\n        actions.map(action => runAsyncPluginHooks(\n            'postMigrateDocument',\n            action\n        ))\n    );\n\n    // remove the documents from the old collection storage instance\n    const bulkDeleteInputData = documentsData.map(docData => {\n        const writeDeleted = flatClone(docData);\n        writeDeleted._deleted = true;\n        return {\n            previous: _handleToStorageInstance(oldCollection as any, docData),\n            document: _handleToStorageInstance(oldCollection as any, writeDeleted)\n        };\n    });\n\n    if (bulkDeleteInputData.length) {\n        await oldCollection.storageInstance.bulkWrite(bulkDeleteInputData);\n    }\n\n    return actions;\n}\n\n\n/**\n * deletes this.storageInstance and removes it from the database.collectionsCollection\n */\nexport function deleteOldCollection(\n    oldCollection: OldRxCollection\n): Promise<void> {\n    return oldCollection.storageInstance.remove()\n        .then(\n            () => oldCollection.database.removeCollectionDoc(\n                oldCollection.dataMigrator.name,\n                oldCollection.schema\n            )\n        );\n}\n\n/**\n * runs the migration on all documents and deletes the storage instance afterwards\n */\nexport function migrateOldCollection(\n    oldCollection: OldRxCollection,\n    batchSize = 10\n): Observable<any> {\n    if (oldCollection._migrate) {\n        // already running\n        throw newRxError('DM3');\n    }\n    oldCollection._migrate = true;\n\n    const observer = new Subject();\n\n    /**\n     * TODO this is a side-effect which might throw\n     * @see DataMigrator.migrate()\n     */\n    (() => {\n        let error: any;\n        const allBatchesDone = () => {\n            // remove this oldCollection\n            return deleteOldCollection(oldCollection)\n                .then(() => observer.complete());\n        };\n        const handleOneBatch = () => {\n            return getBatchOfOldCollection(oldCollection, batchSize)\n                .then(batch => {\n                    if (batch.length === 0) {\n                        allBatchesDone();\n                        return false;\n                    } else {\n                        return _migrateDocuments(oldCollection, batch)\n                            .then((actions: any[]) => actions.forEach(action => observer.next(action)))\n                            .catch(e => error = e)\n                            .then(() => true);\n                    }\n                })\n                .then(next => {\n                    if (!next) {\n                        return;\n                    }\n                    if (error) {\n                        observer.error(error);\n                    } else {\n                        handleOneBatch();\n                    }\n                });\n        };\n        handleOneBatch();\n    })();\n\n    return observer.asObservable();\n}\n\nexport function migratePromise(\n    oldCollection: OldRxCollection,\n    batchSize?: number\n): Promise<any> {\n    if (!oldCollection._migratePromise) {\n        oldCollection._migratePromise = new Promise((res, rej) => {\n            const state$ = migrateOldCollection(oldCollection, batchSize);\n            (state$ as any).subscribe(null, rej, res);\n        });\n    }\n    return oldCollection._migratePromise;\n}\n"]}
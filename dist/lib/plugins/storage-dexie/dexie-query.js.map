{"version":3,"file":"dexie-query.js","names":["getKeyRangeByQueryPlan","queryPlan","IDBKeyRange","window","Error","ret","index","length","bound","startKeys","endKeys","inclusiveStart","inclusiveEnd","dexieQuery","instance","preparedQuery","internals","state","query","skip","limit","Infinity","skipPlusLimit","queryMatcher","selectorSatisfiedByIndex","RxStorageDexieStatics","getQueryMatcher","schema","keyRange","dexieDb","_options","queryPlanFields","rows","transaction","dexieTable","dexieTx","tx","idbtrans","store","objectStore","DEXIE_DOCS_TABLE_NAME","primaryPath","indexName","dexieReplaceIfStartsWithPipe","map","field","join","cursorReq","openCursor","Promise","res","onsuccess","e","cursor","target","result","docData","fromDexieToStorage","value","_deleted","push","sortFieldsSameAsIndexFields","sortComparator","getSortComparator","sort","slice","documents","dexieCount","count","request","rej","onerror","err"],"sources":["../../../../src/plugins/storage-dexie/dexie-query.ts"],"sourcesContent":["import { QueryMatcher } from 'event-reduce-js';\nimport type {\n    DexiePreparedQuery,\n    RxDocumentData,\n    RxQueryPlan,\n    RxStorageQueryResult\n} from '../../types';\nimport {\n    dexieReplaceIfStartsWithPipe,\n    DEXIE_DOCS_TABLE_NAME,\n    fromDexieToStorage\n} from './dexie-helper';\nimport { RxStorageDexieStatics } from './dexie-statics';\nimport type { RxStorageInstanceDexie } from './rx-storage-instance-dexie';\n\n\nexport function getKeyRangeByQueryPlan(\n    queryPlan: RxQueryPlan,\n    IDBKeyRange?: any\n) {\n    if (!IDBKeyRange) {\n        if (typeof window === 'undefined') {\n            throw new Error('IDBKeyRange missing');\n        } else {\n            IDBKeyRange = window.IDBKeyRange;\n        }\n    }\n\n    let ret: any;\n    /**\n     * If index has only one field,\n     * we have to pass the keys directly, not the key arrays.\n     */\n    if (queryPlan.index.length === 1) {\n        ret = IDBKeyRange.bound(\n            queryPlan.startKeys[0],\n            queryPlan.endKeys[0],\n            queryPlan.inclusiveStart,\n            queryPlan.inclusiveEnd\n        );\n    } else {\n        ret = IDBKeyRange.bound(\n            queryPlan.startKeys,\n            queryPlan.endKeys,\n            queryPlan.inclusiveStart,\n            queryPlan.inclusiveEnd\n        );\n    }\n    return ret;\n}\n\n\n/**\n * Runs mango queries over the Dexie.js database.\n */\nexport async function dexieQuery<RxDocType>(\n    instance: RxStorageInstanceDexie<RxDocType>,\n    preparedQuery: DexiePreparedQuery<RxDocType>\n): Promise<RxStorageQueryResult<RxDocType>> {\n    const state = await instance.internals;\n    const query = preparedQuery.query;\n\n    const skip = query.skip ? query.skip : 0;\n    const limit = query.limit ? query.limit : Infinity;\n    const skipPlusLimit = skip + limit;\n    const queryPlan = preparedQuery.queryPlan;\n\n    let queryMatcher: QueryMatcher<RxDocumentData<RxDocType>> | false = false;\n    if (!queryPlan.selectorSatisfiedByIndex) {\n        queryMatcher = RxStorageDexieStatics.getQueryMatcher(\n            instance.schema,\n            preparedQuery\n        );\n    }\n\n    const keyRange = getKeyRangeByQueryPlan(\n        queryPlan,\n        (state.dexieDb as any)._options.IDBKeyRange\n    );\n\n    const queryPlanFields: string[] = queryPlan.index;\n\n    let rows: any[] = [];\n    await state.dexieDb.transaction(\n        'r',\n        state.dexieTable,\n        async (dexieTx) => {\n            /**\n             * TODO here we use the native IndexedDB transaction\n             * to get the cursor.\n             * Instead we should not leave Dexie.js API and find\n             * a way to create the cursor with Dexie.js.\n             */\n            const tx = (dexieTx as any).idbtrans;\n\n            // const nativeIndexedDB = state.dexieDb.backendDB();\n            // const trans = nativeIndexedDB.transaction([DEXIE_DOCS_TABLE_NAME], 'readonly');\n\n            const store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\n            let index: any;\n            if (\n                queryPlanFields.length === 1 &&\n                queryPlanFields[0] === instance.primaryPath\n            ) {\n                index = store;\n            } else {\n                let indexName: string;\n                if (queryPlanFields.length === 1) {\n                    indexName = dexieReplaceIfStartsWithPipe(queryPlanFields[0]);\n                } else {\n                    indexName = '[' +\n                        queryPlanFields\n                            .map(field => dexieReplaceIfStartsWithPipe(field))\n                            .join('+')\n                        + ']';\n                }\n                index = store.index(indexName);\n            }\n            const cursorReq = index.openCursor(keyRange);\n            await new Promise<void>(res => {\n                cursorReq.onsuccess = function (e: any) {\n                    const cursor = e.target.result;\n                    if (cursor) {\n                        // We have a record in cursor.value\n                        const docData = fromDexieToStorage(cursor.value);\n                        if (\n                            !docData._deleted &&\n                            (!queryMatcher || queryMatcher(docData))\n                        ) {\n                            rows.push(docData);\n                        }\n\n                        /**\n                         * If we do not have to manually sort\n                         * and have enough documents,\n                         * we can abort iterating over the cursor\n                         * because we already have every relevant document.\n                         */\n                        if (\n                            queryPlan.sortFieldsSameAsIndexFields &&\n                            rows.length === skipPlusLimit\n                        ) {\n                            res();\n                        } else {\n                            cursor.continue();\n                        }\n                    } else {\n                        // Iteration complete\n                        res();\n                    }\n                };\n            });\n\n\n        }\n    );\n\n\n    if (!queryPlan.sortFieldsSameAsIndexFields) {\n        const sortComparator = RxStorageDexieStatics.getSortComparator(instance.schema, preparedQuery);\n        rows = rows.sort(sortComparator);\n    }\n\n    // apply skip and limit boundaries.\n    rows = rows.slice(skip, skipPlusLimit);\n\n    /**\n     * Comment this in for debugging to check all fields in the database.\n     */\n    // const docsInDb = await state.dexieTable.filter(queryMatcher).toArray();\n    // let documents = docsInDb\n    //     .map(docData => stripDexieKey(docData))\n    //     .sort(sortComparator);\n    // if (preparedQuery.skip) {\n    //     documents = documents.slice(preparedQuery.skip);\n    // }\n    // if (preparedQuery.limit && documents.length > preparedQuery.limit) {\n    //     documents = documents.slice(0, preparedQuery.limit);\n    // }\n\n\n\n    return {\n        documents: rows\n    };\n}\n\n\nexport async function dexieCount<RxDocType>(\n    instance: RxStorageInstanceDexie<RxDocType>,\n    preparedQuery: DexiePreparedQuery<RxDocType>\n): Promise<number> {\n    const state = await instance.internals;\n    const queryPlan = preparedQuery.queryPlan;\n    const queryPlanFields: string[] = queryPlan.index;\n\n    const keyRange = getKeyRangeByQueryPlan(\n        queryPlan,\n        (state.dexieDb as any)._options.IDBKeyRange\n    );\n    let count: number = -1;\n    await state.dexieDb.transaction(\n        'r',\n        state.dexieTable,\n        async (dexieTx) => {\n            const tx = (dexieTx as any).idbtrans;\n            const store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\n            let index: any;\n            if (\n                queryPlanFields.length === 1 &&\n                queryPlanFields[0] === instance.primaryPath\n            ) {\n                index = store;\n            } else {\n                let indexName: string;\n                if (queryPlanFields.length === 1) {\n                    indexName = dexieReplaceIfStartsWithPipe(queryPlanFields[0]);\n                } else {\n                    indexName = '[' +\n                        queryPlanFields\n                            .map(field => dexieReplaceIfStartsWithPipe(field))\n                            .join('+')\n                        + ']';\n                }\n                index = store.index(indexName);\n            }\n\n            const request = index.count(keyRange);\n            count = await new Promise<number>((res, rej) => {\n                request.onsuccess = function () {\n                    res(request.result);\n                };\n                request.onerror = (err: any) => rej(err);\n            });\n        }\n    );\n    return count;\n}\n"],"mappings":"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"}
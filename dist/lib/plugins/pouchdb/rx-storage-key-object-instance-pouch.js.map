{"version":3,"sources":["../../../../src/plugins/pouchdb/rx-storage-key-object-instance-pouch.ts"],"names":["body","recover","result","e","then","RxStorageKeyObjectInstancePouch","databaseName","collectionName","internals","options","changes$","Subject","OPEN_POUCHDB_STORAGE_INSTANCES","add","close","PROMISE_RESOLVE_VOID","remove","pouch","destroy","bulkWrite","documentWrites","length","args","writeRowById","Map","insertDocs","map","writeRow","set","document","_id","storeDocumentData","previous","_rev","startTime","bulkDocs","pouchResult","endTime","ret","success","error","eventBulk","id","events","forEach","resultRow","err","isError","status","documentId","pushObj","rev","_attachments","event","operation","doc","_deleted","previousDoc","eventId","storageChangeEvent","change","push","next","findLocalDocumentsById","ids","withDeleted","pouchIds","POUCHDB_LOCAL_PREFIX","Promise","all","pouchId","get","docData","changeStream","asObservable"],"mappings":"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","sourcesContent":["import { ChangeEvent } from 'event-reduce-js';\nimport {\n    Subject,\n    Observable\n} from 'rxjs';\nimport { newRxError } from '../../rx-error';\nimport type {\n    RxStorageKeyObjectInstance,\n    RxStorageChangeEvent,\n    RxLocalDocumentData,\n    BulkWriteLocalRow,\n    RxLocalStorageBulkWriteResponse,\n    PouchWriteError,\n    RxStorageBulkWriteLocalError,\n    PouchBulkDocResultRow,\n    PouchSettings,\n    EventBulk\n} from '../../types';\nimport {\n    flatClone,\n    getFromMapOrThrow,\n    now,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString\n} from '../../util';\nimport {\n    getEventKey,\n    localDocumentFromPouch,\n    localDocumentToPouch,\n    OPEN_POUCHDB_STORAGE_INSTANCES,\n    POUCHDB_LOCAL_PREFIX,\n    PouchStorageInternals,\n    pouchStripLocalFlagFromPrimary\n} from './pouchdb-helper';\n\nexport class RxStorageKeyObjectInstancePouch implements RxStorageKeyObjectInstance<PouchStorageInternals, PouchSettings> {\n\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxLocalDocumentData>>> = new Subject();\n\n    constructor(\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly internals: Readonly<PouchStorageInternals>,\n        public readonly options: Readonly<PouchSettings>\n    ) {\n        OPEN_POUCHDB_STORAGE_INSTANCES.add(this);\n    }\n\n    close(): Promise<void> {\n        OPEN_POUCHDB_STORAGE_INSTANCES.delete(this);\n        // TODO this did not work because a closed pouchdb cannot be recreated in the same process run\n        // await this.internals.pouch.close();\n        return PROMISE_RESOLVE_VOID;\n    }\n\n    async remove() {\n        OPEN_POUCHDB_STORAGE_INSTANCES.delete(this);\n        await this.internals.pouch.destroy();\n    }\n\n    public async bulkWrite<D = any>(\n        documentWrites: BulkWriteLocalRow<D>[]\n    ): Promise<RxLocalStorageBulkWriteResponse<D>> {\n        if (documentWrites.length === 0) {\n            throw newRxError('P2', {\n                args: {\n                    documentWrites\n                }\n            });\n        }\n\n        const writeRowById: Map<string, BulkWriteLocalRow<D>> = new Map();\n        const insertDocs: RxLocalDocumentData<D>[] = documentWrites.map(writeRow => {\n            writeRowById.set(writeRow.document._id, writeRow);\n\n            /**\n             * add local prefix\n             * Local documents always have _id as primary\n             */\n            const storeDocumentData = localDocumentToPouch(writeRow.document);\n\n            // if previous document exists, we have to send the previous revision to pouchdb.\n            if (writeRow.previous) {\n                storeDocumentData._rev = writeRow.previous._rev;\n            }\n\n            return storeDocumentData;\n        });\n\n        const startTime = now();\n        const pouchResult = await this.internals.pouch.bulkDocs(insertDocs);\n        const endTime = now();\n        const ret: RxLocalStorageBulkWriteResponse<D> = {\n            success: {},\n            error: {}\n        };\n\n        const eventBulk: EventBulk<RxStorageChangeEvent<RxLocalDocumentData>> = {\n            id: randomCouchString(10),\n            events: []\n        };\n\n        pouchResult.forEach(resultRow => {\n            resultRow.id = pouchStripLocalFlagFromPrimary(resultRow.id);\n            const writeRow = getFromMapOrThrow(writeRowById, resultRow.id);\n            if ((resultRow as PouchWriteError).error) {\n                const err: RxStorageBulkWriteLocalError<D> = {\n                    isError: true,\n                    status: 409,\n                    documentId: resultRow.id,\n                    writeRow\n                };\n                ret.error[resultRow.id] = err;\n            } else {\n                const pushObj: RxLocalDocumentData<D> = flatClone(writeRow.document);\n                pushObj._rev = (resultRow as PouchBulkDocResultRow).rev;\n                // local document cannot have attachments\n                pushObj._attachments = {};\n                ret.success[resultRow.id] = pushObj;\n\n                /**\n                 * Emit a write event to the changestream.\n                 * We do this here and not by observing the internal pouchdb changes\n                 * because here we have the previous document data and do\n                 * not have to fill previous with 'UNKNOWN'.\n                 */\n                let event: ChangeEvent<RxLocalDocumentData<D>>;\n                if (!writeRow.previous) {\n                    // was insert\n                    event = {\n                        operation: 'INSERT',\n                        doc: pushObj,\n                        id: resultRow.id,\n                        previous: null\n                    };\n                } else if (writeRow.document._deleted) {\n                    // was delete\n\n                    // we need to add the new revision to the previous doc\n                    // so that the eventkey is calculated correctly.\n                    // Is this a hack? idk.\n                    const previousDoc = flatClone(writeRow.previous);\n                    previousDoc._rev = (resultRow as PouchBulkDocResultRow).rev;\n\n                    event = {\n                        operation: 'DELETE',\n                        doc: null,\n                        id: resultRow.id,\n                        previous: previousDoc\n                    };\n                } else {\n                    // was update\n                    event = {\n                        operation: 'UPDATE',\n                        doc: pushObj,\n                        id: resultRow.id,\n                        previous: writeRow.previous\n                    };\n                }\n\n                if (\n                    writeRow.document._deleted &&\n                    (\n                        !writeRow.previous ||\n                        writeRow.previous._deleted\n                    )\n                ) {\n                    /**\n                     * A deleted document was newly added to the storage engine,\n                     * do not emit an event.\n                     */\n                } else {\n\n                    const doc: RxLocalDocumentData<D> = event.operation === 'DELETE' ? event.previous as any : event.doc as any;\n                    const eventId = getEventKey(true, doc._id, doc._rev ? doc._rev : '');\n\n                    const storageChangeEvent: RxStorageChangeEvent<RxLocalDocumentData<D>> = {\n                        eventId,\n                        documentId: resultRow.id,\n                        change: event,\n                        startTime,\n                        endTime\n                    };\n\n\n                    eventBulk.events.push(storageChangeEvent);\n                }\n\n            }\n\n\n        });\n\n        this.changes$.next(eventBulk);\n        return ret;\n    }\n\n    async findLocalDocumentsById<D = any>(\n        ids: string[],\n        withDeleted: boolean\n    ): Promise<{ [documentId: string]: RxLocalDocumentData<D> }> {\n        const pouch = this.internals.pouch;\n        const pouchIds = ids.map(id => POUCHDB_LOCAL_PREFIX + id);\n        const ret: { [documentId: string]: RxLocalDocumentData<D> } = {};\n\n        /**\n         * Pouchdb is not able to bulk-request local documents\n         * with the pouch.allDocs() method.\n         * so we need to get each by a single call.\n         * TODO create an issue at the pouchdb repo\n         */\n        await Promise.all(\n            pouchIds.map(async (pouchId) => {\n                try {\n                    let docData = await pouch.get(pouchId);\n                    docData = localDocumentFromPouch(docData);\n                    if (\n                        withDeleted ||\n                        !docData._deleted\n                    ) {\n                        ret[docData._id] = docData;\n                    }\n                } catch (err) {\n                    // do not add to result list on error\n                }\n            })\n        );\n        return ret;\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxLocalDocumentData>>> {\n        return this.changes$.asObservable();\n    }\n}\n"],"file":"rx-storage-key-object-instance-pouch.js"}
{"version":3,"file":"custom-events-plugin.js","names":["eventEmitDataToStorageEvents","pouchDBInstance","primaryPath","emitData","ret","writeOptions","custom","hasOwnProperty","new_edits","Promise","all","writeDocs","map","writeDoc","id","_id","pouchDocumentDataToRxDocumentData","writeAttachmentsToAttachments","_attachments","previousDoc","previousDocs","get","parsedRevPrevious","parseRevision","_rev","parsedRevNew","height","hash","_deleted","event","operation","doc","previous","newRxError","args","changeEvent","changeEventToNormal","startTime","endTime","push","writeRowById","writeDocsById","Map","forEach","set","writeResult","resultRow","startsWith","POUCHDB_DESIGN_PREFIX","POUCHDB_LOCAL_PREFIX","getFromMapOrThrow","flatClone","rev","pouchChangeRowToChangeEvent","writeMap","error","writeRow","document","attachments","ensureNotFalsy","newDoc","Object","assign","addedToPouch","EVENT_EMITTER_BY_POUCH_INSTANCE","getCustomEventEmitterByPouch","pouch","key","name","adapter","join","emitter","subject","Subject","i","BULK_DOC_RUN_QUEUE","WeakMap","addCustomEventsPluginToPouch","oldBulkDocs","PouchDBCore","prototype","bulkDocs","newBulkDocs","body","options","callback","queue","PROMISE_RESOLVE_VOID","then","newBulkDocsInner","bind","usePouchResult","hasNonErrorWrite","docs","insertDocsById","Array","from","entries","previousRev","newRev","docInDb","previousDocsInDb","docInDbRev","status","useRevisions","start","ids","_revisions","slice","unshift","useNewRev","writeToPouchDocData","ok","deeperOptions","isDeeper","callReturn","callPromise","res","rej","docIds","Set","d","heighestSequence","changesSub","heighestSequencePromise","changes","since","live","include_docs","on","change","docId","has","seq","size","cancel","call","err","result","row","eventsPromise","now","emitId","runId","events","eventBulk","randomCouchString","checkpoint","sequence","context","next","hasError","find","isArray","undefined","length","bulkGet","revs","latest","viaBulkGet","mustRefetchBecauseDeleted","results","firstDoc","reason","allDocs","keys","conflicts","deletedDocsViaAllDocs","idsWithRevs","rows","value","deletedDocsViaBulkGetWithRev","plugin","primary","storageChangeEvent","eventId","getEventKey","documentId"],"sources":["../../../../src/plugins/pouchdb/custom-events-plugin.ts"],"sourcesContent":["/*\n * Instead of listening to pouch.changes,\n * we overwrite pouchdbs bulkDocs()\n * and create our own event stream, this will work more reliable\n * and has less strange behaviors.\n * Also we can better define what data we need for our events.\n * @link http://jsbin.com/pagebi/1/edit?js,output\n * @link https://github.com/pubkey/rxdb/blob/1f4115b69bdacbb853af9c637d70f5f184d4e474/src/rx-storage-pouchdb.ts#L273\n * @link https://hasura.io/blog/couchdb-style-conflict-resolution-rxdb-hasura/\n */\n\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    PouchBulkDocOptions,\n    PouchBulkDocResultRow,\n    PouchChangesOnChangeEvent,\n    PouchCheckpoint,\n    PouchDBInstance,\n    PouchWriteError,\n    RxDocumentData,\n    RxStorageChangeEvent\n} from '../../types';\nimport PouchDBCore from 'pouchdb-core';\nimport { Subject } from 'rxjs';\nimport {\n    ensureNotFalsy,\n    flatClone,\n    getFromMapOrThrow,\n    now,\n    parseRevision,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString\n} from '../../util';\nimport { newRxError } from '../../rx-error';\nimport {\n    getEventKey,\n    pouchChangeRowToChangeEvent,\n    POUCHDB_DESIGN_PREFIX,\n    POUCHDB_LOCAL_PREFIX,\n    pouchDocumentDataToRxDocumentData,\n    writeAttachmentsToAttachments\n} from './pouchdb-helper';\nimport type { ChangeEvent } from 'event-reduce-js';\n\n// ensure only added once\nlet addedToPouch = false;\n\ndeclare type EmitData = {\n    emitId: number;\n    writeOptions: PouchBulkDocOptions;\n    writeDocs: any[];\n    writeResult: (PouchBulkDocResultRow | PouchWriteError)[];\n    // used on new_edits=false to check if the last revision has changed\n    previousDocs: Map<string, any>;\n    startTime: number;\n    endTime: number;\n};\n\n\ndeclare type Emitter<RxDocType> = {\n    subject: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, PouchCheckpoint>>;\n};\nexport const EVENT_EMITTER_BY_POUCH_INSTANCE: Map<string, Emitter<any>> = new Map();\n\nexport function getCustomEventEmitterByPouch<RxDocType>(\n    pouch: PouchDBInstance\n): Emitter<RxDocType> {\n    const key = [\n        pouch.name,\n        pouch.adapter\n    ].join('|');\n    let emitter = EVENT_EMITTER_BY_POUCH_INSTANCE.get(key);\n    if (!emitter) {\n        emitter = {\n            subject: new Subject()\n        };\n        EVENT_EMITTER_BY_POUCH_INSTANCE.set(key, emitter);\n    }\n    return emitter;\n}\n\n\n/**\n * Counter, used to debug stuff.\n */\nlet i = 0;\n\n\n/**\n * Because we cannot force pouchdb to await bulkDocs runs\n * inside of a transaction, like done with the other RxStorage implementations,\n * we have to ensure the calls to bulkDocs() do not run in parallel. \n * \n * TODO this is somehow a hack. Instead of doing that, inspect how\n * PouchDB runs bulkDocs internally and adapt that transaction handling.\n */\nconst BULK_DOC_RUN_QUEUE: WeakMap<PouchDBInstance, Promise<any>> = new WeakMap();\n\n/**\n * PouchDB is like a minefield,\n * where stuff randomly does not work dependend on some conditions.\n * So instead of doing plain writes,\n * we hack into the bulkDocs() function\n * and adjust the behavior accordingly.\n */\nexport function addCustomEventsPluginToPouch() {\n    if (addedToPouch) {\n        return;\n    }\n    addedToPouch = true;\n\n    const oldBulkDocs: any = PouchDBCore.prototype.bulkDocs;\n\n    /**\n     * Ensure we do not run bulkDocs() in parallel on the same PouchDB instance.\n     */\n    const newBulkDocs = async function (\n        this: PouchDBInstance,\n        body: any[] | { docs: any[], new_edits?: boolean },\n        options: PouchBulkDocOptions,\n        callback: Function\n    ) {\n        let queue = BULK_DOC_RUN_QUEUE.get(this);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue.then(async () => {\n            const ret = await newBulkDocsInner.bind(this)(\n                body,\n                options,\n                callback\n            );\n            return ret;\n        });\n        BULK_DOC_RUN_QUEUE.set(this, queue);\n        return queue;\n    };\n\n\n    const newBulkDocsInner = async function (\n        this: PouchDBInstance,\n        body: any[] | { docs: any[], new_edits?: boolean },\n        options: PouchBulkDocOptions,\n        callback: Function\n    ) {\n\n        const startTime = now();\n        const runId = i++;\n\n        /**\n         * Normalize inputs\n         * because there are many ways to call pouchdb.bulkDocs()\n         */\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        if (!options) {\n            options = {};\n        }\n\n        let docs: any[];\n        if (Array.isArray(body)) {\n            docs = body;\n        } else if (body === undefined) {\n            docs = [];\n        } else {\n            docs = body.docs;\n            if (body.hasOwnProperty('new_edits')) {\n                options.new_edits = body.new_edits;\n            }\n        }\n\n        // throw if no docs given, because RxDB should never make such a call.\n        if (docs.length === 0) {\n            throw newRxError('SNH', {\n                args: {\n                    body,\n                    options\n                }\n            });\n        }\n\n\n        /**\n         * If new_edits=false we have to first find the current state\n         * of the document and can later check if the state was changed\n         * because a new revision was written and we have to emit an event.\n         */\n        const previousDocsInDb: Map<string, RxDocumentData<any>> = options.custom ? options.custom.previousDocsInDb : new Map();\n        if (\n            options.hasOwnProperty('new_edits') &&\n            options.new_edits === false\n        ) {\n            const viaBulkGet = await this.bulkGet({\n                docs: docs.map(doc => ({ id: doc._id })),\n                revs: true,\n                latest: true\n            });\n\n            /**\n             * bulkGet() does not return deleted documents,\n             * so we must refetch them via allDocs() afterwards.\n             */\n            const mustRefetchBecauseDeleted: string[] = [];\n\n            viaBulkGet.results.forEach(resultRow => {\n                const firstDoc = resultRow.docs[0];\n                if (firstDoc.ok) {\n                    previousDocsInDb.set(firstDoc.ok._id, firstDoc.ok);\n                } else {\n                    if (firstDoc.error && firstDoc.error.reason === 'deleted') {\n                        mustRefetchBecauseDeleted.push(resultRow.id);\n                    }\n                }\n            });\n\n            if (mustRefetchBecauseDeleted.length > 0) {\n                const deletedDocsViaAllDocs = await this.allDocs({\n                    keys: mustRefetchBecauseDeleted,\n                    include_docs: true,\n                    conflicts: true,\n                });\n\n                const idsWithRevs: { id: string; rev: string; }[] = [];\n                deletedDocsViaAllDocs.rows.forEach(row => {\n                    idsWithRevs.push({\n                        id: row.id,\n                        rev: row.value.rev\n                    });\n                });\n\n                const deletedDocsViaBulkGetWithRev = await this.bulkGet({\n                    docs: idsWithRevs,\n                    revs: true,\n                    latest: true\n                });\n\n                deletedDocsViaBulkGetWithRev.results.forEach(resultRow => {\n                    const firstDoc = resultRow.docs[0];\n                    if (firstDoc.ok) {\n                        previousDocsInDb.set(firstDoc.ok._id, firstDoc.ok);\n                    } else {\n                        throw newRxError('SNH', {\n                            args: {\n                                deletedDocsViaBulkGetWithRev,\n                                resultRow\n                            }\n                        });\n                    }\n                });\n\n            }\n        }\n\n        /**\n         * Custom handling if the call came from RxDB (options.custom is set).\n         */\n        const usePouchResult: (PouchBulkDocResultRow | PouchWriteError)[] = [];\n        let hasNonErrorWrite = false;\n        if (\n            options.custom &&\n            options.hasOwnProperty('new_edits') &&\n            options.new_edits === false\n        ) {\n            /**\n             * Reset the write docs array,\n             * because we only write non-conflicting documents.\n             */\n            docs = [];\n            const writeRowById: Map<string, BulkWriteRow<any>> = options.custom.writeRowById;\n            const insertDocsById: Map<string, any> = options.custom.insertDocsById;\n\n            Array.from(writeRowById.entries()).forEach(([id, writeRow]) => {\n                const previousRev = writeRow.previous ? writeRow.previous._rev : null;\n                const newRev = parseRevision(writeRow.document._rev);\n                const docInDb = previousDocsInDb.get(id);\n                const docInDbRev: string | null = docInDb ? docInDb._rev : null;\n\n                if (\n                    docInDbRev !== previousRev\n                ) {\n                    // we have a conflict\n                    usePouchResult.push({\n                        error: true,\n                        id,\n                        status: 409\n                    });\n                } else {\n                    const useRevisions = {\n                        start: newRev.height,\n                        ids: docInDb ? docInDb._revisions.ids.slice(0) : []\n                    };\n                    useRevisions.ids.unshift(newRev.hash);\n                    const useNewRev = useRevisions.start + '-' + newRev.hash;\n\n                    hasNonErrorWrite = true;\n                    const writeToPouchDocData = Object.assign(\n                        {},\n                        insertDocsById.get(id),\n                        {\n                            _revisions: useRevisions,\n                            _rev: useNewRev\n                        }\n                    );\n                    docs.push(writeToPouchDocData);\n                    usePouchResult.push({\n                        ok: true,\n                        id,\n                        rev: writeRow.document._rev\n                    });\n                }\n            });\n\n            /**\n             * Optimization shortcut,\n             * if all document writes were conflict errors,\n             * we can skip directly.\n             */\n            if (!hasNonErrorWrite) {\n                return usePouchResult;\n            }\n        }\n\n        /**\n         * pouchdb calls this function again with transformed input.\n         * This would lead to duplicate events. So we marks the deeper calls via the options\n         * parameter and do not emit events if it is set.\n         */\n        const deeperOptions = flatClone(options);\n        deeperOptions.isDeeper = true;\n        let callReturn: any;\n        const callPromise = new Promise((res, rej) => {\n\n            /**\n             * The emitted EventBulk from the write to the pouchdb, needs to contain a checkpoint field.\n             * Because PouchDB works on sequence number to sort changes,\n             * we have to fetch the latest sequence number out of the events because it\n             * is not possible to that that from pouch.bulkDocs().\n             */\n            const docIds: Set<string> = new Set(docs.map(d => d._id));\n            let heighestSequence = 0;\n            let changesSub: PouchChangesOnChangeEvent;\n            const heighestSequencePromise = new Promise<number>(res => {\n                changesSub = this.changes({\n                    since: 'now',\n                    live: true,\n                    include_docs: true\n                }).on('change', (change: any) => {\n                    const docId: string = change.id;\n                    if (docIds.has(docId)) {\n                        docIds.delete(docId);\n                        if (heighestSequence < change.seq) {\n                            heighestSequence = change.seq;\n                        }\n\n                        if (docIds.size === 0) {\n                            (changesSub as any).cancel();\n                            res(heighestSequence);\n                        }\n                    }\n                }) as any;\n            });\n\n            callReturn = oldBulkDocs.call(\n                this,\n                docs,\n                deeperOptions,\n                (err: any, result: (PouchBulkDocResultRow | PouchWriteError)[]) => {\n                    if (err) {\n                        callback ? callback(err) : rej(err);\n                    } else {\n                        return (async () => {\n                            const hasError = result.find(row => (row as PouchWriteError).error);\n                            let heighestSequence = -1;\n                            if (!hasError) {\n                                heighestSequence = await heighestSequencePromise;\n                            } else {\n                                changesSub.cancel();\n                            }\n\n                            result.forEach(row => {\n                                usePouchResult.push(row);\n                            });\n\n                            /**\n                             * For calls that came from RxDB,\n                             * we have to ensure that the events are emitted\n                             * before the actual call resolves.\n                             */\n                            let eventsPromise = PROMISE_RESOLVE_VOID;\n                            if (!options.isDeeper) {\n                                const endTime = now();\n                                const emitData = {\n                                    emitId: runId,\n                                    writeDocs: docs,\n                                    writeOptions: options,\n                                    writeResult: usePouchResult,\n                                    previousDocs: previousDocsInDb,\n                                    startTime,\n                                    endTime\n                                };\n                                eventsPromise = eventEmitDataToStorageEvents(\n                                    this,\n                                    '_id',\n                                    emitData\n                                ).then(events => {\n                                    const eventBulk: EventBulk<any, PouchCheckpoint> = {\n                                        id: randomCouchString(10),\n                                        events,\n                                        checkpoint: {\n                                            sequence: heighestSequence\n                                        },\n                                        context: options.custom ? options.custom.context : 'pouchdb-internal'\n                                    };\n\n                                    const emitter = getCustomEventEmitterByPouch(this);\n                                    emitter.subject.next(eventBulk);\n                                });\n                            }\n\n                            if (callback) {\n                                callback(null, usePouchResult);\n                            } else {\n                                return eventsPromise.then(() => {\n                                    res(usePouchResult);\n                                    return usePouchResult;\n                                });\n                            }\n                        })();\n                    }\n                });\n        });\n\n        if (options.custom) {\n            return callPromise;\n        }\n\n\n\n        return callReturn;\n    };\n\n    PouchDBCore.plugin({\n        bulkDocs: newBulkDocs\n    } as any);\n\n}\n\nexport async function eventEmitDataToStorageEvents<RxDocType>(\n    pouchDBInstance: PouchDBInstance,\n    primaryPath: string,\n    emitData: EmitData\n): Promise<RxStorageChangeEvent<RxDocumentData<RxDocType>>[]> {\n    const ret: RxStorageChangeEvent<RxDocumentData<RxDocType>>[] = [];\n    if (\n        !emitData.writeOptions.custom &&\n        emitData.writeOptions.hasOwnProperty('new_edits') &&\n        emitData.writeOptions.new_edits === false\n    ) {\n        await Promise.all(\n            emitData.writeDocs.map(async (writeDoc) => {\n                const id = writeDoc._id;\n                writeDoc = pouchDocumentDataToRxDocumentData(\n                    primaryPath,\n                    writeDoc\n                );\n                writeDoc._attachments = await writeAttachmentsToAttachments(writeDoc._attachments);\n                let previousDoc = emitData.previousDocs.get(id);\n                if (previousDoc) {\n                    previousDoc = pouchDocumentDataToRxDocumentData(\n                        primaryPath,\n                        previousDoc\n                    );\n                }\n                if (previousDoc) {\n                    const parsedRevPrevious = parseRevision(previousDoc._rev);\n                    const parsedRevNew = parseRevision(writeDoc._rev);\n                    if (\n                        (\n                            parsedRevPrevious.height > parsedRevNew.height ||\n                            /**\n                             * If the revision height is equal,\n                             * we determine the higher hash as winner.\n                             */\n                            (\n                                parsedRevPrevious.height === parsedRevNew.height &&\n                                parsedRevPrevious.hash > parsedRevNew.hash\n                            )\n                        )\n                    ) {\n                        /**\n                         * The newly added document was not the latest revision\n                         * so we drop the write.\n                         * With plain PouchDB it makes sense to store conflicting branches of the document\n                         * but RxDB assumes that the conflict is resolved directly.\n                         */\n                        return;\n                    }\n                }\n\n                if (!previousDoc && writeDoc._deleted) {\n                    // deleted document was added as revision\n                    return;\n                }\n\n                if (previousDoc && previousDoc._deleted && writeDoc._deleted) {\n                    // delete document was deleted again\n                    return;\n                }\n\n                let event: ChangeEvent<RxDocumentData<RxDocType>>;\n                if ((!previousDoc || previousDoc._deleted) && !writeDoc._deleted) {\n                    // was insert\n                    event = {\n                        operation: 'INSERT',\n                        doc: writeDoc,\n                        id: id,\n                        previous: null\n                    };\n                } else if (writeDoc._deleted && previousDoc && !previousDoc._deleted) {\n                    // was delete\n                    previousDoc._rev = writeDoc._rev;\n                    event = {\n                        operation: 'DELETE',\n                        doc: null,\n                        id: id,\n                        previous: previousDoc\n                    };\n                } else if (\n                    previousDoc\n                ) {\n                    // was update\n                    event = {\n                        operation: 'UPDATE',\n                        doc: writeDoc,\n                        id: id,\n                        previous: previousDoc\n                    };\n                } else {\n                    throw newRxError('SNH', { args: { writeDoc } });\n                }\n\n                const changeEvent = changeEventToNormal(\n                    pouchDBInstance,\n                    primaryPath,\n                    event,\n                    emitData.startTime,\n                    emitData.endTime\n                );\n\n                ret.push(changeEvent);\n            })\n        );\n    }\n    /**\n     * There is no write map given for internal pouchdb document writes\n     * like it is done with replication.\n     */\n    else if (\n        !emitData.writeOptions.custom ||\n        (emitData.writeOptions.custom && !emitData.writeOptions.custom.writeRowById)\n    ) {\n        const writeDocsById: Map<string, any> = new Map();\n        emitData.writeDocs.forEach(writeDoc => writeDocsById.set(writeDoc._id, writeDoc));\n        await Promise.all(\n            emitData.writeResult.map(async (resultRow) => {\n                const id = resultRow.id;\n                if (\n                    id.startsWith(POUCHDB_DESIGN_PREFIX) ||\n                    id.startsWith(POUCHDB_LOCAL_PREFIX)\n                ) {\n                    return;\n                }\n                let writeDoc = getFromMapOrThrow(writeDocsById, resultRow.id);\n                writeDoc = pouchDocumentDataToRxDocumentData(\n                    primaryPath,\n                    writeDoc\n                );\n\n                writeDoc._attachments = await writeAttachmentsToAttachments(writeDoc._attachments);\n                writeDoc = flatClone(writeDoc);\n                writeDoc._rev = (resultRow as any).rev;\n                const event = pouchChangeRowToChangeEvent<RxDocType>(\n                    primaryPath as any,\n                    writeDoc\n                );\n                const changeEvent = changeEventToNormal(pouchDBInstance, primaryPath, event);\n                ret.push(changeEvent);\n            })\n        );\n    } else {\n        const writeMap: Map<string, BulkWriteRow<RxDocType>> = emitData.writeOptions.custom.writeRowById;\n        await Promise.all(\n            emitData.writeResult.map(async (resultRow) => {\n                if ((resultRow as PouchWriteError).error) {\n                    return;\n                }\n                const id = resultRow.id;\n                const writeRow = getFromMapOrThrow(writeMap, id);\n                const attachments = await writeAttachmentsToAttachments(writeRow.document._attachments);\n                const newDoc: RxDocumentData<RxDocType> = Object.assign(\n                    {},\n                    writeRow.document,\n                    {\n                        _attachments: attachments,\n                        _rev: (resultRow as PouchBulkDocResultRow).rev\n                    }\n                );\n\n                let event: ChangeEvent<RxDocumentData<RxDocType>>;\n                if (!writeRow.previous || writeRow.previous._deleted) {\n                    // was insert\n                    event = {\n                        operation: 'INSERT',\n                        doc: newDoc,\n                        id: id,\n                        previous: null\n                    };\n                } else if (writeRow.document._deleted) {\n                    // was delete\n\n                    // we need to add the new revision to the previous doc\n                    // so that the eventkey is calculated correctly.\n                    // Is this a hack? idk.\n                    const attachments = await writeAttachmentsToAttachments(writeRow.previous._attachments);\n                    const previousDoc = Object.assign(\n                        {},\n                        writeRow.previous,\n                        {\n                            _attachments: attachments\n                        }\n                    );\n\n                    event = {\n                        operation: 'DELETE',\n                        doc: null,\n                        id: resultRow.id,\n                        previous: previousDoc\n                    };\n                } else {\n                    // was update\n                    event = {\n                        operation: 'UPDATE',\n                        doc: newDoc,\n                        id: resultRow.id,\n                        previous: writeRow.previous\n                    };\n                }\n\n                if (\n                    writeRow.document._deleted &&\n                    (\n                        !writeRow.previous ||\n                        writeRow.previous._deleted\n                    )\n                ) {\n                    /**\n                     * A deleted document was newly added to the storage engine,\n                     * do not emit an event.\n                     */\n                } else {\n                    const changeEvent = changeEventToNormal(\n                        pouchDBInstance,\n                        ensureNotFalsy(emitData.writeOptions.custom).primaryPath,\n                        event,\n                        emitData.startTime,\n                        emitData.endTime\n                    );\n                    ret.push(changeEvent);\n                }\n            })\n        );\n    }\n\n    return ret;\n}\n\nexport function changeEventToNormal<RxDocType>(\n    pouchDBInstance: PouchDBInstance,\n    primaryPath: string,\n    change: ChangeEvent<RxDocumentData<RxDocType>>,\n    startTime?: number,\n    endTime?: number\n): RxStorageChangeEvent<RxDocumentData<RxDocType>> {\n    const doc: RxDocumentData<RxDocType> = change.operation === 'DELETE' ? change.previous as any : change.doc as any;\n    const primary: string = (doc as any)[primaryPath];\n    const storageChangeEvent: RxStorageChangeEvent<RxDocumentData<RxDocType>> = {\n        eventId: getEventKey(pouchDBInstance, primary, change),\n        documentId: primary,\n        change,\n        startTime,\n        endTime\n    };\n    return storageChangeEvent;\n}\n"],"mappings":"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"}
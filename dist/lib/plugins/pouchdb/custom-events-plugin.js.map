{"version":3,"sources":["../../../../src/plugins/pouchdb/custom-events-plugin.ts"],"names":["eventEmitDataToStorageEvents","primaryPath","emitData","ret","writeOptions","hasOwnProperty","new_edits","Promise","all","writeDocs","map","writeDoc","id","_id","_attachments","previousDoc","previousDocs","get","parsedRevPrevious","_rev","parsedRevNew","height","hash","_deleted","event","operation","doc","previous","args","changeEvent","changeEventToNormal","startTime","endTime","push","custom","writeRowById","writeDocsById","Map","forEach","set","writeResult","resultRow","startsWith","POUCHDB_DESIGN_PREFIX","POUCHDB_LOCAL_PREFIX","rev","writeMap","error","writeRow","document","attachments","newDoc","Object","assign","addedToPouch","EVENT_EMITTER_BY_POUCH_INSTANCE","getCustomEventEmitterByPouch","pouch","key","name","adapter","join","emitter","subject","Subject","i","addCustomEventsPluginToPouch","oldBulkDocs","PouchDBCore","prototype","bulkDocs","newBulkDocs","body","options","callback","deeperOptions","isDeeper","call","docs","err","result","emitId","t","events","eventBulk","next","Array","isArray","undefined","length","ids","changes","live","since","doc_ids","style","viaChanges","results","deleted","revs","set_new_edit_as_latest_revision","previousDocsResult","splittedRev","split","revHeight","parseInt","revLabel","_revisions","start","unshift","plugin","change","primary","storageChangeEvent","eventId","documentId"],"mappings":"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","sourcesContent":["/*\n * Instead of listening to pouch.changes,\n * we overwrite pouchdbs bulkDocs()\n * and create our own event stream, this will work more reliable\n * and has less strange behaviors.\n * Also we can better define what data we need for our events.\n * @link http://jsbin.com/pagebi/1/edit?js,output\n * @link https://github.com/pubkey/rxdb/blob/1f4115b69bdacbb853af9c637d70f5f184d4e474/src/rx-storage-pouchdb.ts#L273\n */\n\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    PouchBulkDocOptions,\n    PouchBulkDocResultRow,\n    PouchDBInstance,\n    PouchWriteError,\n    RxDocumentData,\n    RxStorageChangeEvent\n} from '../../types';\nimport PouchDBCore from 'pouchdb-core';\nimport { Subject } from 'rxjs';\nimport {\n    flatClone,\n    getFromMapOrThrow,\n    now,\n    parseRevision,\n    randomCouchString\n} from '../../util';\nimport { newRxError } from '../../rx-error';\nimport {\n    getEventKey,\n    pouchChangeRowToChangeEvent,\n    POUCHDB_DESIGN_PREFIX,\n    POUCHDB_LOCAL_PREFIX,\n    pouchDocumentDataToRxDocumentData,\n    writeAttachmentsToAttachments\n} from './pouchdb-helper';\nimport type { ChangeEvent } from 'event-reduce-js';\n\n// ensure only added once\nlet addedToPouch = false;\n\ndeclare type EmitData = {\n    emitId: number;\n    writeOptions: PouchBulkDocOptions;\n    writeDocs: any[];\n    writeResult: (PouchBulkDocResultRow | PouchWriteError)[];\n    // used on new_edits=false to check if the last revision has changed\n    previousDocs: Map<string, any>;\n    startTime: number;\n    endTime: number;\n};\n\n\ndeclare type Emitter<RxDocType> = {\n    subject: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>>>;\n};\nexport const EVENT_EMITTER_BY_POUCH_INSTANCE: Map<string, Emitter<any>> = new Map();\n\nexport function getCustomEventEmitterByPouch<RxDocType>(\n    pouch: PouchDBInstance\n): Emitter<RxDocType> {\n    const key = [\n        pouch.name,\n        pouch.adapter\n    ].join('|');\n    let emitter = EVENT_EMITTER_BY_POUCH_INSTANCE.get(key);\n    if (!emitter) {\n        emitter = {\n            subject: new Subject()\n        };\n        EVENT_EMITTER_BY_POUCH_INSTANCE.set(key, emitter);\n    }\n    return emitter;\n}\n\n\nlet i = 0;\n\nexport function addCustomEventsPluginToPouch() {\n    if (addedToPouch) {\n        return;\n    }\n    addedToPouch = true;\n\n    const oldBulkDocs: any = PouchDBCore.prototype.bulkDocs;\n    const newBulkDocs = async function (\n        this: PouchDBInstance,\n        body: any[] | { docs: any[], new_edits?: boolean },\n        options: PouchBulkDocOptions,\n        callback: Function\n    ) {\n        const startTime = now();\n        const t = i++;\n\n        // normalize input\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        if (!options) {\n            options = {};\n        }\n\n        let docs: any[];\n        if (Array.isArray(body)) {\n            docs = body;\n        } else if (body === undefined) {\n            docs = [];\n        } else {\n            docs = body.docs;\n            if (body.hasOwnProperty('new_edits')) {\n                options.new_edits = body.new_edits;\n            }\n        }\n\n        if (docs.length === 0) {\n            throw newRxError('SNH', {\n                args: {\n                    body,\n                    options\n                }\n            });\n        }\n\n\n        /**\n         * If new_edits=false we have to first find the current state\n         * of the document and can later check if the state was changed\n         * because a new revision was written and we have to emit an event.\n         */\n        const previousDocs: Map<string, any> = new Map();\n        if (\n            options.hasOwnProperty('new_edits') &&\n            options.new_edits === false\n        ) {\n            const ids = docs.map(doc => doc._id);\n\n            /**\n             * Pouchdb does not return deleted documents via allDocs()\n             * So have to do use our hack with getting the newest revisions from the\n             * changes.\n             * @link https://github.com/pouchdb/pouchdb/issues/7877#issuecomment-522775955\n             */\n            const viaChanges = await this.changes({\n                live: false,\n                since: 0,\n                doc_ids: ids,\n                style: 'all_docs'\n            });\n\n            const previousDocsResult = await Promise.all(\n                viaChanges.results.map(async (result) => {\n                    const firstDoc = await this.get(\n                        result.id,\n                        {\n                            rev: result.changes[0].rev,\n                            deleted: 'ok',\n                            revs: options.set_new_edit_as_latest_revision ? true : false,\n                            style: 'all_docs'\n                        }\n                    );\n                    return firstDoc;\n                })\n            );\n            previousDocsResult.forEach(doc => previousDocs.set(doc._id, doc));\n\n            if (options.set_new_edit_as_latest_revision) {\n                docs.forEach(doc => {\n                    const id = doc._id;\n                    const previous = previousDocs.get(id);\n                    if (previous) {\n                        const splittedRev = doc._rev.split('-');\n                        const revHeight = parseInt(splittedRev[0], 10);\n                        const revLabel = splittedRev[1];\n\n                        if (!previous._revisions) { previous._revisions = { ids: [] } }\n\n                        doc._revisions = {\n                            start: revHeight,\n                            ids: previous._revisions.ids\n                        };\n                        doc._revisions.ids.unshift(revLabel);\n\n                        delete previous._revisions;\n                    }\n                });\n            }\n        }\n\n\n        /**\n         * pouchdb calls this function again with transformed input.\n         * This would lead to duplicate events. So we marks the deeper calls via the options\n         * parameter and do not emit events if it is set.\n         */\n        const deeperOptions = flatClone(options);\n        deeperOptions.isDeeper = true;\n\n        return oldBulkDocs.call(this, docs, deeperOptions, (err: any, result: any) => {\n            if (err) {\n                if (callback) {\n                    callback(err);\n                } else {\n                    throw err;\n                }\n            } else {\n                return (async () => {\n\n                    /**\n                     * For calls that came from RxDB,\n                     * we have to ensure that the events are emitted\n                     * before the actual call resolves.\n                     */\n                    if (!options.isDeeper) {\n                        const endTime = now();\n                        const emitData = {\n                            emitId: t,\n                            writeDocs: docs,\n                            writeOptions: options,\n                            writeResult: result,\n                            previousDocs,\n                            startTime,\n                            endTime\n                        };\n\n                        const events = await eventEmitDataToStorageEvents(\n                            '_id',\n                            emitData\n                        );\n                        const eventBulk: EventBulk<any> = {\n                            id: randomCouchString(10),\n                            events\n                        }\n                        const emitter = getCustomEventEmitterByPouch(this);\n                        emitter.subject.next(eventBulk);\n                    }\n\n                    if (callback) {\n                        callback(null, result);\n                    } else {\n                        return result;\n                    }\n                })();\n            }\n        });\n    };\n\n    PouchDBCore.plugin({\n        bulkDocs: newBulkDocs\n    } as any);\n\n}\n\nexport async function eventEmitDataToStorageEvents<RxDocType>(\n    primaryPath: string,\n    emitData: EmitData\n): Promise<RxStorageChangeEvent<RxDocumentData<RxDocType>>[]> {\n    const ret: RxStorageChangeEvent<RxDocumentData<RxDocType>>[] = [];\n\n    if (emitData.writeOptions.hasOwnProperty('new_edits') && !emitData.writeOptions.new_edits) {\n        await Promise.all(\n            emitData.writeDocs.map(async (writeDoc) => {\n                const id = writeDoc._id;\n\n                writeDoc = pouchDocumentDataToRxDocumentData(\n                    primaryPath,\n                    writeDoc\n                );\n\n                writeDoc._attachments = await writeAttachmentsToAttachments(writeDoc._attachments);\n\n                let previousDoc = emitData.previousDocs.get(id);\n                if (previousDoc) {\n                    previousDoc = pouchDocumentDataToRxDocumentData(\n                        primaryPath,\n                        previousDoc\n                    );\n                }\n\n\n                if (previousDoc) {\n                    const parsedRevPrevious = parseRevision(previousDoc._rev);\n                    const parsedRevNew = parseRevision(writeDoc._rev);\n                    if (\n                        (\n                            parsedRevPrevious.height > parsedRevNew.height ||\n                            /**\n                             * If the revision height is equal,\n                             * we determine the higher hash as winner.\n                             */\n                            (\n                                parsedRevPrevious.height === parsedRevNew.height &&\n                                parsedRevPrevious.hash > parsedRevNew.hash\n                            )\n                        )\n                    ) {\n                        /**\n                         * The newly added document was not the latest revision\n                         * so we drop the write.\n                         * With plain PouchDB it makes sense to store conflicting branches of the document\n                         * but RxDB assumes that the conflict is resolved directly.\n                         */\n                        return;\n                    }\n                }\n\n                if (!previousDoc && writeDoc._deleted) {\n                    // deleted document was added as revision\n                    return;\n                }\n\n                if (previousDoc && previousDoc._deleted && writeDoc._deleted) {\n                    // delete document was deleted again\n                    return;\n                }\n\n                let event: ChangeEvent<RxDocumentData<RxDocType>>;\n                if ((!previousDoc || previousDoc._deleted) && !writeDoc._deleted) {\n                    // was insert\n                    event = {\n                        operation: 'INSERT',\n                        doc: writeDoc,\n                        id: id,\n                        previous: null\n                    };\n                } else if (writeDoc._deleted && previousDoc && !previousDoc._deleted) {\n                    // was delete\n                    previousDoc._rev = writeDoc._rev;\n                    event = {\n                        operation: 'DELETE',\n                        doc: null,\n                        id: id,\n                        previous: previousDoc\n                    };\n                } else if (\n                    previousDoc\n                ) {\n                    // was update\n                    event = {\n                        operation: 'UPDATE',\n                        doc: writeDoc,\n                        id: id,\n                        previous: previousDoc\n                    };\n                } else {\n                    throw newRxError('SNH', { args: { writeDoc } });\n                }\n\n                const changeEvent = changeEventToNormal(\n                    primaryPath,\n                    event,\n                    emitData.startTime,\n                    emitData.endTime\n                );\n                ret.push(changeEvent);\n            })\n        );\n    }\n    /**\n     * There is no write map given for internal pouchdb document writes\n     * like it is done with replication.\n     */\n    else if (\n        !emitData.writeOptions.custom ||\n        (emitData.writeOptions.custom && !emitData.writeOptions.custom.writeRowById)\n    ) {\n        const writeDocsById: Map<string, any> = new Map();\n        emitData.writeDocs.forEach(writeDoc => writeDocsById.set(writeDoc._id, writeDoc));\n        await Promise.all(\n            emitData.writeResult.map(async (resultRow) => {\n                const id = resultRow.id;\n                if (\n                    id.startsWith(POUCHDB_DESIGN_PREFIX) ||\n                    id.startsWith(POUCHDB_LOCAL_PREFIX)\n                ) {\n                    return;\n                }\n                let writeDoc = getFromMapOrThrow(writeDocsById, resultRow.id);\n                writeDoc = pouchDocumentDataToRxDocumentData(\n                    primaryPath,\n                    writeDoc\n                );\n\n                writeDoc._attachments = await writeAttachmentsToAttachments(writeDoc._attachments);\n\n                writeDoc = flatClone(writeDoc);\n                writeDoc._rev = (resultRow as any).rev;\n                const event = pouchChangeRowToChangeEvent<RxDocType>(\n                    primaryPath as any,\n                    writeDoc\n                );\n                const changeEvent = changeEventToNormal(primaryPath, event);\n                ret.push(changeEvent);\n            })\n        );\n    } else {\n        const writeMap: Map<string, BulkWriteRow<RxDocType>> = emitData.writeOptions.custom.writeRowById;\n        await Promise.all(\n            emitData.writeResult.map(async (resultRow) => {\n                if ((resultRow as PouchWriteError).error) {\n                    return;\n                }\n\n                const id = resultRow.id;\n                const writeRow = getFromMapOrThrow(writeMap, id);\n                const attachments = await writeAttachmentsToAttachments(writeRow.document._attachments);\n                const newDoc: RxDocumentData<RxDocType> = Object.assign(\n                    {},\n                    writeRow.document,\n                    {\n                        _attachments: attachments,\n                        _rev: (resultRow as PouchBulkDocResultRow).rev\n                    }\n                );\n\n                let event: ChangeEvent<RxDocumentData<RxDocType>>;\n                if (!writeRow.previous || writeRow.previous._deleted) {\n                    // was insert\n                    event = {\n                        operation: 'INSERT',\n                        doc: newDoc,\n                        id: id,\n                        previous: null\n                    };\n                } else if (writeRow.document._deleted) {\n                    // was delete\n\n                    // we need to add the new revision to the previous doc\n                    // so that the eventkey is calculated correctly.\n                    // Is this a hack? idk.\n                    const attachments = await writeAttachmentsToAttachments(writeRow.previous._attachments);\n                    const previousDoc = Object.assign(\n                        {},\n                        writeRow.previous,\n                        {\n                            _attachments: attachments,\n                            _rev: (resultRow as PouchBulkDocResultRow).rev\n                        }\n                    );\n\n                    event = {\n                        operation: 'DELETE',\n                        doc: null,\n                        id: resultRow.id,\n                        previous: previousDoc\n                    };\n                } else {\n                    // was update\n                    event = {\n                        operation: 'UPDATE',\n                        doc: newDoc,\n                        id: resultRow.id,\n                        previous: writeRow.previous\n                    };\n                }\n\n                if (\n                    writeRow.document._deleted &&\n                    (\n                        !writeRow.previous ||\n                        writeRow.previous._deleted\n                    )\n                ) {\n                    /**\n                     * A deleted document was newly added to the storage engine,\n                     * do not emit an event.\n                     */\n                } else {\n                    const changeEvent = changeEventToNormal(\n                        emitData.writeOptions.custom.primaryPath,\n                        event,\n                        emitData.startTime,\n                        emitData.endTime\n                    );\n                    ret.push(changeEvent);\n                }\n            })\n        );\n    }\n\n\n    return ret;\n}\n\nexport function changeEventToNormal<RxDocType>(\n    primaryPath: string,\n    change: ChangeEvent<RxDocumentData<RxDocType>>,\n    startTime?: number,\n    endTime?: number\n): RxStorageChangeEvent<RxDocumentData<RxDocType>> {\n    const doc: RxDocumentData<RxDocType> = change.operation === 'DELETE' ? change.previous as any : change.doc as any;\n    const primary: string = (doc as any)[primaryPath];\n    const storageChangeEvent: RxStorageChangeEvent<RxDocumentData<RxDocType>> = {\n        eventId: getEventKey(false, primary, doc._rev),\n        documentId: primary,\n        change,\n        startTime,\n        endTime\n    };\n    return storageChangeEvent;\n}\n"],"file":"custom-events-plugin.js"}
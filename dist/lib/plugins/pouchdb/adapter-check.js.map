{"version":3,"sources":["../../../../src/plugins/pouchdb/adapter-check.ts"],"names":[],"mappings":";;;;;;;;AAIA;;AAGA;;AAPA;AACA;AACA;AACA;;AAcA;AACA;AACA;AACA;AACA;AACO,IAAM,gBAAgB,GAAG,oBAAzB;;;AAEA,SAAS,YAAT,CAAsB,OAAtB,EAAkD;AACrD;AACA,MAAM,GAAG,GAAG,gBAAgB,GAAG,GAAnB,GAAyB,6BAAkB,EAAlB,CAArC;;AAEA,MAAI,KAAJ;;AACA,MAAI;AACA,IAAA,KAAK,GAAG,IAAK,gBAAL,CACJ,gBADI,EAEJ,yBAAc,OAAd,CAFI,EAEoB;AACxB,MAAA,eAAe,EAAE,IADO;AAExB,MAAA,UAAU,EAAE;AAFY,KAFpB,CAAR;AAOH,GARD,CAQE,OAAO,GAAP,EAAY;AACV,WAAO,2BAAP;AACH;;AAED,MAAI,YAAJ;AACA,SAAO,KAAK,CAAC,IAAN,GAAa;AAChB;AADG,GAEF,IAFE,CAEG;AAAA,WAAM,KAAK,CAAC,GAAN,CAAU;AAClB,MAAA,GAAG,EAAH,GADkB;AAElB,MAAA,KAAK,EAAE;AACH,QAAA,EAAE,EAAE,IADD;AAEH,QAAA,IAAI,EAAE;AAFH;AAFW,KAAV,CAAN;AAAA,GAFH,EASH;AATG,GAUF,IAVE,CAUG;AAAA,WAAM,KAAK,CAAC,GAAN,CAAU,GAAV,CAAN;AAAA,GAVH,EAWF,IAXE,CAWG,UAAA,GAAG;AAAA,WAAI,YAAY,GAAG,GAAnB;AAAA,GAXN,EAYH;AAZG,GAaF,IAbE,CAaG;AAAA,WAAM,KAAK,CAAC,MAAN,CAAa,YAAb,CAAN;AAAA,GAbH,EAcF,IAdE,CAcG;AAAA,WAAM,IAAN;AAAA,GAdH,EAeF,IAfE,CAeG,YAAM;AACR,QAAI,YAAY,IAAI,YAAY,CAAC,KAA7B,IAAsC,YAAY,CAAC,KAAb,CAAmB,EAA7D,EACI,OAAO,IAAP,CADJ,KAGI,OAAO,KAAP;AACP,GApBE,WAqBI;AAAA,WAAM,KAAN;AAAA,GArBJ,CAAP;AAuBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACC","file":"adapter-check.js","sourcesContent":["/**\n * this plugin adds the checkAdapter-function to rxdb\n * you can use it to check if the given adapter is working in the current environmet\n */\nimport {\n    PouchDB\n} from './pouch-db';\nimport {\n    adapterObject,\n    now,\n    PROMISE_RESOLVE_FALSE,\n    randomCouchString\n} from '../../util';\nimport type {\n    PouchDBInstance\n} from '../../types';\n\n/**\n * The same pouchdb-location is used on each run\n * To ensure when this is run multiple times,\n * there will not be many created databases\n */\nexport const POUCHDB_LOCATION = 'rxdb-adapter-check';\n\nexport function checkAdapter(adapter: any): Promise<any> {\n    // id of the document which is stored and removed to ensure everything works\n    const _id = POUCHDB_LOCATION + '-' + randomCouchString(12);\n\n    let pouch: PouchDBInstance;\n    try {\n        pouch = new (PouchDB as any)(\n            POUCHDB_LOCATION,\n            adapterObject(adapter), {\n            auto_compaction: true,\n            revs_limit: 1\n        }\n        );\n    } catch (err) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    let recoveredDoc: any;\n    return pouch.info() // ensure that we wait until db is useable\n        // ensure write works\n        .then(() => pouch.put({\n            _id,\n            value: {\n                ok: true,\n                time: now()\n            }\n        }))\n        // ensure read works\n        .then(() => pouch.get(_id))\n        .then(doc => recoveredDoc = doc)\n        // ensure remove works\n        .then(() => pouch.remove(recoveredDoc))\n        .then(() => true)\n        .then(() => {\n            if (recoveredDoc && recoveredDoc.value && recoveredDoc.value.ok)\n                return true;\n            else\n                return false;\n        })\n        .catch(() => false);\n\n    /**\n     * NOTICE:\n     * Do not remove the pouchdb-instance after the test\n     * The problem is that when this function is call in parallel,\n     * for example when you restore the tabs from a browser-session and open\n     * the same website multiple times at the same time,\n     * calling destroy would possibly crash the other call\n     */\n}\n"]}
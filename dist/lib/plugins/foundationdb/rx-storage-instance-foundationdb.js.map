{"version":3,"file":"rx-storage-instance-foundationdb.js","names":["RxStorageInstanceFoundationDB","storage","databaseName","collectionName","schema","internals","options","settings","closed","changes$","Subject","primaryPath","getPrimaryFieldOfPrimaryKey","primaryKey","bulkWrite","documentWrites","context","dbsPromise","dbs","categorized","root","doTransaction","tx","ret","success","error","ids","map","row","document","mainTx","at","main","subspace","attachmentTx","attachments","docsInDB","Map","Promise","all","id","get","doc","set","categorizeBulkWriteRows","errors","bulkInsertDocs","forEach","writeRow","docId","Object","values","indexes","indexMeta","indexString","getIndexableString","indexTx","db","bulkUpdateDocs","oldIndexString","ensureNotFalsy","previous","newIndexString","attachmentsAdd","attachment","attachmentMapKey","documentId","attachmentId","attachmentData","attachmentsUpdate","attachmentsRemove","result","eventBulk","events","length","lastState","getNewestOfDocumentStates","checkpoint","lwt","_meta","next","findDocumentsById","withDeleted","docInDb","_deleted","query","preparedQuery","queryFoundationDB","getAttachmentData","data","getChangedDocumentsSince","limit","require","keySelector","StreamingMode","index","indexName","getFoundationDBIndexName","lowerBoundString","checkpointPartialDoc","innerResult","getRangeAll","firstGreaterThan","INDEX_MAX","streamingMode","Exact","range","docIds","docsData","concat","lastDoc","lastOfArray","documents","changeStream","asObservable","remove","clearRange","PROMISE_RESOLVE_VOID","close","cleanup","minimumDeletedTime","maxDeletionTime","now","CLEANUP_INDEX","getStartIndexStringFromLowerBound","upperBoundString","getStartIndexStringFromUpperBound","noMoreUndeleted","batchSize","pop","subIndexDB","docData","conflictResultionTasks","resolveConflictResultionTask","_taskSolution","reject","newRxError","database","collection","complete","createFoundationDBStorageInstance","params","open","directory","encoders","connection","clusterFile","createOrOpen","dir","version","withKeyEncoding","string","withValueEncoding","json","indexDBs","useIndexes","slice","push","useIndexesFinal","indexAr","Array","isArray","unshift","indexDB","getIndexableStringMonad","instance","resolve"],"sources":["../../../../src/plugins/foundationdb/rx-storage-instance-foundationdb.ts"],"sourcesContent":["import { Observable, Subject } from 'rxjs';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport type {\n    BulkWriteRow,\n    CategorizeBulkWriteRowsOutput,\n    EventBulk,\n    RxAttachmentWriteData,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxDocumentData,\n    RxDocumentDataById,\n    RxJsonSchema,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageDefaultCheckpoint,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult,\n    StringKeys\n} from '../../types';\nimport type {\n    FoundationDBDatabase,\n    FoundationDBIndexMeta,\n    FoundationDBStorageInternals,\n    RxStorageFoundationDB,\n    RxStorageFoundationDBInstanceCreationOptions,\n    RxStorageFoundationDBSettings\n} from './foundationdb-types';\n// import {\n//     open as foundationDBOpen,\n//     directory as foundationDBDirectory,\n//     encoders as foundationDBEncoders,\n//     keySelector as foundationDBKeySelector,\n//     StreamingMode as foundationDBStreamingMode\n// } from 'foundationdb';\nimport {\n    categorizeBulkWriteRows,\n    getNewestOfDocumentStates\n} from '../../rx-storage-helper';\nimport {\n\n    CLEANUP_INDEX,\n    getFoundationDBIndexName\n} from './foundationdb-helpers';\nimport { newRxError } from '../../rx-error';\nimport {\n    getIndexableStringMonad,\n    getStartIndexStringFromLowerBound,\n    getStartIndexStringFromUpperBound\n} from '../../custom-index';\nimport {\n    ensureNotFalsy, lastOfArray, now\n    , PROMISE_RESOLVE_VOID\n} from '../../util';\nimport { queryFoundationDB } from './foundationdb-query';\nimport { INDEX_MAX } from '../../query-planner';\nimport { attachmentMapKey } from '../memory';\n\nexport class RxStorageInstanceFoundationDB<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    FoundationDBStorageInternals<RxDocType>,\n    RxStorageFoundationDBInstanceCreationOptions,\n    RxStorageDefaultCheckpoint\n> {\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n\n    public closed = false;\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = new Subject();\n\n    constructor(\n        public readonly storage: RxStorageFoundationDB,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: FoundationDBStorageInternals<RxDocType>,\n        public readonly options: Readonly<RxStorageFoundationDBInstanceCreationOptions>,\n        public readonly settings: RxStorageFoundationDBSettings\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n    }\n\n    async bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        const dbs = await this.internals.dbsPromise;\n        let categorized: CategorizeBulkWriteRowsOutput<RxDocType> | undefined = null as any;\n        const result = await dbs.root.doTransaction(async (tx: any) => {\n            const ret: RxStorageBulkWriteResponse<RxDocType> = {\n                success: {},\n                error: {}\n            };\n\n            const ids = documentWrites.map(row => (row.document as any)[this.primaryPath]);\n            const mainTx = tx.at(dbs.main.subspace);\n            const attachmentTx = tx.at(dbs.attachments.subspace);\n            const docsInDB = new Map<string, RxDocumentData<RxDocType>>();\n            /**\n             * TODO this might be faster if fdb\n             * any time adds a bulk-fetch-by-key method.\n             */\n            await Promise.all(\n                ids.map(async (id) => {\n                    const doc = await mainTx.get(id);\n                    docsInDB.set(id, doc);\n                })\n            );\n\n\n            categorized = categorizeBulkWriteRows<RxDocType>(\n                this,\n                this.primaryPath as any,\n                docsInDB,\n                documentWrites,\n                context\n            );\n\n            ret.error = categorized.errors;\n\n            // INSERTS\n            categorized.bulkInsertDocs.forEach(writeRow => {\n                const docId: string = writeRow.document[this.primaryPath] as any;\n                ret.success[docId] = writeRow.document;\n\n                // insert document data\n                mainTx.set(docId, writeRow.document);\n\n                // insert secondary indexes\n                Object.values(dbs.indexes).forEach(indexMeta => {\n                    const indexString = indexMeta.getIndexableString(writeRow.document);\n                    const indexTx = tx.at(indexMeta.db.subspace);\n                    indexTx.set(indexString, docId);\n                });\n            });\n            // UPDATES\n            categorized.bulkUpdateDocs.forEach((writeRow: BulkWriteRow<RxDocType>) => {\n                const docId: string = writeRow.document[this.primaryPath] as any;\n\n                // overwrite document data\n                mainTx.set(docId, writeRow.document);\n\n                // update secondary indexes\n                Object.values(dbs.indexes).forEach(indexMeta => {\n                    const oldIndexString = indexMeta.getIndexableString(ensureNotFalsy(writeRow.previous));\n                    const newIndexString = indexMeta.getIndexableString(writeRow.document);\n                    if (oldIndexString !== newIndexString) {\n                        const indexTx = tx.at(indexMeta.db.subspace);\n                        indexTx.delete(oldIndexString);\n                        indexTx.set(newIndexString, docId);\n                    }\n                });\n                ret.success[docId] = writeRow.document;\n            });\n\n            // attachments\n            categorized.attachmentsAdd.forEach(attachment => {\n                attachmentTx.set(\n                    attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                    attachment.attachmentData\n                );\n            });\n            categorized.attachmentsUpdate.forEach(attachment => {\n                attachmentTx.set(\n                    attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                    attachment.attachmentData\n                );\n            });\n            categorized.attachmentsRemove.forEach(attachment => {\n                attachmentTx.delete(\n                    attachmentMapKey(attachment.documentId, attachment.attachmentId)\n                );\n            });\n\n            return ret;\n        });\n        /**\n         * The events must be emitted AFTER the transaction\n         * has finished.\n         * Otherwise an observable changestream might cause a read\n         * to a document that does not already exist outside of the transaction.\n         */\n        if (ensureNotFalsy(categorized).eventBulk.events.length > 0) {\n            const lastState = getNewestOfDocumentStates<any>(\n                this.primaryPath as any,\n                Object.values(result.success)\n            );\n            ensureNotFalsy(categorized).eventBulk.checkpoint = {\n                id: lastState[this.primaryPath],\n                lwt: lastState._meta.lwt\n            };\n            this.changes$.next(ensureNotFalsy(categorized).eventBulk);\n        }\n        return result;\n    }\n\n    async findDocumentsById(ids: string[], withDeleted: boolean): Promise<RxDocumentDataById<RxDocType>> {\n        const dbs = await this.internals.dbsPromise;\n        return dbs.main.doTransaction(async (tx: any) => {\n            const ret: RxDocumentDataById<RxDocType> = {};\n            await Promise.all(\n                ids.map(async (docId) => {\n                    const docInDb = await tx.get(docId);\n                    if (\n                        docInDb &&\n                        (\n                            !docInDb._deleted ||\n                            withDeleted\n                        )\n                    ) {\n                        ret[docId] = docInDb;\n                    }\n                })\n            );\n            return ret;\n        });\n    }\n    query(preparedQuery: any): Promise<RxStorageQueryResult<RxDocType>> {\n        return queryFoundationDB(this, preparedQuery);\n    }\n    async getAttachmentData(documentId: string, attachmentId: string): Promise<string> {\n        const dbs = await this.internals.dbsPromise;\n        const attachment = await dbs.attachments.get(attachmentMapKey(documentId, attachmentId));\n        return attachment.data;\n    }\n    async getChangedDocumentsSince(limit: number, checkpoint?: RxStorageDefaultCheckpoint): Promise<{ documents: RxDocumentData<RxDocType>[]; checkpoint: RxStorageDefaultCheckpoint; }> {\n        const {\n            keySelector,\n            StreamingMode\n        } = require('foundationdb');\n        const dbs = await this.internals.dbsPromise;\n        const index = [\n            '_meta.lwt',\n            this.primaryPath as any\n        ];\n        const indexName = getFoundationDBIndexName(index);\n        const indexMeta = dbs.indexes[indexName];\n        let lowerBoundString = '';\n        if (checkpoint) {\n            const checkpointPartialDoc: any = {\n                [this.primaryPath]: checkpoint.id,\n                _meta: {\n                    lwt: checkpoint.lwt\n                }\n            };\n            lowerBoundString = indexMeta.getIndexableString(checkpointPartialDoc);\n        }\n        const result: RxDocumentData<RxDocType>[] = await dbs.root.doTransaction(async (tx: any) => {\n            let innerResult: RxDocumentData<RxDocType>[] = [];\n            const indexTx = tx.at(indexMeta.db.subspace);\n            const mainTx = tx.at(dbs.main.subspace);\n            const range = await indexTx.getRangeAll(\n                keySelector.firstGreaterThan(lowerBoundString),\n                INDEX_MAX,\n                {\n                    limit,\n                    streamingMode: StreamingMode.Exact\n                }\n            );\n            const docIds = range.map((row: string[]) => row[1]);\n            const docsData: RxDocumentData<RxDocType>[] = await Promise.all(\n                docIds.map((docId: string) => mainTx.get(docId))\n            );\n            innerResult = innerResult.concat(docsData);\n            return innerResult;\n        });\n        const lastDoc = lastOfArray(result);\n        return {\n            documents: result,\n            checkpoint: lastDoc ? {\n                id: lastDoc[this.primaryPath] as any,\n                lwt: lastDoc._meta.lwt\n            } : checkpoint ? checkpoint : {\n                id: '',\n                lwt: 0\n            }\n        };\n    }\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocType>, RxStorageDefaultCheckpoint>> {\n        return this.changes$.asObservable();\n    }\n\n    async remove(): Promise<void> {\n        const dbs = await this.internals.dbsPromise;\n        await dbs.root.doTransaction((tx: any) => {\n            tx.clearRange('', INDEX_MAX);\n            return PROMISE_RESOLVE_VOID;\n        });\n        return this.close();\n    }\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        const {\n            keySelector,\n            StreamingMode\n        } = require('foundationdb');\n        const maxDeletionTime = now() - minimumDeletedTime;\n        const dbs = await this.internals.dbsPromise;\n        const index = CLEANUP_INDEX;\n        const indexName = getFoundationDBIndexName(index);\n        const indexMeta = dbs.indexes[indexName];\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            [\n                true,\n                /**\n                 * Do not use 0 here,\n                 * because 1 is the minimum value for _meta.lwt\n                 */\n                1\n            ]\n        );\n        const upperBoundString = getStartIndexStringFromUpperBound(\n            this.schema,\n            index,\n            [\n                true,\n                maxDeletionTime\n            ]\n        );\n        let noMoreUndeleted: boolean = true;\n        await dbs.root.doTransaction(async (tx: any) => {\n            const batchSize = ensureNotFalsy(this.settings.batchSize);\n            const indexTx = tx.at(indexMeta.db.subspace);\n            const mainTx = tx.at(dbs.main.subspace);\n            const range = await indexTx.getRangeAll(\n                keySelector.firstGreaterThan(lowerBoundString),\n                upperBoundString,\n                {\n                    limit: batchSize + 1, // get one more extra to detect what to return from cleanup()\n                    streamingMode: StreamingMode.Exact\n                }\n            );\n            if (range.length > batchSize) {\n                noMoreUndeleted = false;\n                range.pop();\n            }\n            const docIds = range.map((row: string[]) => row[1]);\n            const docsData: RxDocumentData<RxDocType>[] = await Promise.all(docIds.map((docId: string) => mainTx.get(docId)));\n\n            Object\n                .values(dbs.indexes)\n                .forEach(indexMeta => {\n                    const subIndexDB = tx.at(indexMeta.db.subspace);\n                    docsData.forEach(docData => {\n                        const indexString = indexMeta.getIndexableString(docData);\n                        subIndexDB.delete(indexString);\n                    });\n                });\n            docIds.forEach((id: string) => mainTx.delete(id));\n        });\n\n        return noMoreUndeleted;\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return new Subject<any>().asObservable();\n    }\n    resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> {\n        return PROMISE_RESOLVE_VOID;\n    }\n\n    async close() {\n        if (this.closed) {\n            return Promise.reject(newRxError('SNH', {\n                database: this.databaseName,\n                collection: this.collectionName\n            }));\n        }\n        this.closed = true;\n        this.changes$.complete();\n\n        const dbs = await this.internals.dbsPromise;\n        dbs.root.close();\n\n        // TODO shouldnt we close the index databases?\n        // Object.values(dbs.indexes).forEach(db => db.close());\n    }\n}\n\n\nexport function createFoundationDBStorageInstance<RxDocType>(\n    storage: RxStorageFoundationDB,\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageFoundationDBInstanceCreationOptions>,\n    settings: RxStorageFoundationDBSettings\n): Promise<RxStorageInstanceFoundationDB<RxDocType>> {\n    const primaryPath = getPrimaryFieldOfPrimaryKey(params.schema.primaryKey);\n\n    const {\n        open,\n        directory,\n        encoders\n    } = require('foundationdb');\n\n    const connection = open(settings.clusterFile);\n    const dbsPromise = (async () => {\n        const dir = await directory.createOrOpen(connection, 'rxdb');\n\n        const root = connection\n            .at(dir)\n            .at(params.databaseName + '.')\n            .at(params.collectionName + '.')\n            .at(params.schema.version + '.');\n        const main: FoundationDBDatabase<RxDocType> = root\n            .at('main.')\n            .withKeyEncoding(encoders.string) // automatically encode & decode keys using tuples\n            .withValueEncoding(encoders.json) as any; // and values using JSON\n\n\n        const events: FoundationDBDatabase<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = root\n            .at('events.')\n            .withKeyEncoding(encoders.string)\n            .withValueEncoding(encoders.json) as any;\n\n        const attachments: FoundationDBDatabase<RxAttachmentWriteData> = root\n            .at('attachments.')\n            .withKeyEncoding(encoders.string)\n            .withValueEncoding(encoders.json) as any;\n\n\n        const indexDBs: { [indexName: string]: FoundationDBIndexMeta<RxDocType> } = {};\n        const useIndexes = params.schema.indexes ? params.schema.indexes.slice(0) : [];\n        useIndexes.push([primaryPath]);\n        const useIndexesFinal = useIndexes.map(index => {\n            const indexAr = Array.isArray(index) ? index.slice(0) : [index];\n            indexAr.unshift('_deleted');\n            return indexAr;\n        })\n        // used for `getChangedDocumentsSince()`\n        useIndexesFinal.push([\n            '_meta.lwt',\n            primaryPath\n        ]);\n        useIndexesFinal.push(CLEANUP_INDEX);\n        useIndexesFinal.forEach(indexAr => {\n            const indexName = getFoundationDBIndexName(indexAr);\n            const indexDB = root.at(indexName + '.')\n                .withKeyEncoding(encoders.string)\n                .withValueEncoding(encoders.string);\n            indexDBs[indexName] = {\n                indexName,\n                db: indexDB,\n                getIndexableString: getIndexableStringMonad(params.schema, indexAr),\n                index: indexAr\n            };\n        });\n\n        return {\n            root,\n            main,\n            events,\n            attachments,\n            indexes: indexDBs\n        };\n    })();\n\n\n    const internals: FoundationDBStorageInternals<RxDocType> = {\n        connection,\n        dbsPromise: dbsPromise\n    };\n\n    const instance = new RxStorageInstanceFoundationDB(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n    return Promise.resolve(instance);\n}\n"],"mappings":";;;;;;;;AAAA;;AACA;;AAkCA;;AAIA;;AAKA;;AACA;;AAKA;;AAIA;;AACA;;AACA;;AA5BA;AACA;AACA;AACA;AACA;AACA;AACA;IAwBaA,6B;EAWT,uCACoBC,OADpB,EAEoBC,YAFpB,EAGoBC,cAHpB,EAIoBC,MAJpB,EAKoBC,SALpB,EAMoBC,OANpB,EAOoBC,QAPpB,EAQE;IAAA,KAXKC,MAWL,GAXc,KAWd;IAAA,KAVMC,QAUN,GAVkH,IAAIC,aAAJ,EAUlH;IAAA,KAPkBT,OAOlB,GAPkBA,OAOlB;IAAA,KANkBC,YAMlB,GANkBA,YAMlB;IAAA,KALkBC,cAKlB,GALkBA,cAKlB;IAAA,KAJkBC,MAIlB,GAJkBA,MAIlB;IAAA,KAHkBC,SAGlB,GAHkBA,SAGlB;IAAA,KAFkBC,OAElB,GAFkBA,OAElB;IAAA,KADkBC,QAClB,GADkBA,QAClB;IACE,KAAKI,WAAL,GAAmB,IAAAC,2CAAA,EAA4B,KAAKR,MAAL,CAAYS,UAAxC,CAAnB;EACH;;;;SAEKC,S,sBACFC,c,EACAC,O;QAC8C;MAAA,aAC5B,IAD4B;;MAAA,uBAC5B,OAAKX,SAAL,CAAeY,UADa,iBACxCC,GADwC;QAE9C,IAAIC,WAAiE,GAAG,IAAxE;QAF8C,uBAGzBD,GAAG,CAACE,IAAJ,CAASC,aAAT,WAA8BC,EAA9B;UAAA,IAA0C;YAC3D,IAAMC,GAA0C,GAAG;cAC/CC,OAAO,EAAE,EADsC;cAE/CC,KAAK,EAAE;YAFwC,CAAnD;YAKA,IAAMC,GAAG,GAAGX,cAAc,CAACY,GAAf,CAAmB,UAAAC,GAAG;cAAA,OAAKA,GAAG,CAACC,QAAL,CAAsB,OAAKlB,WAA3B,CAAJ;YAAA,CAAtB,CAAZ;YACA,IAAMmB,MAAM,GAAGR,EAAE,CAACS,EAAH,CAAMb,GAAG,CAACc,IAAJ,CAASC,QAAf,CAAf;YACA,IAAMC,YAAY,GAAGZ,EAAE,CAACS,EAAH,CAAMb,GAAG,CAACiB,WAAJ,CAAgBF,QAAtB,CAArB;YACA,IAAMG,QAAQ,GAAG,IAAIC,GAAJ,EAAjB;YACA;AACZ;AACA;AACA;;YAbuE,uBAcrDC,OAAO,CAACC,GAAR,CACFb,GAAG,CAACC,GAAJ,WAAea,EAAf;cAAA,IAAsB;gBAAA,uBACAV,MAAM,CAACW,GAAP,CAAWD,EAAX,CADA,iBACZE,GADY;kBAElBN,QAAQ,CAACO,GAAT,CAAaH,EAAb,EAAiBE,GAAjB;gBAFkB;cAGrB,CAHD;gBAAA;cAAA;YAAA,EADE,CAdqD;cAsB3DvB,WAAW,GAAG,IAAAyB,wCAAA,UAEV,OAAKjC,WAFK,EAGVyB,QAHU,EAIVrB,cAJU,EAKVC,OALU,CAAd;cAQAO,GAAG,CAACE,KAAJ,GAAYN,WAAW,CAAC0B,MAAxB,CA9B2D,CAgC3D;;cACA1B,WAAW,CAAC2B,cAAZ,CAA2BC,OAA3B,CAAmC,UAAAC,QAAQ,EAAI;gBAC3C,IAAMC,KAAa,GAAGD,QAAQ,CAACnB,QAAT,CAAkB,OAAKlB,WAAvB,CAAtB;gBACAY,GAAG,CAACC,OAAJ,CAAYyB,KAAZ,IAAqBD,QAAQ,CAACnB,QAA9B,CAF2C,CAI3C;;gBACAC,MAAM,CAACa,GAAP,CAAWM,KAAX,EAAkBD,QAAQ,CAACnB,QAA3B,EAL2C,CAO3C;;gBACAqB,MAAM,CAACC,MAAP,CAAcjC,GAAG,CAACkC,OAAlB,EAA2BL,OAA3B,CAAmC,UAAAM,SAAS,EAAI;kBAC5C,IAAMC,WAAW,GAAGD,SAAS,CAACE,kBAAV,CAA6BP,QAAQ,CAACnB,QAAtC,CAApB;kBACA,IAAM2B,OAAO,GAAGlC,EAAE,CAACS,EAAH,CAAMsB,SAAS,CAACI,EAAV,CAAaxB,QAAnB,CAAhB;kBACAuB,OAAO,CAACb,GAAR,CAAYW,WAAZ,EAAyBL,KAAzB;gBACH,CAJD;cAKH,CAbD,EAjC2D,CA+C3D;;cACA9B,WAAW,CAACuC,cAAZ,CAA2BX,OAA3B,CAAmC,UAACC,QAAD,EAAuC;gBACtE,IAAMC,KAAa,GAAGD,QAAQ,CAACnB,QAAT,CAAkB,OAAKlB,WAAvB,CAAtB,CADsE,CAGtE;;gBACAmB,MAAM,CAACa,GAAP,CAAWM,KAAX,EAAkBD,QAAQ,CAACnB,QAA3B,EAJsE,CAMtE;;gBACAqB,MAAM,CAACC,MAAP,CAAcjC,GAAG,CAACkC,OAAlB,EAA2BL,OAA3B,CAAmC,UAAAM,SAAS,EAAI;kBAC5C,IAAMM,cAAc,GAAGN,SAAS,CAACE,kBAAV,CAA6B,IAAAK,oBAAA,EAAeZ,QAAQ,CAACa,QAAxB,CAA7B,CAAvB;kBACA,IAAMC,cAAc,GAAGT,SAAS,CAACE,kBAAV,CAA6BP,QAAQ,CAACnB,QAAtC,CAAvB;;kBACA,IAAI8B,cAAc,KAAKG,cAAvB,EAAuC;oBACnC,IAAMN,OAAO,GAAGlC,EAAE,CAACS,EAAH,CAAMsB,SAAS,CAACI,EAAV,CAAaxB,QAAnB,CAAhB;oBACAuB,OAAO,UAAP,CAAeG,cAAf;oBACAH,OAAO,CAACb,GAAR,CAAYmB,cAAZ,EAA4Bb,KAA5B;kBACH;gBACJ,CARD;gBASA1B,GAAG,CAACC,OAAJ,CAAYyB,KAAZ,IAAqBD,QAAQ,CAACnB,QAA9B;cACH,CAjBD,EAhD2D,CAmE3D;;cACAV,WAAW,CAAC4C,cAAZ,CAA2BhB,OAA3B,CAAmC,UAAAiB,UAAU,EAAI;gBAC7C9B,YAAY,CAACS,GAAb,CACI,IAAAsB,wBAAA,EAAiBD,UAAU,CAACE,UAA5B,EAAwCF,UAAU,CAACG,YAAnD,CADJ,EAEIH,UAAU,CAACI,cAFf;cAIH,CALD;cAMAjD,WAAW,CAACkD,iBAAZ,CAA8BtB,OAA9B,CAAsC,UAAAiB,UAAU,EAAI;gBAChD9B,YAAY,CAACS,GAAb,CACI,IAAAsB,wBAAA,EAAiBD,UAAU,CAACE,UAA5B,EAAwCF,UAAU,CAACG,YAAnD,CADJ,EAEIH,UAAU,CAACI,cAFf;cAIH,CALD;cAMAjD,WAAW,CAACmD,iBAAZ,CAA8BvB,OAA9B,CAAsC,UAAAiB,UAAU,EAAI;gBAChD9B,YAAY,UAAZ,CACI,IAAA+B,wBAAA,EAAiBD,UAAU,CAACE,UAA5B,EAAwCF,UAAU,CAACG,YAAnD,CADJ;cAGH,CAJD;cAMA,OAAO5C,GAAP;YAtF2D;UAuF9D,CAvFoB;YAAA;UAAA;QAAA,EAHyB,iBAGxCgD,MAHwC;UA2F9C;AACR;AACA;AACA;AACA;AACA;UACQ,IAAI,IAAAX,oBAAA,EAAezC,WAAf,EAA4BqD,SAA5B,CAAsCC,MAAtC,CAA6CC,MAA7C,GAAsD,CAA1D,EAA6D;YACzD,IAAMC,SAAS,GAAG,IAAAC,0CAAA,EACd,OAAKjE,WADS,EAEduC,MAAM,CAACC,MAAP,CAAcoB,MAAM,CAAC/C,OAArB,CAFc,CAAlB;YAIA,IAAAoC,oBAAA,EAAezC,WAAf,EAA4BqD,SAA5B,CAAsCK,UAAtC,GAAmD;cAC/CrC,EAAE,EAAEmC,SAAS,CAAC,OAAKhE,WAAN,CADkC;cAE/CmE,GAAG,EAAEH,SAAS,CAACI,KAAV,CAAgBD;YAF0B,CAAnD;;YAIA,OAAKrE,QAAL,CAAcuE,IAAd,CAAmB,IAAApB,oBAAA,EAAezC,WAAf,EAA4BqD,SAA/C;UACH;;UACD,OAAOD,MAAP;QA5G8C;MAAA;IA6GjD,C;;;;;SAEKU,iB,8BAAkBvD,G,EAAewD,W;QAA8D;MAAA,aAC/E,IAD+E;;MAAA,uBAC/E,OAAK7E,SAAL,CAAeY,UADgE,iBAC3FC,GAD2F;QAEjG,OAAOA,GAAG,CAACc,IAAJ,CAASX,aAAT,WAA8BC,EAA9B;UAAA,IAA0C;YAC7C,IAAMC,GAAkC,GAAG,EAA3C;YAD6C,uBAEvCe,OAAO,CAACC,GAAR,CACFb,GAAG,CAACC,GAAJ,WAAesB,KAAf;cAAA,IAAyB;gBAAA,uBACC3B,EAAE,CAACmB,GAAH,CAAOQ,KAAP,CADD,iBACfkC,OADe;kBAAA,IAGjBA,OAAO,KAEH,CAACA,OAAO,CAACC,QAAT,IACAF,WAHG,CAHU;oBASjB3D,GAAG,CAAC0B,KAAD,CAAH,GAAakC,OAAb;kBATiB;gBAAA;cAWxB,CAXD;gBAAA;cAAA;YAAA,EADE,CAFuC;cAgB7C,OAAO5D,GAAP;YAhB6C;UAiBhD,CAjBM;YAAA;UAAA;QAAA,EAAP;MAFiG;IAoBpG,C;;;;;SACD8D,K,GAAA,eAAMC,aAAN,EAAoE;IAChE,OAAO,IAAAC,oCAAA,EAAkB,IAAlB,EAAwBD,aAAxB,CAAP;EACH,C;;SACKE,iB,8BAAkBtB,U,EAAoBC,Y;QAAuC;MAAA,aAC7D,IAD6D;;MAAA,uBAC7D,OAAK9D,SAAL,CAAeY,UAD8C,iBACzEC,GADyE;QAAA,uBAEtDA,GAAG,CAACiB,WAAJ,CAAgBM,GAAhB,CAAoB,IAAAwB,wBAAA,EAAiBC,UAAjB,EAA6BC,YAA7B,CAApB,CAFsD,iBAEzEH,UAFyE;UAG/E,OAAOA,UAAU,CAACyB,IAAlB;QAH+E;MAAA;IAIlF,C;;;;;SACKC,wB,qCAAyBC,K,EAAed,U;QAAuI;MAAA,aAK/J,IAL+J;;MACjL,eAGIe,OAAO,CAAC,cAAD,CAHX;MAAA,IACIC,WADJ,YACIA,WADJ;MAAA,IAEIC,aAFJ,YAEIA,aAFJ;;MADiL,uBAK/J,OAAKzF,SAAL,CAAeY,UALgJ,iBAK3KC,GAL2K;QAMjL,IAAM6E,KAAK,GAAG,CACV,WADU,EAEV,OAAKpF,WAFK,CAAd;QAIA,IAAMqF,SAAS,GAAG,IAAAC,6CAAA,EAAyBF,KAAzB,CAAlB;QACA,IAAM1C,SAAS,GAAGnC,GAAG,CAACkC,OAAJ,CAAY4C,SAAZ,CAAlB;QACA,IAAIE,gBAAgB,GAAG,EAAvB;;QACA,IAAIrB,UAAJ,EAAgB;UAAA;;UACZ,IAAMsB,oBAAyB,sDAC1B,OAAKxF,WADqB,IACPkE,UAAU,CAACrC,EADJ,wBAE3BuC,KAF2B,GAEpB;YACHD,GAAG,EAAED,UAAU,CAACC;UADb,CAFoB,wBAA/B;UAMAoB,gBAAgB,GAAG7C,SAAS,CAACE,kBAAV,CAA6B4C,oBAA7B,CAAnB;QACH;;QArBgL,uBAsB/HjF,GAAG,CAACE,IAAJ,CAASC,aAAT,WAA8BC,EAA9B;UAAA,IAA0C;YACxF,IAAI8E,WAAwC,GAAG,EAA/C;YACA,IAAM5C,OAAO,GAAGlC,EAAE,CAACS,EAAH,CAAMsB,SAAS,CAACI,EAAV,CAAaxB,QAAnB,CAAhB;YACA,IAAMH,MAAM,GAAGR,EAAE,CAACS,EAAH,CAAMb,GAAG,CAACc,IAAJ,CAASC,QAAf,CAAf;YAHwF,uBAIpEuB,OAAO,CAAC6C,WAAR,CAChBR,WAAW,CAACS,gBAAZ,CAA6BJ,gBAA7B,CADgB,EAEhBK,uBAFgB,EAGhB;cACIZ,KAAK,EAALA,KADJ;cAEIa,aAAa,EAAEV,aAAa,CAACW;YAFjC,CAHgB,CAJoE,iBAIlFC,KAJkF;cAYxF,IAAMC,MAAM,GAAGD,KAAK,CAAC/E,GAAN,CAAU,UAACC,GAAD;gBAAA,OAAmBA,GAAG,CAAC,CAAD,CAAtB;cAAA,CAAV,CAAf;cAZwF,uBAapCU,OAAO,CAACC,GAAR,CAChDoE,MAAM,CAAChF,GAAP,CAAW,UAACsB,KAAD;gBAAA,OAAmBnB,MAAM,CAACW,GAAP,CAAWQ,KAAX,CAAnB;cAAA,CAAX,CADgD,CAboC,iBAalF2D,QAbkF;gBAgBxFR,WAAW,GAAGA,WAAW,CAACS,MAAZ,CAAmBD,QAAnB,CAAd;gBACA,OAAOR,WAAP;cAjBwF;YAAA;UAkB3F,CAlBiD;YAAA;UAAA;QAAA,EAtB+H,iBAsB3K7B,MAtB2K;UAyCjL,IAAMuC,OAAO,GAAG,IAAAC,iBAAA,EAAYxC,MAAZ,CAAhB;UACA,OAAO;YACHyC,SAAS,EAAEzC,MADR;YAEHM,UAAU,EAAEiC,OAAO,GAAG;cAClBtE,EAAE,EAAEsE,OAAO,CAAC,OAAKnG,WAAN,CADO;cAElBmE,GAAG,EAAEgC,OAAO,CAAC/B,KAAR,CAAcD;YAFD,CAAH,GAGfD,UAAU,GAAGA,UAAH,GAAgB;cAC1BrC,EAAE,EAAE,EADsB;cAE1BsC,GAAG,EAAE;YAFqB;UAL3B,CAAP;QA1CiL;MAAA;IAoDpL,C;;;;;SACDmC,Y,GAAA,wBAAmG;IAC/F,OAAO,KAAKxG,QAAL,CAAcyG,YAAd,EAAP;EACH,C;;SAEKC,M;QAAwB;MAAA,cACR,IADQ;;MAAA,uBACR,QAAK9G,SAAL,CAAeY,UADP,iBACpBC,GADoB;QAAA,uBAEpBA,GAAG,CAACE,IAAJ,CAASC,aAAT,CAAuB,UAACC,EAAD,EAAa;UACtCA,EAAE,CAAC8F,UAAH,CAAc,EAAd,EAAkBb,uBAAlB;UACA,OAAOc,0BAAP;QACH,CAHK,CAFoB;UAM1B,OAAO,QAAKC,KAAL,EAAP;QAN0B;MAAA;IAO7B,C;;;;;SACKC,O,oBAAQC,kB;QAA8C;MAAA,cAMtC,IANsC;;MACxD,gBAGI5B,OAAO,CAAC,cAAD,CAHX;MAAA,IACIC,WADJ,aACIA,WADJ;MAAA,IAEIC,aAFJ,aAEIA,aAFJ;;MAIA,IAAM2B,eAAe,GAAG,IAAAC,SAAA,MAAQF,kBAAhC;MALwD,uBAMtC,QAAKnH,SAAL,CAAeY,UANuB,iBAMlDC,GANkD;QAOxD,IAAM6E,KAAK,GAAG4B,kCAAd;QACA,IAAM3B,SAAS,GAAG,IAAAC,6CAAA,EAAyBF,KAAzB,CAAlB;QACA,IAAM1C,SAAS,GAAGnC,GAAG,CAACkC,OAAJ,CAAY4C,SAAZ,CAAlB;QACA,IAAME,gBAAgB,GAAG,IAAA0B,8CAAA,EACrB,QAAKxH,MADgB,EAErB2F,KAFqB,EAGrB,CACI,IADJ;QAEI;AAChB;AACA;AACA;QACgB,CANJ,CAHqB,CAAzB;QAYA,IAAM8B,gBAAgB,GAAG,IAAAC,8CAAA,EACrB,QAAK1H,MADgB,EAErB2F,KAFqB,EAGrB,CACI,IADJ,EAEI0B,eAFJ,CAHqB,CAAzB;QAQA,IAAIM,eAAwB,GAAG,IAA/B;QA9BwD,uBA+BlD7G,GAAG,CAACE,IAAJ,CAASC,aAAT,WAA8BC,EAA9B;UAAA,IAA0C;YAC5C,IAAM0G,SAAS,GAAG,IAAApE,oBAAA,EAAe,QAAKrD,QAAL,CAAcyH,SAA7B,CAAlB;YACA,IAAMxE,OAAO,GAAGlC,EAAE,CAACS,EAAH,CAAMsB,SAAS,CAACI,EAAV,CAAaxB,QAAnB,CAAhB;YACA,IAAMH,MAAM,GAAGR,EAAE,CAACS,EAAH,CAAMb,GAAG,CAACc,IAAJ,CAASC,QAAf,CAAf;YAH4C,uBAIxBuB,OAAO,CAAC6C,WAAR,CAChBR,WAAW,CAACS,gBAAZ,CAA6BJ,gBAA7B,CADgB,EAEhB2B,gBAFgB,EAGhB;cACIlC,KAAK,EAAEqC,SAAS,GAAG,CADvB;cAC0B;cACtBxB,aAAa,EAAEV,aAAa,CAACW;YAFjC,CAHgB,CAJwB,iBAItCC,KAJsC;cAY5C,IAAIA,KAAK,CAAChC,MAAN,GAAesD,SAAnB,EAA8B;gBAC1BD,eAAe,GAAG,KAAlB;gBACArB,KAAK,CAACuB,GAAN;cACH;;cACD,IAAMtB,MAAM,GAAGD,KAAK,CAAC/E,GAAN,CAAU,UAACC,GAAD;gBAAA,OAAmBA,GAAG,CAAC,CAAD,CAAtB;cAAA,CAAV,CAAf;cAhB4C,uBAiBQU,OAAO,CAACC,GAAR,CAAYoE,MAAM,CAAChF,GAAP,CAAW,UAACsB,KAAD;gBAAA,OAAmBnB,MAAM,CAACW,GAAP,CAAWQ,KAAX,CAAnB;cAAA,CAAX,CAAZ,CAjBR,iBAiBtC2D,QAjBsC;gBAmB5C1D,MAAM,CACDC,MADL,CACYjC,GAAG,CAACkC,OADhB,EAEKL,OAFL,CAEa,UAAAM,SAAS,EAAI;kBAClB,IAAM6E,UAAU,GAAG5G,EAAE,CAACS,EAAH,CAAMsB,SAAS,CAACI,EAAV,CAAaxB,QAAnB,CAAnB;kBACA2E,QAAQ,CAAC7D,OAAT,CAAiB,UAAAoF,OAAO,EAAI;oBACxB,IAAM7E,WAAW,GAAGD,SAAS,CAACE,kBAAV,CAA6B4E,OAA7B,CAApB;oBACAD,UAAU,UAAV,CAAkB5E,WAAlB;kBACH,CAHD;gBAIH,CARL;gBASAqD,MAAM,CAAC5D,OAAP,CAAe,UAACP,EAAD;kBAAA,OAAgBV,MAAM,UAAN,CAAcU,EAAd,CAAhB;gBAAA,CAAf;cA5B4C;YAAA;UA6B/C,CA7BK;YAAA;UAAA;QAAA,EA/BkD;UA8DxD,OAAOuF,eAAP;QA9DwD;MAAA;IA+D3D,C;;;;;SAEDK,sB,GAAA,kCAAyE;IACrE,OAAO,IAAI1H,aAAJ,GAAmBwG,YAAnB,EAAP;EACH,C;;SACDmB,4B,GAAA,sCAA6BC,aAA7B,EAAuG;IACnG,OAAOjB,0BAAP;EACH,C;;SAEKC,K;QAAQ;MAAA,cACN,IADM;;MACV,IAAI,QAAK9G,MAAT,EAAiB;QACb,OAAO8B,OAAO,CAACiG,MAAR,CAAe,IAAAC,mBAAA,EAAW,KAAX,EAAkB;UACpCC,QAAQ,EAAE,QAAKvI,YADqB;UAEpCwI,UAAU,EAAE,QAAKvI;QAFmB,CAAlB,CAAf,CAAP;MAIH;;MACD,QAAKK,MAAL,GAAc,IAAd;;MACA,QAAKC,QAAL,CAAckI,QAAd;;MARU,uBAUQ,QAAKtI,SAAL,CAAeY,UAVvB,iBAUJC,GAVI;QAWVA,GAAG,CAACE,IAAJ,CAASkG,KAAT,GAXU,CAaV;QACA;MAdU;IAeb,C;;;;;;;;;;AAIE,SAASsB,iCAAT,CACH3I,OADG,EAEH4I,MAFG,EAGHtI,QAHG,EAI8C;EACjD,IAAMI,WAAW,GAAG,IAAAC,2CAAA,EAA4BiI,MAAM,CAACzI,MAAP,CAAcS,UAA1C,CAApB;;EAEA,gBAII+E,OAAO,CAAC,cAAD,CAJX;EAAA,IACIkD,IADJ,aACIA,IADJ;EAAA,IAEIC,SAFJ,aAEIA,SAFJ;EAAA,IAGIC,QAHJ,aAGIA,QAHJ;;EAMA,IAAMC,UAAU,GAAGH,IAAI,CAACvI,QAAQ,CAAC2I,WAAV,CAAvB;;EACA,IAAMjI,UAAU,GAAG;IAAA,IAAa;MAAA,uBACV8H,SAAS,CAACI,YAAV,CAAuBF,UAAvB,EAAmC,MAAnC,CADU,iBACtBG,GADsB;QAG5B,IAAMhI,IAAI,GAAG6H,UAAU,CAClBlH,EADQ,CACLqH,GADK,EAERrH,EAFQ,CAEL8G,MAAM,CAAC3I,YAAP,GAAsB,GAFjB,EAGR6B,EAHQ,CAGL8G,MAAM,CAAC1I,cAAP,GAAwB,GAHnB,EAIR4B,EAJQ,CAIL8G,MAAM,CAACzI,MAAP,CAAciJ,OAAd,GAAwB,GAJnB,CAAb;QAKA,IAAMrH,IAAqC,GAAGZ,IAAI,CAC7CW,EADyC,CACtC,OADsC,EAEzCuH,eAFyC,CAEzBN,QAAQ,CAACO,MAFgB,EAER;QAFQ,CAGzCC,iBAHyC,CAGvBR,QAAQ,CAACS,IAHc,CAA9C,CAR4B,CAWkB;;QAG9C,IAAMhF,MAAoH,GAAGrD,IAAI,CAC5HW,EADwH,CACrH,SADqH,EAExHuH,eAFwH,CAExGN,QAAQ,CAACO,MAF+F,EAGxHC,iBAHwH,CAGtGR,QAAQ,CAACS,IAH6F,CAA7H;QAKA,IAAMtH,WAAwD,GAAGf,IAAI,CAChEW,EAD4D,CACzD,cADyD,EAE5DuH,eAF4D,CAE5CN,QAAQ,CAACO,MAFmC,EAG5DC,iBAH4D,CAG1CR,QAAQ,CAACS,IAHiC,CAAjE;QAMA,IAAMC,QAAmE,GAAG,EAA5E;QACA,IAAMC,UAAU,GAAGd,MAAM,CAACzI,MAAP,CAAcgD,OAAd,GAAwByF,MAAM,CAACzI,MAAP,CAAcgD,OAAd,CAAsBwG,KAAtB,CAA4B,CAA5B,CAAxB,GAAyD,EAA5E;QACAD,UAAU,CAACE,IAAX,CAAgB,CAAClJ,WAAD,CAAhB;QACA,IAAMmJ,eAAe,GAAGH,UAAU,CAAChI,GAAX,CAAe,UAAAoE,KAAK,EAAI;UAC5C,IAAMgE,OAAO,GAAGC,KAAK,CAACC,OAAN,CAAclE,KAAd,IAAuBA,KAAK,CAAC6D,KAAN,CAAY,CAAZ,CAAvB,GAAwC,CAAC7D,KAAD,CAAxD;UACAgE,OAAO,CAACG,OAAR,CAAgB,UAAhB;UACA,OAAOH,OAAP;QACH,CAJuB,CAAxB,CA5B4B,CAiC5B;;QACAD,eAAe,CAACD,IAAhB,CAAqB,CACjB,WADiB,EAEjBlJ,WAFiB,CAArB;QAIAmJ,eAAe,CAACD,IAAhB,CAAqBlC,kCAArB;QACAmC,eAAe,CAAC/G,OAAhB,CAAwB,UAAAgH,OAAO,EAAI;UAC/B,IAAM/D,SAAS,GAAG,IAAAC,6CAAA,EAAyB8D,OAAzB,CAAlB;UACA,IAAMI,OAAO,GAAG/I,IAAI,CAACW,EAAL,CAAQiE,SAAS,GAAG,GAApB,EACXsD,eADW,CACKN,QAAQ,CAACO,MADd,EAEXC,iBAFW,CAEOR,QAAQ,CAACO,MAFhB,CAAhB;UAGAG,QAAQ,CAAC1D,SAAD,CAAR,GAAsB;YAClBA,SAAS,EAATA,SADkB;YAElBvC,EAAE,EAAE0G,OAFc;YAGlB5G,kBAAkB,EAAE,IAAA6G,oCAAA,EAAwBvB,MAAM,CAACzI,MAA/B,EAAuC2J,OAAvC,CAHF;YAIlBhE,KAAK,EAAEgE;UAJW,CAAtB;QAMH,CAXD;QAaA,OAAO;UACH3I,IAAI,EAAJA,IADG;UAEHY,IAAI,EAAJA,IAFG;UAGHyC,MAAM,EAANA,MAHG;UAIHtC,WAAW,EAAXA,WAJG;UAKHiB,OAAO,EAAEsG;QALN,CAAP;MApD4B;IA2D/B,CA3DkB;MAAA;IAAA;EAAA,GAAnB;;EA8DA,IAAMrJ,SAAkD,GAAG;IACvD4I,UAAU,EAAVA,UADuD;IAEvDhI,UAAU,EAAEA;EAF2C,CAA3D;EAKA,IAAMoJ,QAAQ,GAAG,IAAIrK,6BAAJ,CACbC,OADa,EAEb4I,MAAM,CAAC3I,YAFM,EAGb2I,MAAM,CAAC1I,cAHM,EAIb0I,MAAM,CAACzI,MAJM,EAKbC,SALa,EAMbwI,MAAM,CAACvI,OANM,EAObC,QAPa,CAAjB;EASA,OAAO+B,OAAO,CAACgI,OAAR,CAAgBD,QAAhB,CAAP;AACH"}
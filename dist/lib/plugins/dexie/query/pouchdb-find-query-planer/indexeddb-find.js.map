{"version":3,"sources":["../../../../../../src/plugins/dexie/query/pouchdb-find-query-planer/indexeddb-find.ts"],"names":["IDB_NULL","Number","MIN_SAFE_INTEGER","IDB_FALSE","IDB_TRUE","COUCH_COLLATE_LO","COUCH_COLLATE_HI","IDB_COLLATE_LO","NEGATIVE_INFINITY","IDB_COLLATE_HI","generateKeyRange","opts","IDBKeyRange","low","height","defined","obj","k","convert","key","exact","filterDeleted","ret","map","Object","prototype","hasOwnProperty","call","length","inclusive_end","inclusive_start","descending","realEndkey","startkey","realInclusiveEnd","endkey","only","lowerBound","upperBound","bound","err","console","dir","error","Error","JSON","stringify"],"mappings":"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","sourcesContent":["/**\n * Copied from\n * @link https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-indexeddb/src/find.js\n */\n\n//const DOC_STORE = 'docs';\nconst IDB_NULL = Number.MIN_SAFE_INTEGER;\nconst IDB_FALSE = Number.MIN_SAFE_INTEGER + 1;\nconst IDB_TRUE = Number.MIN_SAFE_INTEGER + 2;\n\n// Adapted from\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-find/src/adapters/local/find/query-planner.js#L20-L24\n// This could change / improve in the future?\nconst COUCH_COLLATE_LO = null;\nconst COUCH_COLLATE_HI = '\\uffff'; // actually used as {\"\\uffff\": {}}\n\n// Adapted from: https://www.w3.org/TR/IndexedDB/#compare-two-keys\n// Importantly, *there is no upper bound possible* in idb. The ideal data\n// structure an infintely deep array:\n//   var IDB_COLLATE_HI = []; IDB_COLLATE_HI.push(IDB_COLLATE_HI)\n// But IDBKeyRange is not a fan of shenanigans, so I've just gone with 12 layers\n// because it looks nice and surely that's enough!\nconst IDB_COLLATE_LO = Number.NEGATIVE_INFINITY;\nconst IDB_COLLATE_HI = [[[[[[[[[[[[]]]]]]]]]]]];\n// const IDB_COLLATE_HI = DBCore\n\n\n/**\n * Generates a keyrange based on the opts passed to query\n *\n * The first key is always 0, as that's how we're filtering out deleted entries.\n */\nexport function generateKeyRange(\n    opts: any,\n    IDBKeyRange: any,\n    low: any = IDB_COLLATE_LO,\n    height: any = IDB_COLLATE_HI\n) {\n    function defined(obj: any, k: string) {\n        return obj[k] !== void 0;\n    }\n\n    // Converts a valid CouchDB key into a valid IndexedDB one\n    function convert(key: any, exact?: any) {\n\n\n\n        /**\n         * Overwritten.\n         * In dexie.js we store deleted documents at another\n         * table.\n         * So we do not have to filter for deleted ones.\n         */\n        const filterDeleted = [key];\n\n        const ret = filterDeleted.map(function (k) {\n            // null, true and false are not indexable by indexeddb. When we write\n            // these values we convert them to these constants, and so when we\n            // query for them we need to convert the query also.\n            if (k === null && exact) {\n                // for non-exact queries we treat null as a collate property\n                // see `if (!exact)` block below\n                return IDB_NULL;\n            } else if ((k as any) === true) {\n                return IDB_TRUE;\n            } else if ((k as any) === false) {\n                return IDB_FALSE;\n            }\n\n            if (!exact) {\n                // We get passed CouchDB's collate low and high values, so for non-exact\n                // ranged queries we're going to convert them to our IDB equivalents\n                if (k === COUCH_COLLATE_LO) {\n                    return low;\n                } else if (Object.prototype.hasOwnProperty.call(k, COUCH_COLLATE_HI)) {\n                    return height;\n                }\n            }\n\n            return k;\n        });\n\n        /**\n         * Because we do not have to index over the deleted field,\n         * we sometimes have only one key.\n         */\n        if (ret.length === 1) {\n            return ret[0];\n        } else {\n            return ret;\n        }\n    }\n\n    // CouchDB and so PouchdB defaults to true. We need to make this explicit as\n    // we invert these later for IndexedDB.\n    if (!defined(opts, 'inclusive_end')) {\n        opts.inclusive_end = true;\n    }\n    if (!defined(opts, 'inclusive_start')) {\n        opts.inclusive_start = true;\n    }\n\n    if (opts.descending) {\n        // Flip before generating. We'll check descending again later when performing\n        // an index request\n        const realEndkey = opts.startkey,\n            realInclusiveEnd = opts.inclusive_start;\n\n        opts.startkey = opts.endkey;\n        opts.endkey = realEndkey;\n        opts.inclusive_start = opts.inclusive_end;\n        opts.inclusive_end = realInclusiveEnd;\n    }\n\n    try {\n        if (defined(opts, 'key')) {\n            return IDBKeyRange.only(convert(opts.key, true));\n        }\n\n        if (defined(opts, 'startkey') && !defined(opts, 'endkey')) {\n            return IDBKeyRange.lowerBound(convert(opts.startkey), !opts.inclusive_start);\n        }\n\n        if (!defined(opts, 'startkey') && defined(opts, 'endkey')) {\n            return IDBKeyRange.upperBound(convert(opts.endkey), !opts.inclusive_end);\n        }\n\n        if (defined(opts, 'startkey') && defined(opts, 'endkey')) {\n            return IDBKeyRange.bound(\n                convert(opts.startkey), convert(opts.endkey),\n                !opts.inclusive_start, !opts.inclusive_end\n            );\n        }\n\n        return IDBKeyRange.only([0]);\n    } catch (err) {\n        console.dir(IDBKeyRange);\n        console.error('Could not generate keyRange', err, opts);\n        throw Error('Could not generate key range with ' + JSON.stringify(opts));\n    }\n}\n"],"file":"indexeddb-find.js"}
{"version":3,"sources":["../../../../../../src/plugins/dexie/query/pouchdb-find-query-planer/query-planner.ts"],"names":["COLLATE_LO","COLLATE_HI","SHORT_CIRCUIT_QUERY","queryOpts","limit","startkey","endkey","inMemoryFields","checkFieldInIndex","index","field","indexFields","def","fields","map","getKey","i","len","length","indexField","userOperatorLosesPrecision","selector","matcher","userOperator","sortFieldsByIndex","userFields","slice","sort","a","b","aIdx","indexOf","bIdx","Number","MAX_VALUE","getBasicInMemoryFields","needToFilterInMemory","getInMemoryFieldsFromNe","Object","keys","forEach","operator","push","getInMemoryFields","coreInMemoryFields","result","flatten","checkIndexFieldsMatch","sortOrder","sortMatches","selectorMatches","logicalMatchers","isNonLogicalMatcher","checkFieldsLogicallySound","firstField","isInvalidNe","checkIndexMatches","fieldsMatch","findMatchingIndexes","indexes","filter","findBestMatchingIndex","useIndex","matchingIndexes","Error","JSON","stringify","error","message","defaultIndex","defaultUsed","userFieldsMap","scoreIndex","score","useIndexDdoc","useIndexName","find","ddoc","name","getSingleFieldQueryOptsFor","userValue","key","inclusive_end","inclusive_start","getSingleFieldCoreQueryPlan","userOperators","combinedOpts","newQueryOpts","getMultiFieldCoreQueryPlan","getMultiFieldQueryOpts","inclusiveStart","inclusiveEnd","finish","some","usingGtlt","previousKeys","previousWasEq","previousWasSame","gtltLostSpecificity","j","newOpts","res","shouldShortCircuit","values","val","getDefaultQueryPlan","_idx","getCoreQueryPlan","planQuery","request","assign","userFieldsRes","use_index","coreQueryPlan"],"mappings":"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","sourcesContent":["import {\n    getUserFields\n} from './utils';\nimport {\n    getKey,\n    compare\n} from 'pouchdb-selector-core';\nimport {\n    arrayEquals,\n    arrayToObject,\n    flatten,\n    max,\n    mergeObjects,\n    oneArrayIsStrictSubArrayOfOther,\n    oneArrayIsSubArrayOfOther,\n    oneSetIsSubArrayOfOther,\n    uniq\n} from './main-utils';\n\n// couchdb lowest collation value\nconst COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\n// const COLLATE_HI = { '\\uffff': {} };\n// overwritten COLLATE_HI for dexie.js RxStorage.\nconst COLLATE_HI = '\\uffff';\n\n\nconst SHORT_CIRCUIT_QUERY = {\n    queryOpts: { limit: 0, startkey: COLLATE_HI, endkey: COLLATE_LO },\n    inMemoryFields: [],\n};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index: any, field: string) {\n    const indexFields = index.def.fields.map(getKey);\n    for (let i = 0, len = indexFields.length; i < len; i++) {\n        const indexField = indexFields[i];\n        if (field === indexField) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector: any, field: string) {\n    const matcher = selector[field];\n    const userOperator = getKey(matcher);\n\n    return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields: any[], index: any) {\n    const indexFields = index.def.fields.map(getKey);\n\n    return userFields.slice().sort(function (a, b) {\n        let aIdx = indexFields.indexOf(a);\n        let bIdx = indexFields.indexOf(b);\n        if (aIdx === -1) {\n            aIdx = Number.MAX_VALUE;\n        }\n        if (bIdx === -1) {\n            bIdx = Number.MAX_VALUE;\n        }\n        return compare(aIdx, bIdx);\n    });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index: any, selector: any, userFields: any) {\n\n    userFields = sortFieldsByIndex(userFields, index);\n\n    // check if any of the user selectors lose precision\n    let needToFilterInMemory = false;\n    for (let i = 0, len = userFields.length; i < len; i++) {\n        const field = userFields[i];\n        if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n            return userFields.slice(i);\n        }\n        if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n            needToFilterInMemory = true;\n        }\n    }\n    return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector: any) {\n    const fields: any[] = [];\n    Object.keys(selector).forEach(function (field) {\n        const matcher = selector[field];\n        Object.keys(matcher).forEach(function (operator) {\n            if (operator === '$ne') {\n                fields.push(field);\n            }\n        });\n    });\n    return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields: any, index: any, selector: any, userFields: any) {\n    const result = (flatten as any)(\n        // in-memory fields reported as necessary by the query planner\n        coreInMemoryFields,\n        // combine with another pass that checks for any we may have missed\n        getBasicInMemoryFields(index, selector, userFields),\n        // combine with another pass that checks for $ne's\n        getInMemoryFieldsFromNe(selector)\n    );\n\n    return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields: any, sortOrder: any, fields: any) {\n    if (sortOrder) {\n        // array has to be a strict subarray of index array. furthermore,\n        // the sortOrder fields need to all be represented in the index\n        const sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n        const selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\n        return sortMatches && selectorMatches;\n    }\n\n    // all of the user's specified fields still need to be\n    // on the left side of the index array, although the order\n    // doesn't matter\n    return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nconst logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher: any) {\n    return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields: any, selector: any) {\n    const firstField = indexFields[0];\n    const matcher = selector[firstField];\n\n    if (typeof matcher === 'undefined') {\n        /* istanbul ignore next */\n        return true;\n    }\n\n    const isInvalidNe = Object.keys(matcher).length === 1 &&\n        getKey(matcher) === '$ne';\n\n    return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index: any, sortOrder: any, fields: any, selector: any) {\n\n    const indexFields = index.def.fields.map(getKey);\n\n    const fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n    if (!fieldsMatch) {\n        return false;\n    }\n\n    return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector: any, userFields: any, sortOrder: any, indexes: any) {\n    return indexes.filter(function (index: any) {\n        return checkIndexMatches(index, sortOrder, userFields, selector);\n    });\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector: any, userFields: any, sortOrder: any, indexes: any, useIndex: string) {\n\n    const matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n    if (matchingIndexes.length === 0) {\n        if (useIndex) {\n            throw new Error(JSON.stringify({\n                error: 'no_usable_index',\n                message: 'There is no index available for this selector.',\n                selector,\n                indexes,\n                sortOrder,\n                userFields,\n                useIndex\n            }, null, 4));\n        }\n        //return `all_docs` as a default index;\n        //I'm assuming that _all_docs is always first\n        const defaultIndex = indexes[0];\n        defaultIndex.defaultUsed = true;\n        return defaultIndex;\n    }\n    if (matchingIndexes.length === 1 && !useIndex) {\n        return matchingIndexes[0];\n    }\n\n    const userFieldsMap = arrayToObject(userFields);\n\n    function scoreIndex(index: any) {\n        const indexFields = index.def.fields.map(getKey);\n        let score = 0;\n        for (let i = 0, len = indexFields.length; i < len; i++) {\n            const indexField = indexFields[i];\n            if (userFieldsMap[indexField]) {\n                score++;\n            }\n        }\n        return score;\n    }\n\n    if (useIndex) {\n        const useIndexDdoc = '_design/' + useIndex;\n        const useIndexName = useIndex;\n        const index = matchingIndexes.find(function (index: any) {\n            if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n                return true;\n            }\n\n            if (index.ddoc === useIndexDdoc) {\n                /* istanbul ignore next */\n                return true;\n            }\n\n            return false;\n        });\n\n        if (!index) {\n            throw new Error(JSON.stringify({\n                error: 'unknown_error',\n                message: 'Could not find that index or could not use that index for the query',\n                useIndex,\n                indexes,\n                selector\n            }, null, 4));\n        }\n        return index;\n    }\n\n    return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator: any, userValue: any) {\n    switch (userOperator) {\n        case '$eq':\n            return { key: userValue };\n        case '$lte':\n            return { endkey: userValue };\n        case '$gte':\n            return { startkey: userValue };\n        case '$lt':\n            return {\n                endkey: userValue,\n                inclusive_end: false\n            };\n        case '$gt':\n            return {\n                startkey: userValue,\n                inclusive_start: false\n            };\n    }\n\n    return {\n        startkey: COLLATE_LO\n    };\n}\n\nfunction getSingleFieldCoreQueryPlan(selector: any, index: any) {\n    const field = getKey(index.def.fields[0]);\n    //ignoring this because the test to exercise the branch is skipped at the moment\n    /* istanbul ignore next */\n    const matcher = selector[field] || {};\n    const inMemoryFields: any[] = [];\n\n    const userOperators = Object.keys(matcher);\n\n    let combinedOpts: any;\n\n    userOperators.forEach(function (userOperator) {\n\n        if (isNonLogicalMatcher(userOperator)) {\n            inMemoryFields.push(field);\n        }\n\n        const userValue = matcher[userOperator];\n\n        const newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n        if (combinedOpts) {\n            combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n        } else {\n            combinedOpts = newQueryOpts;\n        }\n    });\n\n    return {\n        queryOpts: combinedOpts,\n        inMemoryFields: inMemoryFields\n    };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator: any, userValue: any) {\n    switch (userOperator) {\n        case '$eq':\n            return {\n                startkey: userValue,\n                endkey: userValue\n            };\n        case '$lte':\n            return {\n                endkey: userValue\n            };\n        case '$gte':\n            return {\n                startkey: userValue\n            };\n        case '$lt':\n            return {\n                endkey: userValue,\n                inclusive_end: false\n            };\n        case '$gt':\n            return {\n                startkey: userValue,\n                inclusive_start: false\n            };\n    }\n}\n\nfunction getMultiFieldQueryOpts(selector: any, index: any) {\n\n    const indexFields = index.def.fields.map(getKey);\n\n    let inMemoryFields: any[] = [];\n    const startkey = [];\n    const endkey = [];\n    let inclusiveStart: any;\n    let inclusiveEnd: any;\n\n\n    function finish(i: any) {\n\n        if (inclusiveStart !== false) {\n            startkey.push(COLLATE_LO);\n        }\n        if (inclusiveEnd !== false) {\n            endkey.push(COLLATE_HI);\n        }\n        // keep track of the fields where we lost specificity,\n        // and therefore need to filter in-memory\n        inMemoryFields = indexFields.slice(i);\n    }\n\n    for (let i = 0, len = indexFields.length; i < len; i++) {\n        const indexField = indexFields[i];\n\n        const matcher = selector[indexField];\n\n        if (!matcher || !Object.keys(matcher).length) { // fewer fields in user query than in index\n            finish(i);\n            break;\n        } else if (Object.keys(matcher).some(isNonLogicalMatcher)) { // non-logical are ignored\n            finish(i);\n            break;\n        } else if (i > 0) {\n            const usingGtlt = (\n                '$gt' in matcher || '$gte' in matcher ||\n                '$lt' in matcher || '$lte' in matcher);\n            const previousKeys = Object.keys(selector[indexFields[i - 1]]);\n            const previousWasEq = arrayEquals(previousKeys, ['$eq']);\n            const previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n            const gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n            if (gtltLostSpecificity) {\n                finish(i);\n                break;\n            }\n        }\n\n        const userOperators = Object.keys(matcher);\n\n        let combinedOpts: any = null;\n\n        for (let j = 0; j < userOperators.length; j++) {\n            const userOperator = userOperators[j];\n            const userValue = matcher[userOperator];\n\n            const newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n            if (combinedOpts) {\n                combinedOpts = mergeObjects([combinedOpts, newOpts]);\n            } else {\n                combinedOpts = newOpts;\n            }\n        }\n\n        startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n        endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n        if ('inclusive_start' in combinedOpts) {\n            inclusiveStart = combinedOpts.inclusive_start;\n        }\n        if ('inclusive_end' in combinedOpts) {\n            inclusiveEnd = combinedOpts.inclusive_end;\n        }\n    }\n\n    const res: any = {\n        startkey: startkey,\n        endkey: endkey\n    };\n\n    if (typeof inclusiveStart !== 'undefined') {\n        res.inclusive_start = inclusiveStart;\n    }\n    if (typeof inclusiveEnd !== 'undefined') {\n        res.inclusive_end = inclusiveEnd;\n    }\n\n    return {\n        queryOpts: res,\n        inMemoryFields: inMemoryFields\n    };\n}\n\nfunction shouldShortCircuit(selector: any) {\n    // We have a field to select from, but not a valid value\n    // this should result in a short circuited query \n    // just like the http adapter (couchdb) and mongodb\n    // see tests for issue #7810\n\n    const values = Object.values(selector);\n    return values.some(function (val: any) {\n        return typeof val === 'object' && Object.keys(val).length === 0;\n    });\n}\n\nfunction getDefaultQueryPlan(selector: any, _idx?: any) {\n    //using default index, so all fields need to be done in memory\n    return {\n        queryOpts: { startkey: null },\n        inMemoryFields: [Object.keys(selector)]\n    };\n}\n\nfunction getCoreQueryPlan(selector: any, index: any) {\n    if (index.defaultUsed) {\n        return getDefaultQueryPlan(selector, index);\n    }\n\n    if (index.def.fields.length === 1) {\n        // one field in index, so the value was indexed as a singleton\n        return getSingleFieldCoreQueryPlan(selector, index);\n    }\n    // else index has multiple fields, so the value was indexed as an array\n    return getMultiFieldQueryOpts(selector, index);\n}\n\nexport function planQuery(request: any, indexes: any) {\n\n    const selector = request.selector;\n    const sort = request.sort;\n\n    if (shouldShortCircuit(selector)) {\n        return Object.assign({}, SHORT_CIRCUIT_QUERY, { index: indexes[0] });\n    }\n\n    const userFieldsRes = getUserFields(selector, sort);\n\n    const userFields = userFieldsRes.fields;\n    const sortOrder = userFieldsRes.sortOrder;\n    const index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\n    const coreQueryPlan = getCoreQueryPlan(selector, index);\n    const queryOpts = coreQueryPlan.queryOpts;\n    const coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n    const inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n    const res = {\n        queryOpts: queryOpts,\n        index: index,\n        inMemoryFields: inMemoryFields\n    };\n    return res;\n}\n"],"file":"query-planner.js"}
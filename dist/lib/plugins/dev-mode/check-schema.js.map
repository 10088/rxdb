{"version":3,"file":"check-schema.js","names":["checkFieldNameRegex","fieldName","includes","newRxError","regexStr","regex","RegExp","match","validateFieldsDeep","rxJsonSchema","primaryPath","getPrimaryFieldOfPrimaryKey","primaryKey","checkField","schemaObj","path","Array","isArray","hasOwnProperty","type","required","length","items","isNested","split","primary","charAt","traverse","currentObj","currentPath","Object","keys","forEach","attributeName","properties","nextPath","checkPrimaryKey","jsonSchema","schema","validatePrimarySchemaPart","schemaPart","args","key","compositePrimaryKey","keySchemaPart","getSchemaByObjectPath","fields","field","primaryPathSchemaPart","maxLength","getSchemaPropertyRealPath","shortPath","pathParts","realPath","i","concat","trimDots","checkSchema","_rev","version","value","indexes","unique","encrypted","rxDocumentProperties","isMaybeReadonlyArray","index","indexAsArray","multipleOf","maximum","minimum","parentPath","lastPathPart","partParts","pop","join","parentSchemaPart","flattenObject","map","splitted","filter","elem","pos","arr","indexOf","objectPath","get","replace","reduce","indexPaths","currentIndex","push","indexPath","propPath"],"sources":["../../../../src/plugins/dev-mode/check-schema.ts"],"sourcesContent":["/**\n * does additional checks over the schema-json\n * to ensure nothing is broken or not supported\n */\n\nimport objectPath from 'object-path';\nimport {\n    newRxError\n} from '../../rx-error';\nimport { getPrimaryFieldOfPrimaryKey, getSchemaByObjectPath } from '../../rx-schema-helper';\nimport type {\n    CompositePrimaryKey,\n    JsonSchema,\n    JsonSchemaTypes,\n    RxJsonSchema,\n    TopLevelProperty\n} from '../../types';\nimport {\n    flattenObject, isMaybeReadonlyArray,\n    trimDots\n} from '../../util';\nimport { rxDocumentProperties } from './entity-properties';\n\n/**\n * checks if the fieldname is allowed\n * this makes sure that the fieldnames can be transformed into javascript-vars\n * and does not conquer the observe$ and populate_ fields\n * @throws {Error}\n */\nexport function checkFieldNameRegex(fieldName: string) {\n    if (fieldName === '_deleted') {\n        return;\n    }\n\n    if (['properties', 'language'].includes(fieldName)) {\n        throw newRxError('SC23', {\n            fieldName\n        });\n    }\n\n    const regexStr = '^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$';\n    const regex = new RegExp(regexStr);\n    if (\n        /**\n         * It must be allowed to set _id as primaryKey.\n         * This makes it sometimes easier to work with RxDB+CouchDB\n         * @link https://github.com/pubkey/rxdb/issues/681\n         */\n        fieldName !== '_id' &&\n        !fieldName.match(regex)\n    ) {\n        throw newRxError('SC1', {\n            regex: regexStr,\n            fieldName\n        });\n    }\n}\n\n/**\n * validate that all schema-related things are ok\n */\nexport function validateFieldsDeep(rxJsonSchema: RxJsonSchema<any>): true {\n\n    const primaryPath = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);\n\n    function checkField(\n        fieldName: string,\n        schemaObj: any,\n        path: string\n    ) {\n        if (\n            typeof fieldName === 'string' &&\n            typeof schemaObj === 'object' &&\n            !Array.isArray(schemaObj)\n        ) checkFieldNameRegex(fieldName);\n\n        // 'item' only allowed it type=='array'\n        if (schemaObj.hasOwnProperty('item') && schemaObj.type !== 'array') {\n            throw newRxError('SC2', {\n                fieldName\n            });\n        }\n\n        /**\n         * required fields cannot be set via 'required: true',\n         * but must be set via required: []\n         */\n        if (schemaObj.hasOwnProperty('required') && typeof schemaObj.required === 'boolean') {\n            throw newRxError('SC24', {\n                fieldName\n            });\n        }\n\n\n        // if ref given, must be type=='string', type=='array' with string-items or type==['string','null']\n        if (schemaObj.hasOwnProperty('ref')) {\n            if (Array.isArray(schemaObj.type)) {\n                if (schemaObj.type.length > 2 || !schemaObj.type.includes('string') || !schemaObj.type.includes('null')) {\n                    throw newRxError('SC4', {\n                        fieldName\n                    });\n                }\n            } else {\n                switch (schemaObj.type) {\n                    case 'string':\n                        break;\n                    case 'array':\n                        if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== 'string') {\n                            throw newRxError('SC3', {\n                                fieldName\n                            });\n                        }\n                        break;\n                    default:\n                        throw newRxError('SC4', {\n                            fieldName\n                        });\n                }\n            }\n        }\n\n        const isNested = path.split('.').length >= 2;\n\n        // nested only\n        if (isNested) {\n            if (schemaObj.primary) {\n                throw newRxError('SC6', {\n                    path,\n                    primary: schemaObj.primary\n                });\n            }\n\n            if (schemaObj.default) {\n                throw newRxError('SC7', {\n                    path\n                });\n            }\n        }\n\n        // first level\n        if (!isNested) {\n\n            // if _id is used, it must be primaryKey\n            if (\n                fieldName === '_id' &&\n                primaryPath !== '_id'\n            ) {\n                throw newRxError('COL2', {\n                    fieldName\n                });\n            }\n\n            // check underscore fields\n            if (fieldName.charAt(0) === '_') {\n                if (\n                    // exceptional allow underscore on these fields.\n                    fieldName === '_id' ||\n                    fieldName === '_deleted'\n                ) {\n                    return;\n                }\n                throw newRxError('SC8', {\n                    fieldName\n                });\n            }\n        }\n    }\n\n    function traverse(currentObj: any, currentPath: any) {\n        if (typeof currentObj !== 'object') return;\n        Object.keys(currentObj).forEach(attributeName => {\n            if (!currentObj.properties) {\n                checkField(\n                    attributeName,\n                    currentObj[attributeName],\n                    currentPath\n                );\n            }\n            let nextPath = currentPath;\n            if (attributeName !== 'properties') nextPath = nextPath + '.' + attributeName;\n            traverse(currentObj[attributeName], nextPath);\n        });\n    }\n    traverse(rxJsonSchema, '');\n    return true;\n}\n\nexport function checkPrimaryKey(\n    jsonSchema: RxJsonSchema<any>\n) {\n    if (!jsonSchema.primaryKey) {\n        throw newRxError('SC30', { schema: jsonSchema });\n    }\n\n\n\n    function validatePrimarySchemaPart(\n        schemaPart: JsonSchema | TopLevelProperty\n    ) {\n        if (!schemaPart) {\n            throw newRxError('SC33', { schema: jsonSchema });\n        }\n\n        const type: string = schemaPart.type as any;\n        if (\n            !type ||\n            !['string', 'number', 'integer'].includes(type)\n        ) {\n            throw newRxError('SC32', { schema: jsonSchema, args: { schemaPart } });\n        }\n    }\n\n    if (typeof jsonSchema.primaryKey === 'string') {\n        const key = jsonSchema.primaryKey;\n        const schemaPart = jsonSchema.properties[key];\n        validatePrimarySchemaPart(schemaPart);\n    } else {\n        const compositePrimaryKey: CompositePrimaryKey<any> = jsonSchema.primaryKey as any;\n\n        const keySchemaPart = getSchemaByObjectPath(jsonSchema, compositePrimaryKey.key);\n        validatePrimarySchemaPart(keySchemaPart);\n\n        compositePrimaryKey.fields.forEach(field => {\n            const schemaPart = getSchemaByObjectPath(jsonSchema, field);\n            validatePrimarySchemaPart(schemaPart);\n        });\n    }\n\n\n    /**\n     * The primary key must have a maxLength set\n     * which is required by some RxStorage implementations\n     * to ensure we can craft custom index strings.\n     */\n    const primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);\n    const primaryPathSchemaPart = jsonSchema.properties[primaryPath];\n    if (!primaryPathSchemaPart.maxLength) {\n        throw newRxError('SC39', { schema: jsonSchema, args: { primaryPathSchemaPart } });\n    }\n}\n\n/**\n * computes real path of the object path in the collection schema\n */\nfunction getSchemaPropertyRealPath(shortPath: string) {\n    const pathParts = shortPath.split('.');\n    let realPath = '';\n    for (let i = 0; i < pathParts.length; i += 1) {\n        if (pathParts[i] !== '[]') {\n            realPath = realPath.concat('.properties.'.concat(pathParts[i]));\n        } else {\n            realPath = realPath.concat('.items');\n        }\n    }\n    return trimDots(realPath);\n}\n\n/**\n * does the checking\n * @throws {Error} if something is not ok\n */\nexport function checkSchema(jsonSchema: RxJsonSchema<any>) {\n\n    if (!jsonSchema.primaryKey) {\n        throw newRxError('SC30', {\n            schema: jsonSchema\n        });\n    }\n\n    if (!jsonSchema.hasOwnProperty('properties')) {\n        throw newRxError('SC29', {\n            schema: jsonSchema\n        });\n    }\n\n    // _rev MUST NOT exist, it is added by RxDB\n    if (jsonSchema.properties._rev) {\n        throw newRxError('SC10', {\n            schema: jsonSchema\n        });\n    }\n\n    // check version\n    if (!jsonSchema.hasOwnProperty('version') ||\n        typeof jsonSchema.version !== 'number' ||\n        jsonSchema.version < 0\n    ) {\n        throw newRxError('SC11', {\n            version: jsonSchema.version\n        });\n    }\n\n    validateFieldsDeep(jsonSchema);\n    checkPrimaryKey(jsonSchema);\n\n    Object.keys(jsonSchema.properties).forEach(key => {\n        const value: any = jsonSchema.properties[key];\n        // check primary\n        if (key === jsonSchema.primaryKey) {\n            if (jsonSchema.indexes && jsonSchema.indexes.includes(key)) {\n                throw newRxError('SC13', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n            if (value.unique) {\n                throw newRxError('SC14', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n            if (jsonSchema.encrypted && jsonSchema.encrypted.includes(key)) {\n                throw newRxError('SC15', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n            if (value.type !== 'string') {\n                throw newRxError('SC16', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n        }\n\n        // check if RxDocument-property\n        if (rxDocumentProperties().includes(key)) {\n            throw newRxError('SC17', {\n                key,\n                schema: jsonSchema\n            });\n        }\n    });\n\n    // check format of jsonSchema.indexes\n    if (jsonSchema.indexes) {\n        // should be an array\n        if (!isMaybeReadonlyArray(jsonSchema.indexes)) {\n            throw newRxError('SC18', {\n                indexes: jsonSchema.indexes,\n                schema: jsonSchema\n            });\n        }\n\n        jsonSchema.indexes.forEach(index => {\n            // should contain strings or array of strings\n            if (!(typeof index === 'string' || Array.isArray(index))) {\n                throw newRxError('SC19', { index, schema: jsonSchema });\n            }\n            // if is a compound index it must contain strings\n            if (Array.isArray(index)) {\n                for (let i = 0; i < index.length; i += 1) {\n                    if (typeof index[i] !== 'string') {\n                        throw newRxError('SC20', { index, schema: jsonSchema });\n                    }\n                }\n            }\n\n            /**\n             * To be able to craft custom indexable string with compound fields,\n             * we need to know the maximum fieldlength of the fields values\n             * when they are transformed to strings.\n             * Therefore we need to enforce some properties inside of the schema.\n             */\n            const indexAsArray = isMaybeReadonlyArray(index) ? index : [index];\n            indexAsArray.forEach(fieldName => {\n                const schemaPart = getSchemaByObjectPath(\n                    jsonSchema,\n                    fieldName\n                );\n\n\n                const type: JsonSchemaTypes = schemaPart.type as any;\n                switch (type) {\n                    case 'string':\n                        const maxLength = schemaPart.maxLength;\n                        if (!maxLength) {\n                            throw newRxError('SC34', {\n                                index,\n                                field: fieldName,\n                                schema: jsonSchema\n                            });\n                        }\n                        break;\n                    case 'number':\n                    case 'integer':\n                        const multipleOf = schemaPart.multipleOf;\n                        if (!multipleOf) {\n                            throw newRxError('SC35', {\n                                index,\n                                field: fieldName,\n                                schema: jsonSchema\n                            });\n                        }\n                        const maximum = schemaPart.maximum;\n                        const minimum = schemaPart.minimum;\n                        if (\n                            typeof maximum === 'undefined' ||\n                            typeof minimum === 'undefined'\n                        ) {\n                            throw newRxError('SC37', {\n                                index,\n                                field: fieldName,\n                                schema: jsonSchema\n                            });\n                        }\n                        break;\n                    case 'boolean':\n                        /**\n                         * If a boolean field is used as an index,\n                         * it must be required.\n                         */\n                        let parentPath = '';\n                        let lastPathPart = fieldName;\n                        if (fieldName.includes('.')) {\n                            const partParts = fieldName.split('.');\n                            lastPathPart = partParts.pop();\n                            parentPath = partParts.join('.');\n                        }\n                        const parentSchemaPart = parentPath === '' ? jsonSchema : getSchemaByObjectPath(\n                            jsonSchema,\n                            parentPath\n                        );\n\n                        if (\n                            !parentSchemaPart.required ||\n                            !parentSchemaPart.required.includes(lastPathPart)\n                        ) {\n                            throw newRxError('SC38', {\n                                index,\n                                field: fieldName,\n                                schema: jsonSchema\n                            });\n                        }\n                        break;\n\n                    default:\n                        throw newRxError('SC36', {\n                            fieldName,\n                            type: schemaPart.type as any,\n                            schema: jsonSchema,\n                        });\n                }\n            });\n\n        });\n    }\n\n    // remove backward-compatibility for index: true\n    Object.keys(flattenObject(jsonSchema))\n        .map(key => {\n            // flattenObject returns only ending paths, we need all paths pointing to an object\n            const splitted = key.split('.');\n            splitted.pop(); // all but last\n            return splitted.join('.');\n        })\n        .filter(key => key !== '')\n        .filter((elem, pos, arr) => arr.indexOf(elem) === pos) // unique\n        .filter(key => { // check if this path defines an index\n            const value = objectPath.get(jsonSchema, key);\n            return !!value.index;\n        })\n        .forEach(key => { // replace inner properties\n            key = key.replace('properties.', ''); // first\n            key = key.replace(/\\.properties\\./g, '.'); // middle\n            throw newRxError('SC26', {\n                index: trimDots(key),\n                schema: jsonSchema\n            });\n        });\n\n    /* check types of the indexes */\n    (jsonSchema.indexes || [])\n        .reduce((indexPaths: string[], currentIndex) => {\n            if (isMaybeReadonlyArray(currentIndex)) {\n                indexPaths.concat(currentIndex);\n            } else {\n                indexPaths.push(currentIndex);\n            }\n            return indexPaths;\n        }, [])\n        .filter((elem, pos, arr) => arr.indexOf(elem) === pos) // from now on working only with unique indexes\n        .map(indexPath => {\n            const realPath = getSchemaPropertyRealPath(indexPath); // real path in the collection schema\n            const schemaObj = objectPath.get(jsonSchema, realPath); // get the schema of the indexed property\n            if (!schemaObj || typeof schemaObj !== 'object') {\n                throw newRxError('SC21', {\n                    index: indexPath,\n                    schema: jsonSchema\n                });\n            }\n            return { indexPath, schemaObj };\n        })\n        .filter(index =>\n            index.schemaObj.type !== 'string' &&\n            index.schemaObj.type !== 'integer' &&\n            index.schemaObj.type !== 'number' &&\n            index.schemaObj.type !== 'boolean'\n        )\n        .forEach(index => {\n            throw newRxError('SC22', {\n                key: index.indexPath,\n                type: index.schemaObj.type,\n                schema: jsonSchema\n            });\n        });\n\n\n    /**\n     * TODO\n     * in 9.0.0 we changed the way encrypted fields are defined\n     * This check ensures people do not oversee the breaking change\n     * Remove this check in the future\n     */\n    Object.keys(flattenObject(jsonSchema))\n        .map(key => {\n            // flattenObject returns only ending paths, we need all paths pointing to an object\n            const splitted = key.split('.');\n            splitted.pop(); // all but last\n            return splitted.join('.');\n        })\n        .filter(key => key !== '' && key !== 'attachments')\n        .filter((elem, pos, arr) => arr.indexOf(elem) === pos) // unique\n        .filter(key => {\n            // check if this path defines an encrypted field\n            const value = objectPath.get(jsonSchema, key);\n            return !!value.encrypted;\n        })\n        .forEach(key => { // replace inner properties\n            key = key.replace('properties.', ''); // first\n            key = key.replace(/\\.properties\\./g, '.'); // middle\n            throw newRxError('SC27', {\n                index: trimDots(key),\n                schema: jsonSchema\n            });\n        });\n\n    /* ensure encrypted fields exist in the schema */\n    if (jsonSchema.encrypted) {\n        jsonSchema.encrypted\n            .forEach(propPath => {\n                // real path in the collection schema\n                const realPath = getSchemaPropertyRealPath(propPath);\n                // get the schema of the indexed property\n                const schemaObj = objectPath.get(jsonSchema, realPath);\n                if (!schemaObj || typeof schemaObj !== 'object') {\n                    throw newRxError('SC28', {\n                        field: propPath,\n                        schema: jsonSchema\n                    });\n                }\n            });\n    }\n}\n"],"mappings":"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"}
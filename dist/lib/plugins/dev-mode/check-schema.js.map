{"version":3,"sources":["../../../../src/plugins/dev-mode/check-schema.ts"],"names":["checkFieldNameRegex","fieldName","includes","regexStr","regex","RegExp","match","validateFieldsDeep","jsonSchema","checkField","schemaObj","path","Array","isArray","hasOwnProperty","type","required","length","items","isNested","split","primary","charAt","traverse","currentObj","currentPath","Object","keys","forEach","attributeName","properties","nextPath","checkPrimaryKey","primaryKey","schema","validatePrimarySchemaPart","schemaPart","args","key","compositePrimaryKey","keySchemaPart","fields","field","getSchemaPropertyRealPath","shortPath","pathParts","realPath","i","concat","checkSchema","_rev","version","value","indexes","unique","encrypted","index","map","splitted","pop","join","filter","elem","pos","arr","indexOf","objectPath","get","replace","reduce","indexPaths","currentIndex","push","indexPath","propPath"],"mappings":";;;;;;;;;;;;AAKA;;AACA;;AAGA;;AAOA;;AAIA;;AApBA;AACA;AACA;AACA;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,mBAAT,CAA6BC,SAA7B,EAAgD;AACnD,MAAIA,SAAS,KAAK,EAAlB,EAAsB,OAD6B,CACrB;;AAC9B,MAAIA,SAAS,KAAK,UAAlB,EAA8B;;AAE9B,MAAI,CAAC,YAAD,EAAe,UAAf,EAA2BC,QAA3B,CAAoCD,SAApC,CAAJ,EAAoD;AAChD,UAAM,yBAAW,MAAX,EAAmB;AACrBA,MAAAA,SAAS,EAATA;AADqB,KAAnB,CAAN;AAGH;;AAED,MAAME,QAAQ,GAAG,4CAAjB;AACA,MAAMC,KAAK,GAAG,IAAIC,MAAJ,CAAWF,QAAX,CAAd;;AACA,MAAI,CAACF,SAAS,CAACK,KAAV,CAAgBF,KAAhB,CAAL,EAA6B;AACzB,UAAM,yBAAW,KAAX,EAAkB;AACpBA,MAAAA,KAAK,EAAED,QADa;AAEpBF,MAAAA,SAAS,EAATA;AAFoB,KAAlB,CAAN;AAIH;AACJ;AAED;AACA;AACA;;;AACO,SAASM,kBAAT,CAA4BC,UAA5B,EAAmD;AACtD,WAASC,UAAT,CACIR,SADJ,EAEIS,SAFJ,EAGIC,IAHJ,EAIE;AACE,QACI,OAAOV,SAAP,KAAqB,QAArB,IACA,OAAOS,SAAP,KAAqB,QADrB,IAEA,CAACE,KAAK,CAACC,OAAN,CAAcH,SAAd,CAHL,EAIEV,mBAAmB,CAACC,SAAD,CAAnB,CALJ,CAOE;;AACA,QAAIS,SAAS,CAACI,cAAV,CAAyB,MAAzB,KAAoCJ,SAAS,CAACK,IAAV,KAAmB,OAA3D,EAAoE;AAChE,YAAM,yBAAW,KAAX,EAAkB;AACpBd,QAAAA,SAAS,EAATA;AADoB,OAAlB,CAAN;AAGH;AAED;AACR;AACA;AACA;;;AACQ,QAAIS,SAAS,CAACI,cAAV,CAAyB,UAAzB,KAAwC,OAAOJ,SAAS,CAACM,QAAjB,KAA8B,SAA1E,EAAqF;AACjF,YAAM,yBAAW,MAAX,EAAmB;AACrBf,QAAAA,SAAS,EAATA;AADqB,OAAnB,CAAN;AAGH,KAtBH,CAyBE;;;AACA,QAAIS,SAAS,CAACI,cAAV,CAAyB,KAAzB,CAAJ,EAAqC;AACjC,UAAIF,KAAK,CAACC,OAAN,CAAcH,SAAS,CAACK,IAAxB,CAAJ,EAAmC;AAC/B,YAAIL,SAAS,CAACK,IAAV,CAAeE,MAAf,GAAwB,CAAxB,IAA6B,CAACP,SAAS,CAACK,IAAV,CAAeb,QAAf,CAAwB,QAAxB,CAA9B,IAAmE,CAACQ,SAAS,CAACK,IAAV,CAAeb,QAAf,CAAwB,MAAxB,CAAxE,EAAyG;AACrG,gBAAM,yBAAW,KAAX,EAAkB;AACpBD,YAAAA,SAAS,EAATA;AADoB,WAAlB,CAAN;AAGH;AACJ,OAND,MAMO;AACH,gBAAQS,SAAS,CAACK,IAAlB;AACI,eAAK,QAAL;AACI;;AACJ,eAAK,OAAL;AACI,gBAAI,CAACL,SAAS,CAACQ,KAAX,IAAoB,CAACR,SAAS,CAACQ,KAAV,CAAgBH,IAArC,IAA6CL,SAAS,CAACQ,KAAV,CAAgBH,IAAhB,KAAyB,QAA1E,EAAoF;AAChF,oBAAM,yBAAW,KAAX,EAAkB;AACpBd,gBAAAA,SAAS,EAATA;AADoB,eAAlB,CAAN;AAGH;;AACD;;AACJ;AACI,kBAAM,yBAAW,KAAX,EAAkB;AACpBA,cAAAA,SAAS,EAATA;AADoB,aAAlB,CAAN;AAXR;AAeH;AACJ;;AAED,QAAMkB,QAAQ,GAAGR,IAAI,CAACS,KAAL,CAAW,GAAX,EAAgBH,MAAhB,IAA0B,CAA3C,CApDF,CAsDE;;AACA,QAAIE,QAAJ,EAAc;AACV,UAAIT,SAAS,CAACW,OAAd,EAAuB;AACnB,cAAM,yBAAW,KAAX,EAAkB;AACpBV,UAAAA,IAAI,EAAJA,IADoB;AAEpBU,UAAAA,OAAO,EAAEX,SAAS,CAACW;AAFC,SAAlB,CAAN;AAIH;;AAED,UAAIX,SAAS,WAAb,EAAuB;AACnB,cAAM,yBAAW,KAAX,EAAkB;AACpBC,UAAAA,IAAI,EAAJA;AADoB,SAAlB,CAAN;AAGH;AACJ,KApEH,CAsEE;;;AACA,QAAI,CAACQ,QAAL,EAAe;AACX;AACA,UAAIlB,SAAS,CAACqB,MAAV,CAAiB,CAAjB,MAAwB,GAA5B,EAAiC;AAC7B,YAAIrB,SAAS,KAAK,UAAlB,EAA8B;AAC1B;AACH;;AACD,cAAM,yBAAW,KAAX,EAAkB;AACpBA,UAAAA,SAAS,EAATA;AADoB,SAAlB,CAAN;AAGH;AACJ;AACJ;;AAED,WAASsB,QAAT,CAAkBC,UAAlB,EAAmCC,WAAnC,EAAqD;AACjD,QAAI,OAAOD,UAAP,KAAsB,QAA1B,EAAoC;AACpCE,IAAAA,MAAM,CAACC,IAAP,CAAYH,UAAZ,EAAwBI,OAAxB,CAAgC,UAAAC,aAAa,EAAI;AAC7C,UAAI,CAACL,UAAU,CAACM,UAAhB,EAA4B;AACxBrB,QAAAA,UAAU,CACNoB,aADM,EAENL,UAAU,CAACK,aAAD,CAFJ,EAGNJ,WAHM,CAAV;AAKH;;AACD,UAAIM,QAAQ,GAAGN,WAAf;AACA,UAAII,aAAa,KAAK,YAAtB,EAAoCE,QAAQ,GAAGA,QAAQ,GAAG,GAAX,GAAiBF,aAA5B;AACpCN,MAAAA,QAAQ,CAACC,UAAU,CAACK,aAAD,CAAX,EAA4BE,QAA5B,CAAR;AACH,KAXD;AAYH;;AACDR,EAAAA,QAAQ,CAACf,UAAD,EAAa,EAAb,CAAR;AACA,SAAO,IAAP;AACH;;AAEM,SAASwB,eAAT,CACHxB,UADG,EAEL;AACE,MAAI,CAACA,UAAU,CAACyB,UAAhB,EAA4B;AACxB,UAAM,yBAAW,MAAX,EAAmB;AAAEC,MAAAA,MAAM,EAAE1B;AAAV,KAAnB,CAAN;AACH;;AAED,WAAS2B,yBAAT,CACIC,UADJ,EAEE;AACE,QAAI,CAACA,UAAL,EAAiB;AACb,YAAM,yBAAW,MAAX,EAAmB;AAAEF,QAAAA,MAAM,EAAE1B;AAAV,OAAnB,CAAN;AACH;;AAED,QAAMO,IAAY,GAAGqB,UAAU,CAACrB,IAAhC;;AACA,QACI,CAACA,IAAD,IACA,CAAC,CAAC,QAAD,EAAW,QAAX,EAAqB,SAArB,EAAgCb,QAAhC,CAAyCa,IAAzC,CAFL,EAGE;AACE,YAAM,yBAAW,MAAX,EAAmB;AAAEmB,QAAAA,MAAM,EAAE1B,UAAV;AAAsB6B,QAAAA,IAAI,EAAE;AAAED,UAAAA,UAAU,EAAVA;AAAF;AAA5B,OAAnB,CAAN;AACH;AACJ;;AAED,MAAI,OAAO5B,UAAU,CAACyB,UAAlB,KAAiC,QAArC,EAA+C;AAC3C,QAAMK,GAAG,GAAG9B,UAAU,CAACyB,UAAvB;AACA,QAAMG,UAAU,GAAG5B,UAAU,CAACsB,UAAX,CAAsBQ,GAAtB,CAAnB;AACAH,IAAAA,yBAAyB,CAACC,UAAD,CAAzB;AACH,GAJD,MAIO;AACH,QAAMG,mBAA6C,GAAG/B,UAAU,CAACyB,UAAjE;AAEA,QAAMO,aAAa,GAAG,2CAAsBhC,UAAtB,EAAkC+B,mBAAmB,CAACD,GAAtD,CAAtB;AACAH,IAAAA,yBAAyB,CAACK,aAAD,CAAzB;AAEAD,IAAAA,mBAAmB,CAACE,MAApB,CAA2Bb,OAA3B,CAAmC,UAAAc,KAAK,EAAI;AACxC,UAAMN,UAAU,GAAG,2CAAsB5B,UAAtB,EAAkCkC,KAAlC,CAAnB;AACAP,MAAAA,yBAAyB,CAACC,UAAD,CAAzB;AACH,KAHD;AAIH;AACJ;AAED;AACA;AACA;;;AACA,SAASO,yBAAT,CAAmCC,SAAnC,EAAsD;AAClD,MAAMC,SAAS,GAAGD,SAAS,CAACxB,KAAV,CAAgB,GAAhB,CAAlB;AACA,MAAI0B,QAAQ,GAAG,EAAf;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAS,CAAC5B,MAA9B,EAAsC8B,CAAC,IAAI,CAA3C,EAA8C;AAC1C,QAAIF,SAAS,CAACE,CAAD,CAAT,KAAiB,IAArB,EAA2B;AACvBD,MAAAA,QAAQ,GAAGA,QAAQ,CAACE,MAAT,CAAgB,eAAeA,MAAf,CAAsBH,SAAS,CAACE,CAAD,CAA/B,CAAhB,CAAX;AACH,KAFD,MAEO;AACHD,MAAAA,QAAQ,GAAGA,QAAQ,CAACE,MAAT,CAAgB,QAAhB,CAAX;AACH;AACJ;;AACD,SAAO,oBAASF,QAAT,CAAP;AACH;AAED;AACA;AACA;AACA;;;AACO,SAASG,WAAT,CAAqBzC,UAArB,EAAoD;AAEvD,MAAI,CAACA,UAAU,CAACyB,UAAhB,EAA4B;AACxB,UAAM,yBAAW,MAAX,EAAmB;AACrBC,MAAAA,MAAM,EAAE1B;AADa,KAAnB,CAAN;AAGH;;AAED,MAAI,CAACA,UAAU,CAACM,cAAX,CAA0B,YAA1B,CAAL,EAA8C;AAC1C,UAAM,yBAAW,MAAX,EAAmB;AACrBoB,MAAAA,MAAM,EAAE1B;AADa,KAAnB,CAAN;AAGH,GAZsD,CAcvD;;;AACA,MAAIA,UAAU,CAACsB,UAAX,CAAsBoB,IAA1B,EAAgC;AAC5B,UAAM,yBAAW,MAAX,EAAmB;AACrBhB,MAAAA,MAAM,EAAE1B;AADa,KAAnB,CAAN;AAGH,GAnBsD,CAqBvD;;;AACA,MAAI,CAACA,UAAU,CAACM,cAAX,CAA0B,SAA1B,CAAD,IACA,OAAON,UAAU,CAAC2C,OAAlB,KAA8B,QAD9B,IAEA3C,UAAU,CAAC2C,OAAX,GAAqB,CAFzB,EAGE;AACE,UAAM,yBAAW,MAAX,EAAmB;AACrBA,MAAAA,OAAO,EAAE3C,UAAU,CAAC2C;AADC,KAAnB,CAAN;AAGH;;AAED5C,EAAAA,kBAAkB,CAACC,UAAD,CAAlB;AACAwB,EAAAA,eAAe,CAACxB,UAAD,CAAf;AAEAkB,EAAAA,MAAM,CAACC,IAAP,CAAYnB,UAAU,CAACsB,UAAvB,EAAmCF,OAAnC,CAA2C,UAAAU,GAAG,EAAI;AAC9C,QAAMc,KAAU,GAAG5C,UAAU,CAACsB,UAAX,CAAsBQ,GAAtB,CAAnB,CAD8C,CAE9C;;AACA,QAAIA,GAAG,KAAK9B,UAAU,CAACyB,UAAvB,EAAmC;AAC/B,UAAIzB,UAAU,CAAC6C,OAAX,IAAsB7C,UAAU,CAAC6C,OAAX,CAAmBnD,QAAnB,CAA4BoC,GAA5B,CAA1B,EAA4D;AACxD,cAAM,yBAAW,MAAX,EAAmB;AACrBc,UAAAA,KAAK,EAALA,KADqB;AAErBlB,UAAAA,MAAM,EAAE1B;AAFa,SAAnB,CAAN;AAIH;;AACD,UAAI4C,KAAK,CAACE,MAAV,EAAkB;AACd,cAAM,yBAAW,MAAX,EAAmB;AACrBF,UAAAA,KAAK,EAALA,KADqB;AAErBlB,UAAAA,MAAM,EAAE1B;AAFa,SAAnB,CAAN;AAIH;;AACD,UAAIA,UAAU,CAAC+C,SAAX,IAAwB/C,UAAU,CAAC+C,SAAX,CAAqBrD,QAArB,CAA8BoC,GAA9B,CAA5B,EAAgE;AAC5D,cAAM,yBAAW,MAAX,EAAmB;AACrBc,UAAAA,KAAK,EAALA,KADqB;AAErBlB,UAAAA,MAAM,EAAE1B;AAFa,SAAnB,CAAN;AAIH;;AACD,UAAI4C,KAAK,CAACrC,IAAN,KAAe,QAAnB,EAA6B;AACzB,cAAM,yBAAW,MAAX,EAAmB;AACrBqC,UAAAA,KAAK,EAALA,KADqB;AAErBlB,UAAAA,MAAM,EAAE1B;AAFa,SAAnB,CAAN;AAIH;AACJ,KA5B6C,CA8B9C;;;AACA,QAAI,8CAAuBN,QAAvB,CAAgCoC,GAAhC,CAAJ,EAA0C;AACtC,YAAM,yBAAW,MAAX,EAAmB;AACrBA,QAAAA,GAAG,EAAHA,GADqB;AAErBJ,QAAAA,MAAM,EAAE1B;AAFa,OAAnB,CAAN;AAIH;AACJ,GArCD,EAlCuD,CAyEvD;;AACA,MAAIA,UAAU,CAAC6C,OAAf,EAAwB;AACpB;AACA,QAAI,CAACzC,KAAK,CAACC,OAAN,CAAcL,UAAU,CAAC6C,OAAzB,CAAL,EAAwC;AACpC,YAAM,yBAAW,MAAX,EAAmB;AACrBA,QAAAA,OAAO,EAAE7C,UAAU,CAAC6C,OADC;AAErBnB,QAAAA,MAAM,EAAE1B;AAFa,OAAnB,CAAN;AAIH;;AAEDA,IAAAA,UAAU,CAAC6C,OAAX,CAAmBzB,OAAnB,CAA2B,UAAA4B,KAAK,EAAI;AAChC;AACA,UAAI,EAAE,OAAOA,KAAP,KAAiB,QAAjB,IAA6B5C,KAAK,CAACC,OAAN,CAAc2C,KAAd,CAA/B,CAAJ,EAA0D;AACtD,cAAM,yBAAW,MAAX,EAAmB;AAAEA,UAAAA,KAAK,EAALA,KAAF;AAAStB,UAAAA,MAAM,EAAE1B;AAAjB,SAAnB,CAAN;AACH,OAJ+B,CAKhC;;;AACA,UAAII,KAAK,CAACC,OAAN,CAAc2C,KAAd,CAAJ,EAA0B;AACtB,aAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,KAAK,CAACvC,MAA1B,EAAkC8B,CAAC,IAAI,CAAvC,EAA0C;AACtC,cAAI,OAAOS,KAAK,CAACT,CAAD,CAAZ,KAAoB,QAAxB,EAAkC;AAC9B,kBAAM,yBAAW,MAAX,EAAmB;AAAES,cAAAA,KAAK,EAALA,KAAF;AAAStB,cAAAA,MAAM,EAAE1B;AAAjB,aAAnB,CAAN;AACH;AACJ;AACJ;AACJ,KAbD;AAcH;AAED;AACJ;AACA;AACA;AACI;;;AACA,MAAIkB,MAAM,CAACC,IAAP,CAAYnB,UAAZ,EAAwBN,QAAxB,CAAiC,iBAAjC,CAAJ,EAAyD;AACrD,UAAM,yBAAW,MAAX,EAAmB;AAAEgC,MAAAA,MAAM,EAAE1B;AAAV,KAAnB,CAAN;AACH,GA1GsD,CA4GvD;;;AACAkB,EAAAA,MAAM,CAACC,IAAP,CAAY,yBAAcnB,UAAd,CAAZ,EACKiD,GADL,CACS,UAAAnB,GAAG,EAAI;AACR;AACA,QAAMoB,QAAQ,GAAGpB,GAAG,CAAClB,KAAJ,CAAU,GAAV,CAAjB;AACAsC,IAAAA,QAAQ,CAACC,GAAT,GAHQ,CAGQ;;AAChB,WAAOD,QAAQ,CAACE,IAAT,CAAc,GAAd,CAAP;AACH,GANL,EAOKC,MAPL,CAOY,UAAAvB,GAAG;AAAA,WAAIA,GAAG,KAAK,EAAZ;AAAA,GAPf,EAQKuB,MARL,CAQY,UAACC,IAAD,EAAOC,GAAP,EAAYC,GAAZ;AAAA,WAAoBA,GAAG,CAACC,OAAJ,CAAYH,IAAZ,MAAsBC,GAA1C;AAAA,GARZ,EAQ2D;AAR3D,GASKF,MATL,CASY,UAAAvB,GAAG,EAAI;AAAE;AACb,QAAMc,KAAK,GAAGc,uBAAWC,GAAX,CAAe3D,UAAf,EAA2B8B,GAA3B,CAAd;;AACA,WAAO,CAAC,CAACc,KAAK,CAACI,KAAf;AACH,GAZL,EAaK5B,OAbL,CAaa,UAAAU,GAAG,EAAI;AAAE;AACdA,IAAAA,GAAG,GAAGA,GAAG,CAAC8B,OAAJ,CAAY,aAAZ,EAA2B,EAA3B,CAAN,CADY,CAC0B;;AACtC9B,IAAAA,GAAG,GAAGA,GAAG,CAAC8B,OAAJ,CAAY,iBAAZ,EAA+B,GAA/B,CAAN,CAFY,CAE+B;;AAC3C,UAAM,yBAAW,MAAX,EAAmB;AACrBZ,MAAAA,KAAK,EAAE,oBAASlB,GAAT,CADc;AAErBJ,MAAAA,MAAM,EAAE1B;AAFa,KAAnB,CAAN;AAIH,GApBL;AAsBA;;AACA,GAACA,UAAU,CAAC6C,OAAX,IAAsB,EAAvB,EACKgB,MADL,CACY,UAACC,UAAD,EAAuBC,YAAvB,EAAwC;AAC5C,QAAI3D,KAAK,CAACC,OAAN,CAAc0D,YAAd,CAAJ,EAAiC;AAC7BD,MAAAA,UAAU,CAACtB,MAAX,CAAkBuB,YAAlB;AACH,KAFD,MAEO;AACHD,MAAAA,UAAU,CAACE,IAAX,CAAgBD,YAAhB;AACH;;AACD,WAAOD,UAAP;AACH,GARL,EAQO,EARP,EASKT,MATL,CASY,UAACC,IAAD,EAAOC,GAAP,EAAYC,GAAZ;AAAA,WAAoBA,GAAG,CAACC,OAAJ,CAAYH,IAAZ,MAAsBC,GAA1C;AAAA,GATZ,EAS2D;AAT3D,GAUKN,GAVL,CAUS,UAAAgB,SAAS,EAAI;AACd,QAAM3B,QAAQ,GAAGH,yBAAyB,CAAC8B,SAAD,CAA1C,CADc,CACyC;;AACvD,QAAM/D,SAAS,GAAGwD,uBAAWC,GAAX,CAAe3D,UAAf,EAA2BsC,QAA3B,CAAlB,CAFc,CAE0C;;;AACxD,QAAI,CAACpC,SAAD,IAAc,OAAOA,SAAP,KAAqB,QAAvC,EAAiD;AAC7C,YAAM,yBAAW,MAAX,EAAmB;AACrB8C,QAAAA,KAAK,EAAEiB,SADc;AAErBvC,QAAAA,MAAM,EAAE1B;AAFa,OAAnB,CAAN;AAIH;;AACD,WAAO;AAAEiE,MAAAA,SAAS,EAATA,SAAF;AAAa/D,MAAAA,SAAS,EAATA;AAAb,KAAP;AACH,GApBL,EAqBKmD,MArBL,CAqBY,UAAAL,KAAK;AAAA,WACTA,KAAK,CAAC9C,SAAN,CAAgBK,IAAhB,KAAyB,QAAzB,IACAyC,KAAK,CAAC9C,SAAN,CAAgBK,IAAhB,KAAyB,SADzB,IAEAyC,KAAK,CAAC9C,SAAN,CAAgBK,IAAhB,KAAyB,QAHhB;AAAA,GArBjB,EA0BKa,OA1BL,CA0Ba,UAAA4B,KAAK,EAAI;AACd,UAAM,yBAAW,MAAX,EAAmB;AACrBlB,MAAAA,GAAG,EAAEkB,KAAK,CAACiB,SADU;AAErB1D,MAAAA,IAAI,EAAEyC,KAAK,CAAC9C,SAAN,CAAgBK,IAFD;AAGrBmB,MAAAA,MAAM,EAAE1B;AAHa,KAAnB,CAAN;AAKH,GAhCL;AAmCA;AACJ;AACA;AACA;AACA;AACA;;AACIkB,EAAAA,MAAM,CAACC,IAAP,CAAY,yBAAcnB,UAAd,CAAZ,EACKiD,GADL,CACS,UAAAnB,GAAG,EAAI;AACR;AACA,QAAMoB,QAAQ,GAAGpB,GAAG,CAAClB,KAAJ,CAAU,GAAV,CAAjB;AACAsC,IAAAA,QAAQ,CAACC,GAAT,GAHQ,CAGQ;;AAChB,WAAOD,QAAQ,CAACE,IAAT,CAAc,GAAd,CAAP;AACH,GANL,EAOKC,MAPL,CAOY,UAAAvB,GAAG;AAAA,WAAIA,GAAG,KAAK,EAAR,IAAcA,GAAG,KAAK,aAA1B;AAAA,GAPf,EAQKuB,MARL,CAQY,UAACC,IAAD,EAAOC,GAAP,EAAYC,GAAZ;AAAA,WAAoBA,GAAG,CAACC,OAAJ,CAAYH,IAAZ,MAAsBC,GAA1C;AAAA,GARZ,EAQ2D;AAR3D,GASKF,MATL,CASY,UAAAvB,GAAG,EAAI;AACX;AACA,QAAMc,KAAK,GAAGc,uBAAWC,GAAX,CAAe3D,UAAf,EAA2B8B,GAA3B,CAAd;;AACA,WAAO,CAAC,CAACc,KAAK,CAACG,SAAf;AACH,GAbL,EAcK3B,OAdL,CAca,UAAAU,GAAG,EAAI;AAAE;AACdA,IAAAA,GAAG,GAAGA,GAAG,CAAC8B,OAAJ,CAAY,aAAZ,EAA2B,EAA3B,CAAN,CADY,CAC0B;;AACtC9B,IAAAA,GAAG,GAAGA,GAAG,CAAC8B,OAAJ,CAAY,iBAAZ,EAA+B,GAA/B,CAAN,CAFY,CAE+B;;AAC3C,UAAM,yBAAW,MAAX,EAAmB;AACrBZ,MAAAA,KAAK,EAAE,oBAASlB,GAAT,CADc;AAErBJ,MAAAA,MAAM,EAAE1B;AAFa,KAAnB,CAAN;AAIH,GArBL;AAuBA;;AACA,MAAIA,UAAU,CAAC+C,SAAf,EAA0B;AACtB/C,IAAAA,UAAU,CAAC+C,SAAX,CACK3B,OADL,CACa,UAAA8C,QAAQ,EAAI;AACjB;AACA,UAAM5B,QAAQ,GAAGH,yBAAyB,CAAC+B,QAAD,CAA1C,CAFiB,CAGjB;;AACA,UAAMhE,SAAS,GAAGwD,uBAAWC,GAAX,CAAe3D,UAAf,EAA2BsC,QAA3B,CAAlB;;AACA,UAAI,CAACpC,SAAD,IAAc,OAAOA,SAAP,KAAqB,QAAvC,EAAiD;AAC7C,cAAM,yBAAW,MAAX,EAAmB;AACrBgC,UAAAA,KAAK,EAAEgC,QADc;AAErBxC,UAAAA,MAAM,EAAE1B;AAFa,SAAnB,CAAN;AAIH;AACJ,KAZL;AAaH;AACJ","sourcesContent":["/**\n * does additional checks over the schema-json\n * to ensure nothing is broken or not supported\n */\n\nimport objectPath from 'object-path';\nimport {\n    newRxError\n} from '../../rx-error';\nimport { getSchemaByObjectPath } from '../../rx-schema-helper';\nimport type {\n    CompositePrimaryKey,\n    JsonSchema,\n    RxJsonSchema,\n    TopLevelProperty\n} from '../../types';\nimport {\n    flattenObject,\n    trimDots\n} from '../../util';\nimport { rxDocumentProperties } from './entity-properties';\n\n/**\n * checks if the fieldname is allowed\n * this makes sure that the fieldnames can be transformed into javascript-vars\n * and does not conquer the observe$ and populate_ fields\n * @throws {Error}\n */\nexport function checkFieldNameRegex(fieldName: string) {\n    if (fieldName === '') return; // TODO why is the fieldname allowed to be empty string?\n    if (fieldName === '_deleted') return;\n\n    if (['properties', 'language'].includes(fieldName)) {\n        throw newRxError('SC23', {\n            fieldName\n        });\n    }\n\n    const regexStr = '^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$';\n    const regex = new RegExp(regexStr);\n    if (!fieldName.match(regex)) {\n        throw newRxError('SC1', {\n            regex: regexStr,\n            fieldName\n        });\n    }\n}\n\n/**\n * validate that all schema-related things are ok\n */\nexport function validateFieldsDeep(jsonSchema: any): true {\n    function checkField(\n        fieldName: string,\n        schemaObj: any,\n        path: string\n    ) {\n        if (\n            typeof fieldName === 'string' &&\n            typeof schemaObj === 'object' &&\n            !Array.isArray(schemaObj)\n        ) checkFieldNameRegex(fieldName);\n\n        // 'item' only allowed it type=='array'\n        if (schemaObj.hasOwnProperty('item') && schemaObj.type !== 'array') {\n            throw newRxError('SC2', {\n                fieldName\n            });\n        }\n\n        /**\n         * required fields cannot be set via 'required: true',\n         * but must be set via required: []\n         */\n        if (schemaObj.hasOwnProperty('required') && typeof schemaObj.required === 'boolean') {\n            throw newRxError('SC24', {\n                fieldName\n            });\n        }\n\n\n        // if ref given, must be type=='string', type=='array' with string-items or type==['string','null']\n        if (schemaObj.hasOwnProperty('ref')) {\n            if (Array.isArray(schemaObj.type)) {\n                if (schemaObj.type.length > 2 || !schemaObj.type.includes('string') || !schemaObj.type.includes('null')) {\n                    throw newRxError('SC4', {\n                        fieldName\n                    });\n                }\n            } else {\n                switch (schemaObj.type) {\n                    case 'string':\n                        break;\n                    case 'array':\n                        if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== 'string') {\n                            throw newRxError('SC3', {\n                                fieldName\n                            });\n                        }\n                        break;\n                    default:\n                        throw newRxError('SC4', {\n                            fieldName\n                        });\n                }\n            }\n        }\n\n        const isNested = path.split('.').length >= 2;\n\n        // nested only\n        if (isNested) {\n            if (schemaObj.primary) {\n                throw newRxError('SC6', {\n                    path,\n                    primary: schemaObj.primary\n                });\n            }\n\n            if (schemaObj.default) {\n                throw newRxError('SC7', {\n                    path\n                });\n            }\n        }\n\n        // first level\n        if (!isNested) {\n            // check underscore fields\n            if (fieldName.charAt(0) === '_') {\n                if (fieldName === '_deleted') {\n                    return;\n                }\n                throw newRxError('SC8', {\n                    fieldName\n                });\n            }\n        }\n    }\n\n    function traverse(currentObj: any, currentPath: any) {\n        if (typeof currentObj !== 'object') return;\n        Object.keys(currentObj).forEach(attributeName => {\n            if (!currentObj.properties) {\n                checkField(\n                    attributeName,\n                    currentObj[attributeName],\n                    currentPath\n                );\n            }\n            let nextPath = currentPath;\n            if (attributeName !== 'properties') nextPath = nextPath + '.' + attributeName;\n            traverse(currentObj[attributeName], nextPath);\n        });\n    }\n    traverse(jsonSchema, '');\n    return true;\n}\n\nexport function checkPrimaryKey(\n    jsonSchema: RxJsonSchema<any>\n) {\n    if (!jsonSchema.primaryKey) {\n        throw newRxError('SC30', { schema: jsonSchema });\n    }\n\n    function validatePrimarySchemaPart(\n        schemaPart: JsonSchema | TopLevelProperty\n    ) {\n        if (!schemaPart) {\n            throw newRxError('SC33', { schema: jsonSchema });\n        }\n\n        const type: string = schemaPart.type as any;\n        if (\n            !type ||\n            !['string', 'number', 'integer'].includes(type)\n        ) {\n            throw newRxError('SC32', { schema: jsonSchema, args: { schemaPart } });\n        }\n    }\n\n    if (typeof jsonSchema.primaryKey === 'string') {\n        const key = jsonSchema.primaryKey;\n        const schemaPart = jsonSchema.properties[key];\n        validatePrimarySchemaPart(schemaPart);\n    } else {\n        const compositePrimaryKey: CompositePrimaryKey<any> = jsonSchema.primaryKey as any;\n\n        const keySchemaPart = getSchemaByObjectPath(jsonSchema, compositePrimaryKey.key);\n        validatePrimarySchemaPart(keySchemaPart);\n\n        compositePrimaryKey.fields.forEach(field => {\n            const schemaPart = getSchemaByObjectPath(jsonSchema, field);\n            validatePrimarySchemaPart(schemaPart);\n        });\n    }\n}\n\n/**\n * computes real path of the object path in the collection schema\n */\nfunction getSchemaPropertyRealPath(shortPath: string) {\n    const pathParts = shortPath.split('.');\n    let realPath = '';\n    for (let i = 0; i < pathParts.length; i += 1) {\n        if (pathParts[i] !== '[]') {\n            realPath = realPath.concat('.properties.'.concat(pathParts[i]));\n        } else {\n            realPath = realPath.concat('.items');\n        }\n    }\n    return trimDots(realPath);\n}\n\n/**\n * does the checking\n * @throws {Error} if something is not ok\n */\nexport function checkSchema(jsonSchema: RxJsonSchema<any>) {\n\n    if (!jsonSchema.primaryKey) {\n        throw newRxError('SC30', {\n            schema: jsonSchema\n        });\n    }\n\n    if (!jsonSchema.hasOwnProperty('properties')) {\n        throw newRxError('SC29', {\n            schema: jsonSchema\n        });\n    }\n\n    // _rev MUST NOT exist, it is added by RxDB\n    if (jsonSchema.properties._rev) {\n        throw newRxError('SC10', {\n            schema: jsonSchema\n        });\n    }\n\n    // check version\n    if (!jsonSchema.hasOwnProperty('version') ||\n        typeof jsonSchema.version !== 'number' ||\n        jsonSchema.version < 0\n    ) {\n        throw newRxError('SC11', {\n            version: jsonSchema.version\n        });\n    }\n\n    validateFieldsDeep(jsonSchema);\n    checkPrimaryKey(jsonSchema);\n\n    Object.keys(jsonSchema.properties).forEach(key => {\n        const value: any = jsonSchema.properties[key];\n        // check primary\n        if (key === jsonSchema.primaryKey) {\n            if (jsonSchema.indexes && jsonSchema.indexes.includes(key)) {\n                throw newRxError('SC13', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n            if (value.unique) {\n                throw newRxError('SC14', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n            if (jsonSchema.encrypted && jsonSchema.encrypted.includes(key)) {\n                throw newRxError('SC15', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n            if (value.type !== 'string') {\n                throw newRxError('SC16', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n        }\n\n        // check if RxDocument-property\n        if (rxDocumentProperties().includes(key)) {\n            throw newRxError('SC17', {\n                key,\n                schema: jsonSchema\n            });\n        }\n    });\n\n    // check format of jsonSchema.indexes\n    if (jsonSchema.indexes) {\n        // should be an array\n        if (!Array.isArray(jsonSchema.indexes)) {\n            throw newRxError('SC18', {\n                indexes: jsonSchema.indexes,\n                schema: jsonSchema\n            });\n        }\n\n        jsonSchema.indexes.forEach(index => {\n            // should contain strings or array of strings\n            if (!(typeof index === 'string' || Array.isArray(index))) {\n                throw newRxError('SC19', { index, schema: jsonSchema });\n            }\n            // if is a compound index it must contain strings\n            if (Array.isArray(index)) {\n                for (let i = 0; i < index.length; i += 1) {\n                    if (typeof index[i] !== 'string') {\n                        throw newRxError('SC20', { index, schema: jsonSchema });\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * TODO\n     * this check has to exist only in beta-version, to help developers migrate their schemas\n     */\n    // remove backward-compatibility for compoundIndexes\n    if (Object.keys(jsonSchema).includes('compoundIndexes')) {\n        throw newRxError('SC25', { schema: jsonSchema });\n    }\n\n    // remove backward-compatibility for index: true\n    Object.keys(flattenObject(jsonSchema))\n        .map(key => {\n            // flattenObject returns only ending paths, we need all paths pointing to an object\n            const splitted = key.split('.');\n            splitted.pop(); // all but last\n            return splitted.join('.');\n        })\n        .filter(key => key !== '')\n        .filter((elem, pos, arr) => arr.indexOf(elem) === pos) // unique\n        .filter(key => { // check if this path defines an index\n            const value = objectPath.get(jsonSchema, key);\n            return !!value.index;\n        })\n        .forEach(key => { // replace inner properties\n            key = key.replace('properties.', ''); // first\n            key = key.replace(/\\.properties\\./g, '.'); // middle\n            throw newRxError('SC26', {\n                index: trimDots(key),\n                schema: jsonSchema\n            });\n        });\n\n    /* check types of the indexes */\n    (jsonSchema.indexes || [])\n        .reduce((indexPaths: string[], currentIndex) => {\n            if (Array.isArray(currentIndex)) {\n                indexPaths.concat(currentIndex);\n            } else {\n                indexPaths.push(currentIndex);\n            }\n            return indexPaths;\n        }, [])\n        .filter((elem, pos, arr) => arr.indexOf(elem) === pos) // from now on working only with unique indexes\n        .map(indexPath => {\n            const realPath = getSchemaPropertyRealPath(indexPath); // real path in the collection schema\n            const schemaObj = objectPath.get(jsonSchema, realPath); // get the schema of the indexed property\n            if (!schemaObj || typeof schemaObj !== 'object') {\n                throw newRxError('SC21', {\n                    index: indexPath,\n                    schema: jsonSchema\n                });\n            }\n            return { indexPath, schemaObj };\n        })\n        .filter(index =>\n            index.schemaObj.type !== 'string' &&\n            index.schemaObj.type !== 'integer' &&\n            index.schemaObj.type !== 'number'\n        )\n        .forEach(index => {\n            throw newRxError('SC22', {\n                key: index.indexPath,\n                type: index.schemaObj.type,\n                schema: jsonSchema\n            });\n        });\n\n\n    /**\n     * TODO\n     * in 9.0.0 we changed the way encrypted fields are defined\n     * This check ensures people do not oversee the breaking change\n     * Remove this check in the future\n     */\n    Object.keys(flattenObject(jsonSchema))\n        .map(key => {\n            // flattenObject returns only ending paths, we need all paths pointing to an object\n            const splitted = key.split('.');\n            splitted.pop(); // all but last\n            return splitted.join('.');\n        })\n        .filter(key => key !== '' && key !== 'attachments')\n        .filter((elem, pos, arr) => arr.indexOf(elem) === pos) // unique\n        .filter(key => {\n            // check if this path defines an encrypted field\n            const value = objectPath.get(jsonSchema, key);\n            return !!value.encrypted;\n        })\n        .forEach(key => { // replace inner properties\n            key = key.replace('properties.', ''); // first\n            key = key.replace(/\\.properties\\./g, '.'); // middle\n            throw newRxError('SC27', {\n                index: trimDots(key),\n                schema: jsonSchema\n            });\n        });\n\n    /* ensure encrypted fields exist in the schema */\n    if (jsonSchema.encrypted) {\n        jsonSchema.encrypted\n            .forEach(propPath => {\n                // real path in the collection schema\n                const realPath = getSchemaPropertyRealPath(propPath);\n                // get the schema of the indexed property\n                const schemaObj = objectPath.get(jsonSchema, realPath);\n                if (!schemaObj || typeof schemaObj !== 'object') {\n                    throw newRxError('SC28', {\n                        field: propPath,\n                        schema: jsonSchema\n                    });\n                }\n            });\n    }\n}\n"],"file":"check-schema.js"}
{"version":3,"sources":["../../../src/plugins/in-memory.ts"],"names":["collectionCacheMap","WeakMap","collectionPromiseCacheMap","BULK_DOC_OPTIONS","new_edits","BULK_DOC_OPTIONS_FALSE","InMemoryRxCollection","parentCollection","pouchSettings","database","name","toCleanSchema","schema","_methods","_eventCounter","_isInMemory","onDestroy","then","destroy","_crypter","password","_changeStreams","forEach","stream","cancel","storageInstance","internals","pouch","options","Object","entries","statics","funName","fun","defineProperty","get","bind","_observable$","Subject","_changeEventBuffer","parentProto","getPrototypeOf","_oldPouchPut","_pouchPut","_nonPersistentRevisions","Set","_nonPersistentRevisionsSubject","prepareChild","setIndexes","_subs","push","subscribe","cE","doc","_docCache","documentId","_handleChangeEvent","replicateExistingDocuments","thisToParentSub","streamChangedDocuments","pipe","applyChangedDocumentToPouch","changeRev","next","size","parentToThisSub","awaitPersistence","PROMISE_RESOLVE_VOID","obj","overwrite","ret","add","rev","$emit","changeEvent","hasChangeWithRevision","_rev","compact","syncCouchDB","RxCollectionBase","rxSchema","newSchemaJson","jsonSchema","keyCompression","properties","_attachments","removeEncryption","complete","encrypted","values","filter","val","fromCollection","toCollection","allDocs","attachments","include_docs","allRows","docs","rows","map","row","language","primaryKey","primaryPath","length","Promise","resolve","bulkDocs","all","indexes","indexAr","indexName","join","createIndex","ddoc","index","fields","rxCollection","prevFilter","_i","_doNotEmitSet","observable","changes","since","live","changeAr","change","emitFlag","id","has","d","docData","transformedDoc","_id","oldDoc","bulkRet","ok","Error","JSON","stringify","setTimeout","INIT_DONE","inMemory","PouchDB","adapters","memory","col","prepareInMemoryRxCollection","preparePromise","set","instance","memoryStorage","createStorageInstance","databaseName","collectionName","multiInstance","rxdb","prototypes","RxCollection","proto","RxDBInMemoryPlugin"],"mappings":"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","sourcesContent":["/**\n * This plugin adds RxCollection.inMemory()\n * Which replicates the collection into an in-memory-collection\n * So you can do faster queries and also query over encrypted fields.\n * Writes will still run on the original collection\n */\n\nimport {\n    Subject,\n    fromEvent as ObservableFromEvent,\n    Observable,\n    firstValueFrom\n} from 'rxjs';\n\nimport {\n    filter,\n    map,\n    mergeMap,\n    delay\n} from 'rxjs/operators';\n\nimport type {\n    RxCollection,\n    RxCouchDBReplicationState,\n    PouchDBInstance,\n    RxPlugin,\n    PouchBulkDocResultRow,\n    RxChangeEvent\n} from '../types';\nimport {\n    RxCollectionBase\n} from '../rx-collection';\nimport {\n    clone,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString\n} from '../util';\nimport {\n    PouchDB,\n    getRxStoragePouch,\n    pouchSwapIdToPrimary,\n    pouchSwapPrimaryToId,\n} from '../plugins/pouchdb';\nimport {\n    createCrypter\n} from '../crypter';\nimport {\n    createChangeEventBuffer\n} from '../change-event-buffer';\nimport {\n    createRxSchema,\n    RxSchema\n} from '../rx-schema';\nimport {\n    newRxError\n} from '../rx-error';\nimport { getDocumentDataOfRxChangeEvent } from '../rx-change-event';\nimport { _handleFromStorageInstance, _handleToStorageInstance } from '../rx-collection-helper';\n\nconst collectionCacheMap = new WeakMap();\nconst collectionPromiseCacheMap = new WeakMap();\nconst BULK_DOC_OPTIONS = {\n    new_edits: true\n};\nconst BULK_DOC_OPTIONS_FALSE = {\n    new_edits: false\n};\n\nexport\n    class InMemoryRxCollection<RxDocumentType, OrmMethods>\n    extends RxCollectionBase<RxDocumentType, OrmMethods> {\n\n    constructor(\n        public readonly parentCollection: RxCollection<RxDocumentType, OrmMethods>,\n        public readonly pouchSettings?: any\n    ) {\n        super(\n            parentCollection.database as any,\n            parentCollection.name,\n            toCleanSchema(parentCollection.schema),\n            pouchSettings, // pouchSettings\n            {} as any,\n            (parentCollection as any)._methods);\n        this._isInMemory = true;\n\n        parentCollection.onDestroy.then(() => this.destroy());\n        this._crypter = createCrypter(this.database.password, this.schema);\n        this._changeStreams = [];\n\n        /**\n         * runs on parentCollection.destroy()\n         * Cleans up everything to free up memory\n         */\n        this.onDestroy.then(() => {\n            this._changeStreams.forEach((stream: any) => stream.cancel());\n            // delete all data\n            this.storageInstance.internals.pouch.destroy();\n        });\n\n        // add orm functions and options from parent\n        this.options = parentCollection.options;\n        Object\n            .entries(parentCollection.statics)\n            .forEach(([funName, fun]) => {\n                Object.defineProperty(this, funName, {\n                    get: () => (fun as any).bind(this)\n                });\n            });\n\n        this._observable$ = new Subject();\n        this._changeEventBuffer = createChangeEventBuffer(this as any);\n\n        const parentProto = Object.getPrototypeOf(parentCollection);\n        this._oldPouchPut = (parentProto as any)._pouchPut.bind(this);\n\n        this._nonPersistentRevisions = new Set();\n        this._nonPersistentRevisionsSubject = new Subject(); // emits Set.size() when Set is changed\n    }\n    public _changeStreams: any;\n    public _oldPouchPut: Function;\n    public _nonPersistentRevisions: any;\n    public _nonPersistentRevisionsSubject: any;\n\n\n    /**\n     * @overwrite\n     */\n    public _eventCounter: number = 0;\n\n    prepareChild() {\n        return setIndexes(this.schema, this.storageInstance.internals.pouch)\n            .then(() => {\n                this._subs.push(\n                    (this._observable$ as any).subscribe((cE: RxChangeEvent) => {\n                        // when data changes, send it to RxDocument in docCache\n                        const doc = this._docCache.get(cE.documentId);\n                        if (doc) doc._handleChangeEvent(cE);\n                    })\n                );\n            })\n            // initial sync parent's docs to own\n            .then(() => replicateExistingDocuments(this.parentCollection as any, this as any))\n            .then(() => {\n                /**\n                 * create an ongoing replications between both sides\n                 */\n                const thisToParentSub = streamChangedDocuments(this as any)\n                    .pipe(\n                        mergeMap(doc => applyChangedDocumentToPouch(this.parentCollection, doc)\n                            .then(() => doc['_rev'])\n                        )\n                    )\n                    .subscribe(changeRev => {\n                        this._nonPersistentRevisions.delete(changeRev);\n                        this._nonPersistentRevisionsSubject.next(this._nonPersistentRevisions.size);\n                    });\n                this._subs.push(thisToParentSub);\n\n                const parentToThisSub = streamChangedDocuments(this.parentCollection)\n                    .subscribe(doc => applyChangedDocumentToPouch(this as any, doc));\n                this._subs.push(parentToThisSub);\n            });\n    }\n\n    /**\n     * waits until all writes are persistent\n     * in the parent collection\n     */\n    awaitPersistence(): Promise<any> {\n        if (this._nonPersistentRevisions.size === 0) {\n            return PROMISE_RESOLVE_VOID;\n        }\n        return firstValueFrom(\n            this._nonPersistentRevisionsSubject.pipe(\n                filter(() => this._nonPersistentRevisions.size === 0),\n            )\n        );\n    }\n\n    /**\n     * To know which events are replicated and which are not,\n     * the _pouchPut is wrapped\n     * @overwrite\n     */\n    _pouchPut(obj: any, overwrite: boolean) {\n        return this._oldPouchPut(obj, overwrite).then((ret: any) => {\n            this._nonPersistentRevisions.add(ret.rev);\n            return ret;\n        });\n    }\n    $emit(changeEvent: RxChangeEvent) {\n        const doc = getDocumentDataOfRxChangeEvent(changeEvent);\n        if ((this._changeEventBuffer as any).hasChangeWithRevision(doc && doc._rev)) {\n            return;\n        }\n\n        (this._observable$ as any).next(changeEvent);\n\n        // run compaction each 10 events\n        this._eventCounter++;\n        if (this._eventCounter === 10) {\n            this._eventCounter = 0;\n            this.storageInstance.internals.pouch.compact();\n        }\n    }\n\n    /**\n     * @overwrite\n     * Replication on the inMemory is dangerous,\n     * replicate with it's parent instead\n     */\n    syncCouchDB(): RxCouchDBReplicationState {\n        throw newRxError('IM2');\n    }\n}\n\n/**\n * returns a version of the schema that:\n * - disabled the keyCompression\n * - has no encryption\n * - has no attachments\n */\nfunction toCleanSchema(rxSchema: RxSchema): RxSchema {\n    const newSchemaJson = clone(rxSchema.jsonSchema);\n    newSchemaJson.keyCompression = false;\n    delete newSchemaJson.properties._rev;\n    delete newSchemaJson.properties._attachments;\n\n    const removeEncryption = (schema: any, complete: any) => {\n        delete schema.encrypted;\n        Object.values(schema)\n            .filter(val => typeof val === 'object')\n            .forEach(val => removeEncryption(val, complete));\n    };\n    removeEncryption(newSchemaJson, newSchemaJson);\n\n    return createRxSchema(newSchemaJson);\n}\n\n/**\n * replicates all documents from the parent to the inMemoryCollection\n * @return Promise that resolves with an array of the docs data\n */\nexport function replicateExistingDocuments(\n    fromCollection: RxCollection,\n    toCollection: RxCollection\n): Promise<any[]> {\n    const pouch: PouchDBInstance = fromCollection.storageInstance.internals.pouch;\n    return pouch.allDocs({\n        attachments: false,\n        include_docs: true\n    }).then(allRows => {\n        const docs = allRows\n            .rows\n            .map((row: any) => row.doc)\n            .filter((doc: any) => !doc.language) // do not replicate design-docs\n            .map((doc: any) => _handleFromStorageInstance(fromCollection, doc))\n            // swap back primary because keyCompression:false\n            .map((doc: any) => {\n                const primaryKey: string = fromCollection.schema.primaryPath as any;\n                return pouchSwapPrimaryToId(primaryKey, doc);\n            });\n\n        if (docs.length === 0) {\n            // nothing to replicate\n            return Promise.resolve([]);\n        }\n        else {\n            return toCollection.storageInstance.internals.pouch.bulkDocs({\n                docs\n            }, BULK_DOC_OPTIONS_FALSE)\n                .then(() => docs);\n        }\n    });\n}\n\n/**\n * sets the indexes from the schema at the pouchdb\n */\nexport function setIndexes(\n    schema: RxSchema,\n    pouch: PouchDBInstance,\n): Promise<any> {\n    return Promise.all(\n        schema.indexes\n            .map(indexAr => {\n                const indexName = 'idx-rxdb-' + indexAr.join(',');\n                return pouch.createIndex({\n                    ddoc: indexName,\n                    name: indexName,\n                    index: {\n                        fields: indexAr\n                    }\n                });\n            })\n    );\n}\n\n/**\n * returns an observable that streams all changes\n * as plain documents that have no encryption or keyCompression.\n * We use this to replicate changes from one collection to the other\n * @param prevFilter can be used to filter changes before doing anything\n * @return observable that emits document-data\n */\nexport function streamChangedDocuments(\n    rxCollection: RxCollection<any, any>,\n    prevFilter = (_i: any) => true\n): Observable<any> {\n    if (!(rxCollection as any)._doNotEmitSet) {\n        (rxCollection as any)._doNotEmitSet = new Set();\n    }\n\n    const observable = ObservableFromEvent(\n        rxCollection.storageInstance.internals.pouch\n            .changes({\n                since: 'now',\n                live: true,\n                include_docs: true\n            }),\n        'change'\n    )\n        .pipe(\n            /**\n             * we need this delay because with pouchdb 7.2.2\n             * it happened that _doNotEmitSet.add() from applyChangedDocumentToPouch()\n             * was called after the change was streamed downwards\n             * which then leads to a wrong detection\n             */\n            delay(0),\n            map((changeAr: any) => changeAr[0]), // rxjs emits an array for whatever reason\n            filter(change => {\n                // changes on the doNotEmit-list shell not be fired\n                const emitFlag = change.id + ':' + change.doc._rev;\n                if ((rxCollection as any)._doNotEmitSet.has(emitFlag)) {\n                    return false;\n                } else {\n                    return true;\n                }\n            }),\n            filter(change => prevFilter(change)),\n            map(change => _handleFromStorageInstance(rxCollection, change.doc)),\n            map(d => {\n                const primaryKey: string = rxCollection.schema.primaryPath as any;\n                return pouchSwapIdToPrimary(primaryKey, d);\n            })\n        );\n    return observable;\n}\n\n/**\n * writes the doc-data into the pouchdb of the collection\n * without changeing the revision\n */\nexport function applyChangedDocumentToPouch(\n    rxCollection: RxCollection<any, any>,\n    docData: any\n): Promise<any> {\n    if (!(rxCollection as any)._doNotEmitSet) {\n        (rxCollection as any)._doNotEmitSet = new Set();\n    }\n\n    const primaryKey: string = rxCollection.schema.primaryPath as any;\n\n    let transformedDoc = _handleToStorageInstance(rxCollection, docData);\n    transformedDoc = pouchSwapPrimaryToId(\n        primaryKey,\n        transformedDoc\n    );\n\n    return rxCollection.storageInstance.internals.pouch.get(transformedDoc._id)\n        .then((oldDoc: any) => transformedDoc._rev = oldDoc._rev)\n        .catch(() => {\n            // doc not found, do not use a revision\n            delete transformedDoc._rev;\n        }).then(() => rxCollection.storageInstance.internals.pouch.bulkDocs({\n            docs: [transformedDoc]\n        }, BULK_DOC_OPTIONS))\n        .then((bulkRet: any) => {\n            if (bulkRet.length > 0 && !(bulkRet[0] as PouchBulkDocResultRow).ok) {\n                throw new Error(JSON.stringify(bulkRet[0]));\n            }\n            // set the flag so this does not appear in the own event-stream again\n            const emitFlag = transformedDoc._id + ':' + (bulkRet[0] as PouchBulkDocResultRow).rev;\n            (rxCollection as any)._doNotEmitSet.add(emitFlag);\n\n            // remove from the list later to not have a memory-leak\n            setTimeout(() => (rxCollection as any)._doNotEmitSet.delete(emitFlag), 30 * 1000);\n\n            return transformedDoc;\n        });\n}\n\nlet INIT_DONE = false;\n/**\n * called in the proto of RxCollection\n */\nexport async function inMemory(\n    this: RxCollection\n): Promise<RxCollection> {\n    if (!INIT_DONE) {\n        INIT_DONE = true;\n        // ensure memory-adapter is added\n        if (!(PouchDB as any).adapters || !(PouchDB as any).adapters.memory) {\n            throw newRxError('IM1');\n        }\n    }\n\n    if (collectionCacheMap.has(this)) {\n        // already exists for this collection -> wait until synced\n        return collectionPromiseCacheMap.get(this)\n            .then(() => collectionCacheMap.get(this));\n    }\n\n    const col = new InMemoryRxCollection(this);\n    await prepareInMemoryRxCollection(col);\n\n    const preparePromise = col.prepareChild();\n    collectionCacheMap.set(this, col);\n    collectionPromiseCacheMap.set(this, preparePromise);\n\n    return preparePromise.then(() => col) as any;\n}\n\nexport async function prepareInMemoryRxCollection(instance: InMemoryRxCollection<any, {}>): Promise<void> {\n    const memoryStorage = getRxStoragePouch('memory', {});\n    instance.storageInstance = await memoryStorage.createStorageInstance({\n        databaseName: 'rxdb-in-memory',\n        collectionName: randomCouchString(10),\n        schema: instance.schema.jsonSchema,\n        options: instance.pouchSettings,\n        multiInstance: false\n    });\n    (instance as any).pouch = instance.storageInstance.internals.pouch;\n}\n\n\nexport const rxdb = true;\nexport const prototypes = {\n    RxCollection: (proto: any) => {\n        proto.inMemory = inMemory;\n    }\n};\n\nexport const RxDBInMemoryPlugin: RxPlugin = {\n    name: 'in-memory',\n    rxdb,\n    prototypes\n};\n"],"file":"in-memory.js"}
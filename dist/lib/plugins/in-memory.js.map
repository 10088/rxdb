{"version":3,"sources":["../../../src/plugins/in-memory.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAOA;;AAOA;;AAeA;;AAGA;;AAKA;;AAMA;;AAGA;;AAGA;;AAIA;;AAGA;;AACA;;AAzDA;AACA;AACA;AACA;AACA;AACA;AAsDA,IAAM,kBAAkB,GAAG,IAAI,OAAJ,EAA3B;AACA,IAAM,yBAAyB,GAAG,IAAI,OAAJ,EAAlC;AACA,IAAM,gBAAgB,GAAG;AACrB,EAAA,SAAS,EAAE;AADU,CAAzB;AAGA,IAAM,sBAAsB,GAAG;AAC3B,EAAA,SAAS,EAAE;AADgB,CAA/B;;IAKU,oB;;;AAGN,gCACoB,gBADpB,EAEoB,aAFpB,EAGE;AAAA;;AACE,yCACI,gBAAgB,CAAC,QADrB,EAEI,gBAAgB,CAAC,IAFrB,EAGI,aAAa,CAAC,gBAAgB,CAAC,MAAlB,CAHjB,EAII,aAJJ,EAImB;AACf,MALJ,EAMK,gBAAD,CAA0B,QAN9B;AADF,UAoDK,aApDL,GAoD6B,CApD7B;AAAA,UAFkB,gBAElB,GAFkB,gBAElB;AAAA,UADkB,aAClB,GADkB,aAClB;AAQE,UAAK,WAAL,GAAmB,IAAnB;AAEA,IAAA,gBAAgB,CAAC,SAAjB,CAA2B,IAA3B,CAAgC;AAAA,aAAM,MAAK,OAAL,EAAN;AAAA,KAAhC;AACA,UAAK,QAAL,GAAgB,4BAAc,MAAK,QAAL,CAAc,QAA5B,EAAsC,MAAK,MAA3C,CAAhB;AACA,UAAK,cAAL,GAAsB,EAAtB;AAEA;AACR;AACA;AACA;;AACQ,UAAK,SAAL,CAAe,IAAf,CAAoB,YAAM;AACtB,YAAK,cAAL,CAAoB,OAApB,CAA4B,UAAC,MAAD;AAAA,eAAiB,MAAM,CAAC,MAAP,EAAjB;AAAA,OAA5B,EADsB,CAEtB;;;AACA,YAAK,eAAL,CAAqB,SAArB,CAA+B,KAA/B,CAAqC,OAArC;AACH,KAJD,EAlBF,CAwBE;;;AACA,UAAK,OAAL,GAAe,gBAAgB,CAAC,OAAhC;AACA,IAAA,MAAM,CACD,OADL,CACa,gBAAgB,CAAC,OAD9B,EAEK,OAFL,CAEa,gBAAoB;AAAA,UAAlB,OAAkB;AAAA,UAAT,GAAS;AACzB,MAAA,MAAM,CAAC,cAAP,iDAA4B,OAA5B,EAAqC;AACjC,QAAA,GAAG,EAAE;AAAA,iBAAO,GAAD,CAAa,IAAb,gDAAN;AAAA;AAD4B,OAArC;AAGH,KANL;AAQA,UAAK,YAAL,GAAoB,IAAI,aAAJ,EAApB;AACA,UAAK,kBAAL,GAA0B,+FAA1B;AAEA,QAAM,WAAW,GAAG,MAAM,CAAC,cAAP,CAAsB,gBAAtB,CAApB;AACA,UAAK,YAAL,GAAqB,WAAD,CAAqB,SAArB,CAA+B,IAA/B,gDAApB;AAEA,UAAK,uBAAL,GAA+B,IAAI,GAAJ,EAA/B;AACA,UAAK,8BAAL,GAAsC,IAAI,aAAJ,EAAtC,CAzCF,CAyCuD;;AAzCvD;AA0CD;;;;SAYD,Y,GAAA,wBAAe;AAAA;;AACX,WAAO,UAAU,CAAC,KAAK,MAAN,EAAc,KAAK,eAAL,CAAqB,SAArB,CAA+B,KAA7C,CAAV,CACF,IADE,CACG,YAAM;AACR,MAAA,MAAI,CAAC,KAAL,CAAW,IAAX,CACK,MAAI,CAAC,YAAN,CAA2B,SAA3B,CAAqC,UAAC,EAAD,EAAuB;AACxD;AACA,YAAM,GAAG,GAAG,MAAI,CAAC,SAAL,CAAe,GAAf,CAAmB,EAAE,CAAC,UAAtB,CAAZ;;AACA,YAAI,GAAJ,EAAS,GAAG,CAAC,kBAAJ,CAAuB,EAAvB;AACZ,OAJD,CADJ;AAOH,KATE,EAUH;AAVG,KAWF,IAXE,CAWG;AAAA,aAAM,0BAA0B,CAAC,MAAI,CAAC,gBAAN,EAA+B,MAA/B,CAAhC;AAAA,KAXH,EAYF,IAZE,CAYG,YAAM;AACR;AAChB;AACA;AACgB,UAAM,eAAe,GAAG,sBAAsB,CAAC,MAAD,CAAtB,CACnB,IADmB,CAEhB,yBAAS,UAAA,GAAG;AAAA,eAAI,2BAA2B,CAAC,MAAI,CAAC,gBAAN,EAAwB,GAAxB,CAA3B,CACX,IADW,CACN;AAAA,iBAAM,GAAG,CAAC,MAAD,CAAT;AAAA,SADM,CAAJ;AAAA,OAAZ,CAFgB,EAMnB,SANmB,CAMT,UAAA,SAAS,EAAI;AACpB,QAAA,MAAI,CAAC,uBAAL,WAAoC,SAApC;;AACA,QAAA,MAAI,CAAC,8BAAL,CAAoC,IAApC,CAAyC,MAAI,CAAC,uBAAL,CAA6B,IAAtE;AACH,OATmB,CAAxB;;AAUA,MAAA,MAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,eAAhB;;AAEA,UAAM,eAAe,GAAG,sBAAsB,CAAC,MAAI,CAAC,gBAAN,CAAtB,CACnB,SADmB,CACT,UAAA,GAAG;AAAA,eAAI,2BAA2B,CAAC,MAAD,EAAc,GAAd,CAA/B;AAAA,OADM,CAAxB;;AAEA,MAAA,MAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,eAAhB;AACH,KA/BE,CAAP;AAgCH;AAED;AACJ;AACA;AACA;;;SACI,gB,GAAA,4BAAiC;AAAA;;AAC7B,QAAI,KAAK,uBAAL,CAA6B,IAA7B,KAAsC,CAA1C,EAA6C;AACzC,aAAO,0BAAP;AACH;;AACD,WAAO,0BACH,KAAK,8BAAL,CAAoC,IAApC,CACI,uBAAO;AAAA,aAAM,MAAI,CAAC,uBAAL,CAA6B,IAA7B,KAAsC,CAA5C;AAAA,KAAP,CADJ,CADG,CAAP;AAKH;AAED;AACJ;AACA;AACA;AACA;;;SACI,S,GAAA,mBAAU,GAAV,EAAoB,SAApB,EAAwC;AAAA;;AACpC,WAAO,KAAK,YAAL,CAAkB,GAAlB,EAAuB,SAAvB,EAAkC,IAAlC,CAAuC,UAAC,GAAD,EAAc;AACxD,MAAA,MAAI,CAAC,uBAAL,CAA6B,GAA7B,CAAiC,GAAG,CAAC,GAArC;;AACA,aAAO,GAAP;AACH,KAHM,CAAP;AAIH,G;;SACD,K,GAAA,eAAM,WAAN,EAAkC;AAC9B,QAAM,GAAG,GAAG,mDAA+B,WAA/B,CAAZ;;AACA,QAAK,KAAK,kBAAN,CAAiC,qBAAjC,CAAuD,GAAG,IAAI,GAAG,CAAC,IAAlE,CAAJ,EAA6E;AACzE;AACH;;AAEA,SAAK,YAAN,CAA2B,IAA3B,CAAgC,WAAhC,EAN8B,CAQ9B;;;AACA,SAAK,aAAL;;AACA,QAAI,KAAK,aAAL,KAAuB,EAA3B,EAA+B;AAC3B,WAAK,aAAL,GAAqB,CAArB;AACA,WAAK,eAAL,CAAqB,SAArB,CAA+B,KAA/B,CAAqC,OAArC;AACH;AACJ;AAED;AACJ;AACA;AACA;AACA;;;SACI,W,GAAA,uBAAyC;AACrC,UAAM,yBAAW,KAAX,CAAN;AACH,G;;;EA/IO,8B;AAkJZ;AACA;AACA;AACA;AACA;AACA;;;;;AACA,SAAS,aAAT,CAAuB,QAAvB,EAAqD;AACjD,MAAM,aAAa,GAAG,iBAAM,QAAQ,CAAC,UAAf,CAAtB;AACA,EAAA,aAAa,CAAC,cAAd,GAA+B,KAA/B;AACA,SAAO,aAAa,CAAC,UAAd,CAAyB,IAAhC;AACA,SAAO,aAAa,CAAC,UAAd,CAAyB,YAAhC;;AAEA,MAAM,gBAAgB,GAAG,SAAnB,gBAAmB,CAAC,MAAD,EAAc,QAAd,EAAgC;AACrD,WAAO,MAAM,CAAC,SAAd;AACA,IAAA,MAAM,CAAC,MAAP,CAAc,MAAd,EACK,MADL,CACY,UAAA,GAAG;AAAA,aAAI,OAAO,GAAP,KAAe,QAAnB;AAAA,KADf,EAEK,OAFL,CAEa,UAAA,GAAG;AAAA,aAAI,gBAAgB,CAAC,GAAD,EAAM,QAAN,CAApB;AAAA,KAFhB;AAGH,GALD;;AAMA,EAAA,gBAAgB,CAAC,aAAD,EAAgB,aAAhB,CAAhB;AAEA,SAAO,8BAAe,aAAf,CAAP;AACH;AAED;AACA;AACA;AACA;;;AACO,SAAS,0BAAT,CACH,cADG,EAEH,YAFG,EAGW;AACd,MAAM,KAAsB,GAAG,cAAc,CAAC,eAAf,CAA+B,SAA/B,CAAyC,KAAxE;AACA,SAAO,KAAK,CAAC,OAAN,CAAc;AACjB,IAAA,WAAW,EAAE,KADI;AAEjB,IAAA,YAAY,EAAE;AAFG,GAAd,EAGJ,IAHI,CAGC,UAAA,OAAO,EAAI;AACf,QAAM,IAAI,GAAG,OAAO,CACf,IADQ,CAER,GAFQ,CAEJ,UAAC,GAAD;AAAA,aAAc,GAAG,CAAC,GAAlB;AAAA,KAFI,EAGR,MAHQ,CAGD,UAAC,GAAD;AAAA,aAAc,CAAC,GAAG,CAAC,QAAnB;AAAA,KAHC,EAG4B;AAH5B,KAIR,GAJQ,CAIJ,UAAC,GAAD;AAAA,aAAc,oDAA2B,cAA3B,EAA2C,GAA3C,CAAd;AAAA,KAJI,EAKT;AALS,KAMR,GANQ,CAMJ,UAAC,GAAD,EAAc;AACf,UAAM,UAAkB,GAAG,cAAc,CAAC,MAAf,CAAsB,WAAjD;AACA,aAAO,mCAAqB,UAArB,EAAiC,GAAjC,CAAP;AACH,KATQ,CAAb;;AAWA,QAAI,IAAI,CAAC,MAAL,KAAgB,CAApB,EAAuB;AACnB;AACA,aAAO,OAAO,CAAC,OAAR,CAAgB,EAAhB,CAAP;AACH,KAHD,MAIK;AACD,aAAO,YAAY,CAAC,eAAb,CAA6B,SAA7B,CAAuC,KAAvC,CAA6C,QAA7C,CAAsD;AACzD,QAAA,IAAI,EAAJ;AADyD,OAAtD,EAEJ,sBAFI,EAGF,IAHE,CAGG;AAAA,eAAM,IAAN;AAAA,OAHH,CAAP;AAIH;AACJ,GAzBM,CAAP;AA0BH;AAED;AACA;AACA;;;AACO,SAAS,UAAT,CACH,MADG,EAEH,KAFG,EAGS;AACZ,SAAO,OAAO,CAAC,GAAR,CACH,MAAM,CAAC,OAAP,CACK,GADL,CACS,UAAA,OAAO,EAAI;AACZ,QAAM,SAAS,GAAG,cAAc,OAAO,CAAC,IAAR,CAAa,GAAb,CAAhC;AACA,WAAO,KAAK,CAAC,WAAN,CAAkB;AACrB,MAAA,IAAI,EAAE,SADe;AAErB,MAAA,IAAI,EAAE,SAFe;AAGrB,MAAA,KAAK,EAAE;AACH,QAAA,MAAM,EAAE;AADL;AAHc,KAAlB,CAAP;AAOH,GAVL,CADG,CAAP;AAaH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAAS,sBAAT,CACH,YADG,EAGY;AAAA,MADf,UACe,uEADF,UAAC,EAAD;AAAA,WAAa,IAAb;AAAA,GACE;;AACf,MAAI,CAAE,YAAD,CAAsB,aAA3B,EAA0C;AACrC,IAAA,YAAD,CAAsB,aAAtB,GAAsC,IAAI,GAAJ,EAAtC;AACH;;AAED,MAAM,UAAU,GAAG,qBACf,YAAY,CAAC,eAAb,CAA6B,SAA7B,CAAuC,KAAvC,CACK,OADL,CACa;AACL,IAAA,KAAK,EAAE,KADF;AAEL,IAAA,IAAI,EAAE,IAFD;AAGL,IAAA,YAAY,EAAE;AAHT,GADb,CADe,EAOf,QAPe,EASd,IATc;AAUX;AACZ;AACA;AACA;AACA;AACA;AACY,wBAAM,CAAN,CAhBW,EAiBX,oBAAI,UAAC,QAAD;AAAA,WAAmB,QAAQ,CAAC,CAAD,CAA3B;AAAA,GAAJ,CAjBW,EAiB0B;AACrC,yBAAO,UAAA,MAAM,EAAI;AACb;AACA,QAAM,QAAQ,GAAG,MAAM,CAAC,EAAP,GAAY,GAAZ,GAAkB,MAAM,CAAC,GAAP,CAAW,IAA9C;;AACA,QAAK,YAAD,CAAsB,aAAtB,CAAoC,GAApC,CAAwC,QAAxC,CAAJ,EAAuD;AACnD,aAAO,KAAP;AACH,KAFD,MAEO;AACH,aAAO,IAAP;AACH;AACJ,GARD,CAlBW,EA2BX,uBAAO,UAAA,MAAM;AAAA,WAAI,UAAU,CAAC,MAAD,CAAd;AAAA,GAAb,CA3BW,EA4BX,oBAAI,UAAA,MAAM;AAAA,WAAI,oDAA2B,YAA3B,EAAyC,MAAM,CAAC,GAAhD,CAAJ;AAAA,GAAV,CA5BW,EA6BX,oBAAI,UAAA,CAAC,EAAI;AACL,QAAM,UAAkB,GAAG,YAAY,CAAC,MAAb,CAAoB,WAA/C;AACA,WAAO,mCAAqB,UAArB,EAAiC,CAAjC,CAAP;AACH,GAHD,CA7BW,CAAnB;AAkCA,SAAO,UAAP;AACH;AAED;AACA;AACA;AACA;;;AACO,SAAS,2BAAT,CACH,YADG,EAEH,OAFG,EAGS;AACZ,MAAI,CAAE,YAAD,CAAsB,aAA3B,EAA0C;AACrC,IAAA,YAAD,CAAsB,aAAtB,GAAsC,IAAI,GAAJ,EAAtC;AACH;;AAED,MAAM,UAAkB,GAAG,YAAY,CAAC,MAAb,CAAoB,WAA/C;AAEA,MAAI,cAAc,GAAG,kDAAyB,YAAzB,EAAuC,OAAvC,CAArB;AACA,EAAA,cAAc,GAAG,mCACb,UADa,EAEb,cAFa,CAAjB;AAKA,SAAO,YAAY,CAAC,eAAb,CAA6B,SAA7B,CAAuC,KAAvC,CAA6C,GAA7C,CAAiD,cAAc,CAAC,GAAhE,EACF,IADE,CACG,UAAC,MAAD;AAAA,WAAiB,cAAc,CAAC,IAAf,GAAsB,MAAM,CAAC,IAA9C;AAAA,GADH,WAEI,YAAM;AACT;AACA,WAAO,cAAc,CAAC,IAAtB;AACH,GALE,EAKA,IALA,CAKK;AAAA,WAAM,YAAY,CAAC,eAAb,CAA6B,SAA7B,CAAuC,KAAvC,CAA6C,QAA7C,CAAsD;AAChE,MAAA,IAAI,EAAE,CAAC,cAAD;AAD0D,KAAtD,EAEX,gBAFW,CAAN;AAAA,GALL,EAQF,IARE,CAQG,UAAC,OAAD,EAAkB;AACpB,QAAI,OAAO,CAAC,MAAR,GAAiB,CAAjB,IAAsB,CAAE,OAAO,CAAC,CAAD,CAAR,CAAsC,EAAjE,EAAqE;AACjE,YAAM,IAAI,KAAJ,CAAU,IAAI,CAAC,SAAL,CAAe,OAAO,CAAC,CAAD,CAAtB,CAAV,CAAN;AACH,KAHmB,CAIpB;;;AACA,QAAM,QAAQ,GAAG,cAAc,CAAC,GAAf,GAAqB,GAArB,GAA4B,OAAO,CAAC,CAAD,CAAR,CAAsC,GAAlF;;AACC,IAAA,YAAD,CAAsB,aAAtB,CAAoC,GAApC,CAAwC,QAAxC,EANoB,CAQpB;;;AACA,IAAA,UAAU,CAAC;AAAA,aAAO,YAAD,CAAsB,aAAtB,WAA2C,QAA3C,CAAN;AAAA,KAAD,EAA6D,KAAK,IAAlE,CAAV;AAEA,WAAO,cAAP;AACH,GApBE,CAAP;AAqBH;;AAED,IAAI,SAAS,GAAG,KAAhB;AACA;AACA;AACA;;SACsB,Q;;;;;4FAAf;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAGE,SAHF;AAAA;AAAA;AAAA;;AAIC,YAAA,SAAS,GAAG,IAAZ,CAJD,CAKC;;AALD,kBAMK,CAAE,gBAAD,CAAiB,QAAlB,IAA8B,CAAE,gBAAD,CAAiB,QAAjB,CAA0B,MAN9D;AAAA;AAAA;AAAA;;AAAA,kBAOW,yBAAW,KAAX,CAPX;;AAAA;AAAA,iBAWC,kBAAkB,CAAC,GAAnB,CAAuB,IAAvB,CAXD;AAAA;AAAA;AAAA;;AAAA,6CAaQ,yBAAyB,CAAC,GAA1B,CAA8B,IAA9B,EACF,IADE,CACG;AAAA,qBAAM,kBAAkB,CAAC,GAAnB,CAAuB,MAAvB,CAAN;AAAA,aADH,CAbR;;AAAA;AAiBG,YAAA,GAjBH,GAiBS,IAAI,oBAAJ,CAAyB,IAAzB,CAjBT;AAAA;AAAA,mBAkBG,2BAA2B,CAAC,GAAD,CAlB9B;;AAAA;AAoBG,YAAA,cApBH,GAoBoB,GAAG,CAAC,YAAJ,EApBpB;AAqBH,YAAA,kBAAkB,CAAC,GAAnB,CAAuB,IAAvB,EAA6B,GAA7B;AACA,YAAA,yBAAyB,CAAC,GAA1B,CAA8B,IAA9B,EAAoC,cAApC;AAtBG,6CAwBI,cAAc,CAAC,IAAf,CAAoB;AAAA,qBAAM,GAAN;AAAA,aAApB,CAxBJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SA2Be,2B;;;;;+GAAf,kBAA2C,QAA3C;AAAA;AAAA;AAAA;AAAA;AAAA;AACG,YAAA,aADH,GACmB,gCAAkB,QAAlB,EAA4B,EAA5B,CADnB;AAAA;AAAA,mBAE8B,aAAa,CAAC,qBAAd,CAAoC;AACjE,cAAA,YAAY,EAAE,gBADmD;AAEjE,cAAA,cAAc,EAAE,6BAAkB,EAAlB,CAFiD;AAGjE,cAAA,MAAM,EAAE,QAAQ,CAAC,MAAT,CAAgB,UAHyC;AAIjE,cAAA,OAAO,EAAE,QAAQ,CAAC,aAJ+C;AAKjE,cAAA,SAAS,EAAE,QAAQ,CAAC,QAAT,CAAkB;AALoC,aAApC,CAF9B;;AAAA;AAEH,YAAA,QAAQ,CAAC,eAFN;AASF,YAAA,QAAD,CAAkB,KAAlB,GAA0B,QAAQ,CAAC,eAAT,CAAyB,SAAzB,CAAmC,KAA7D;;AATG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAaA,IAAM,IAAI,GAAG,IAAb;;AACA,IAAM,UAAU,GAAG;AACtB,EAAA,YAAY,EAAE,sBAAC,KAAD,EAAgB;AAC1B,IAAA,KAAK,CAAC,QAAN,GAAiB,QAAjB;AACH;AAHqB,CAAnB;;AAMA,IAAM,kBAA4B,GAAG;AACxC,EAAA,IAAI,EAAE,WADkC;AAExC,EAAA,IAAI,EAAJ,IAFwC;AAGxC,EAAA,UAAU,EAAV;AAHwC,CAArC","file":"in-memory.js","sourcesContent":["/**\n * This plugin adds RxCollection.inMemory()\n * Which replicates the collection into an in-memory-collection\n * So you can do faster queries and also query over encrypted fields.\n * Writes will still run on the original collection\n */\n\nimport {\n    Subject,\n    fromEvent as ObservableFromEvent,\n    Observable,\n    firstValueFrom\n} from 'rxjs';\n\nimport {\n    filter,\n    map,\n    mergeMap,\n    delay\n} from 'rxjs/operators';\n\nimport type {\n    RxCollection,\n    RxCouchDBReplicationState,\n    PouchDBInstance,\n    RxPlugin,\n    PouchBulkDocResultRow,\n    RxChangeEvent\n} from '../types';\nimport {\n    RxCollectionBase\n} from '../rx-collection';\nimport {\n    clone,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString\n} from '../util';\nimport {\n    PouchDB,\n    getRxStoragePouch,\n    pouchSwapIdToPrimary,\n    pouchSwapPrimaryToId,\n} from '../plugins/pouchdb';\nimport {\n    createCrypter\n} from '../crypter';\nimport {\n    createChangeEventBuffer\n} from '../change-event-buffer';\nimport {\n    createRxSchema,\n    RxSchema\n} from '../rx-schema';\nimport {\n    newRxError\n} from '../rx-error';\nimport { getDocumentDataOfRxChangeEvent } from '../rx-change-event';\nimport { _handleFromStorageInstance, _handleToStorageInstance } from '../rx-collection-helper';\n\nconst collectionCacheMap = new WeakMap();\nconst collectionPromiseCacheMap = new WeakMap();\nconst BULK_DOC_OPTIONS = {\n    new_edits: true\n};\nconst BULK_DOC_OPTIONS_FALSE = {\n    new_edits: false\n};\n\nexport\n    class InMemoryRxCollection<RxDocumentType, OrmMethods>\n    extends RxCollectionBase<RxDocumentType, OrmMethods> {\n\n    constructor(\n        public readonly parentCollection: RxCollection<RxDocumentType, OrmMethods>,\n        public readonly pouchSettings?: any\n    ) {\n        super(\n            parentCollection.database as any,\n            parentCollection.name,\n            toCleanSchema(parentCollection.schema),\n            pouchSettings, // pouchSettings\n            {} as any,\n            (parentCollection as any)._methods);\n        this._isInMemory = true;\n\n        parentCollection.onDestroy.then(() => this.destroy());\n        this._crypter = createCrypter(this.database.password, this.schema);\n        this._changeStreams = [];\n\n        /**\n         * runs on parentCollection.destroy()\n         * Cleans up everything to free up memory\n         */\n        this.onDestroy.then(() => {\n            this._changeStreams.forEach((stream: any) => stream.cancel());\n            // delete all data\n            this.storageInstance.internals.pouch.destroy();\n        });\n\n        // add orm functions and options from parent\n        this.options = parentCollection.options;\n        Object\n            .entries(parentCollection.statics)\n            .forEach(([funName, fun]) => {\n                Object.defineProperty(this, funName, {\n                    get: () => (fun as any).bind(this)\n                });\n            });\n\n        this._observable$ = new Subject();\n        this._changeEventBuffer = createChangeEventBuffer(this as any);\n\n        const parentProto = Object.getPrototypeOf(parentCollection);\n        this._oldPouchPut = (parentProto as any)._pouchPut.bind(this);\n\n        this._nonPersistentRevisions = new Set();\n        this._nonPersistentRevisionsSubject = new Subject(); // emits Set.size() when Set is changed\n    }\n    public _changeStreams: any;\n    public _oldPouchPut: Function;\n    public _nonPersistentRevisions: any;\n    public _nonPersistentRevisionsSubject: any;\n\n\n    /**\n     * @overwrite\n     */\n    public _eventCounter: number = 0;\n\n    prepareChild() {\n        return setIndexes(this.schema, this.storageInstance.internals.pouch)\n            .then(() => {\n                this._subs.push(\n                    (this._observable$ as any).subscribe((cE: RxChangeEvent) => {\n                        // when data changes, send it to RxDocument in docCache\n                        const doc = this._docCache.get(cE.documentId);\n                        if (doc) doc._handleChangeEvent(cE);\n                    })\n                );\n            })\n            // initial sync parent's docs to own\n            .then(() => replicateExistingDocuments(this.parentCollection as any, this as any))\n            .then(() => {\n                /**\n                 * create an ongoing replications between both sides\n                 */\n                const thisToParentSub = streamChangedDocuments(this as any)\n                    .pipe(\n                        mergeMap(doc => applyChangedDocumentToPouch(this.parentCollection, doc)\n                            .then(() => doc['_rev'])\n                        )\n                    )\n                    .subscribe(changeRev => {\n                        this._nonPersistentRevisions.delete(changeRev);\n                        this._nonPersistentRevisionsSubject.next(this._nonPersistentRevisions.size);\n                    });\n                this._subs.push(thisToParentSub);\n\n                const parentToThisSub = streamChangedDocuments(this.parentCollection)\n                    .subscribe(doc => applyChangedDocumentToPouch(this as any, doc));\n                this._subs.push(parentToThisSub);\n            });\n    }\n\n    /**\n     * waits until all writes are persistent\n     * in the parent collection\n     */\n    awaitPersistence(): Promise<any> {\n        if (this._nonPersistentRevisions.size === 0) {\n            return PROMISE_RESOLVE_VOID;\n        }\n        return firstValueFrom(\n            this._nonPersistentRevisionsSubject.pipe(\n                filter(() => this._nonPersistentRevisions.size === 0),\n            )\n        );\n    }\n\n    /**\n     * To know which events are replicated and which are not,\n     * the _pouchPut is wrapped\n     * @overwrite\n     */\n    _pouchPut(obj: any, overwrite: boolean) {\n        return this._oldPouchPut(obj, overwrite).then((ret: any) => {\n            this._nonPersistentRevisions.add(ret.rev);\n            return ret;\n        });\n    }\n    $emit(changeEvent: RxChangeEvent) {\n        const doc = getDocumentDataOfRxChangeEvent(changeEvent);\n        if ((this._changeEventBuffer as any).hasChangeWithRevision(doc && doc._rev)) {\n            return;\n        }\n\n        (this._observable$ as any).next(changeEvent);\n\n        // run compaction each 10 events\n        this._eventCounter++;\n        if (this._eventCounter === 10) {\n            this._eventCounter = 0;\n            this.storageInstance.internals.pouch.compact();\n        }\n    }\n\n    /**\n     * @overwrite\n     * Replication on the inMemory is dangerous,\n     * replicate with it's parent instead\n     */\n    syncCouchDB(): RxCouchDBReplicationState {\n        throw newRxError('IM2');\n    }\n}\n\n/**\n * returns a version of the schema that:\n * - disabled the keyCompression\n * - has no encryption\n * - has no attachments\n */\nfunction toCleanSchema(rxSchema: RxSchema): RxSchema {\n    const newSchemaJson = clone(rxSchema.jsonSchema);\n    newSchemaJson.keyCompression = false;\n    delete newSchemaJson.properties._rev;\n    delete newSchemaJson.properties._attachments;\n\n    const removeEncryption = (schema: any, complete: any) => {\n        delete schema.encrypted;\n        Object.values(schema)\n            .filter(val => typeof val === 'object')\n            .forEach(val => removeEncryption(val, complete));\n    };\n    removeEncryption(newSchemaJson, newSchemaJson);\n\n    return createRxSchema(newSchemaJson);\n}\n\n/**\n * replicates all documents from the parent to the inMemoryCollection\n * @return Promise that resolves with an array of the docs data\n */\nexport function replicateExistingDocuments(\n    fromCollection: RxCollection,\n    toCollection: RxCollection\n): Promise<any[]> {\n    const pouch: PouchDBInstance = fromCollection.storageInstance.internals.pouch;\n    return pouch.allDocs({\n        attachments: false,\n        include_docs: true\n    }).then(allRows => {\n        const docs = allRows\n            .rows\n            .map((row: any) => row.doc)\n            .filter((doc: any) => !doc.language) // do not replicate design-docs\n            .map((doc: any) => _handleFromStorageInstance(fromCollection, doc))\n            // swap back primary because keyCompression:false\n            .map((doc: any) => {\n                const primaryKey: string = fromCollection.schema.primaryPath as any;\n                return pouchSwapPrimaryToId(primaryKey, doc);\n            });\n\n        if (docs.length === 0) {\n            // nothing to replicate\n            return Promise.resolve([]);\n        }\n        else {\n            return toCollection.storageInstance.internals.pouch.bulkDocs({\n                docs\n            }, BULK_DOC_OPTIONS_FALSE)\n                .then(() => docs);\n        }\n    });\n}\n\n/**\n * sets the indexes from the schema at the pouchdb\n */\nexport function setIndexes(\n    schema: RxSchema,\n    pouch: PouchDBInstance,\n): Promise<any> {\n    return Promise.all(\n        schema.indexes\n            .map(indexAr => {\n                const indexName = 'idx-rxdb-' + indexAr.join(',');\n                return pouch.createIndex({\n                    ddoc: indexName,\n                    name: indexName,\n                    index: {\n                        fields: indexAr\n                    }\n                });\n            })\n    );\n}\n\n/**\n * returns an observable that streams all changes\n * as plain documents that have no encryption or keyCompression.\n * We use this to replicate changes from one collection to the other\n * @param prevFilter can be used to filter changes before doing anything\n * @return observable that emits document-data\n */\nexport function streamChangedDocuments(\n    rxCollection: RxCollection<any, any>,\n    prevFilter = (_i: any) => true\n): Observable<any> {\n    if (!(rxCollection as any)._doNotEmitSet) {\n        (rxCollection as any)._doNotEmitSet = new Set();\n    }\n\n    const observable = ObservableFromEvent(\n        rxCollection.storageInstance.internals.pouch\n            .changes({\n                since: 'now',\n                live: true,\n                include_docs: true\n            }),\n        'change'\n    )\n        .pipe(\n            /**\n             * we need this delay because with pouchdb 7.2.2\n             * it happened that _doNotEmitSet.add() from applyChangedDocumentToPouch()\n             * was called after the change was streamed downwards\n             * which then leads to a wrong detection\n             */\n            delay(0),\n            map((changeAr: any) => changeAr[0]), // rxjs emits an array for whatever reason\n            filter(change => {\n                // changes on the doNotEmit-list shell not be fired\n                const emitFlag = change.id + ':' + change.doc._rev;\n                if ((rxCollection as any)._doNotEmitSet.has(emitFlag)) {\n                    return false;\n                } else {\n                    return true;\n                }\n            }),\n            filter(change => prevFilter(change)),\n            map(change => _handleFromStorageInstance(rxCollection, change.doc)),\n            map(d => {\n                const primaryKey: string = rxCollection.schema.primaryPath as any;\n                return pouchSwapIdToPrimary(primaryKey, d);\n            })\n        );\n    return observable;\n}\n\n/**\n * writes the doc-data into the pouchdb of the collection\n * without changeing the revision\n */\nexport function applyChangedDocumentToPouch(\n    rxCollection: RxCollection<any, any>,\n    docData: any\n): Promise<any> {\n    if (!(rxCollection as any)._doNotEmitSet) {\n        (rxCollection as any)._doNotEmitSet = new Set();\n    }\n\n    const primaryKey: string = rxCollection.schema.primaryPath as any;\n\n    let transformedDoc = _handleToStorageInstance(rxCollection, docData);\n    transformedDoc = pouchSwapPrimaryToId(\n        primaryKey,\n        transformedDoc\n    );\n\n    return rxCollection.storageInstance.internals.pouch.get(transformedDoc._id)\n        .then((oldDoc: any) => transformedDoc._rev = oldDoc._rev)\n        .catch(() => {\n            // doc not found, do not use a revision\n            delete transformedDoc._rev;\n        }).then(() => rxCollection.storageInstance.internals.pouch.bulkDocs({\n            docs: [transformedDoc]\n        }, BULK_DOC_OPTIONS))\n        .then((bulkRet: any) => {\n            if (bulkRet.length > 0 && !(bulkRet[0] as PouchBulkDocResultRow).ok) {\n                throw new Error(JSON.stringify(bulkRet[0]));\n            }\n            // set the flag so this does not appear in the own event-stream again\n            const emitFlag = transformedDoc._id + ':' + (bulkRet[0] as PouchBulkDocResultRow).rev;\n            (rxCollection as any)._doNotEmitSet.add(emitFlag);\n\n            // remove from the list later to not have a memory-leak\n            setTimeout(() => (rxCollection as any)._doNotEmitSet.delete(emitFlag), 30 * 1000);\n\n            return transformedDoc;\n        });\n}\n\nlet INIT_DONE = false;\n/**\n * called in the proto of RxCollection\n */\nexport async function inMemory(\n    this: RxCollection\n): Promise<RxCollection> {\n    if (!INIT_DONE) {\n        INIT_DONE = true;\n        // ensure memory-adapter is added\n        if (!(PouchDB as any).adapters || !(PouchDB as any).adapters.memory) {\n            throw newRxError('IM1');\n        }\n    }\n\n    if (collectionCacheMap.has(this)) {\n        // already exists for this collection -> wait until synced\n        return collectionPromiseCacheMap.get(this)\n            .then(() => collectionCacheMap.get(this));\n    }\n\n    const col = new InMemoryRxCollection(this);\n    await prepareInMemoryRxCollection(col);\n\n    const preparePromise = col.prepareChild();\n    collectionCacheMap.set(this, col);\n    collectionPromiseCacheMap.set(this, preparePromise);\n\n    return preparePromise.then(() => col) as any;\n}\n\nexport async function prepareInMemoryRxCollection(instance: InMemoryRxCollection<any, {}>): Promise<void> {\n    const memoryStorage = getRxStoragePouch('memory', {});\n    instance.storageInstance = await memoryStorage.createStorageInstance({\n        databaseName: 'rxdb-in-memory',\n        collectionName: randomCouchString(10),\n        schema: instance.schema.jsonSchema,\n        options: instance.pouchSettings,\n        idleQueue: instance.database.idleQueue\n    });\n    (instance as any).pouch = instance.storageInstance.internals.pouch;\n}\n\n\nexport const rxdb = true;\nexport const prototypes = {\n    RxCollection: (proto: any) => {\n        proto.inMemory = inMemory;\n    }\n};\n\nexport const RxDBInMemoryPlugin: RxPlugin = {\n    name: 'in-memory',\n    rxdb,\n    prototypes\n};\n"]}
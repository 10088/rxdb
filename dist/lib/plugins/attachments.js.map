{"version":3,"sources":["../../../src/plugins/attachments.ts"],"names":[],"mappings":"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","file":"attachments.js","sourcesContent":["import {\n    map\n} from 'rxjs/operators';\nimport {\n    blobBufferUtil,\n    flatClone\n} from './../util';\nimport {\n    newRxError\n} from '../rx-error';\nimport type {\n    RxDocument,\n    RxPlugin,\n    BlobBuffer,\n    OldRxCollection,\n    RxDocumentWriteData,\n    RxAttachmentData,\n    RxDocumentData,\n    RxAttachmentCreator,\n    RxAttachmentWriteData\n} from '../types';\nimport type { RxSchema } from '../rx-schema';\nimport { writeSingle } from '../rx-storage-helper';\nimport { _handleToStorageInstance } from '../rx-collection-helper';\n\nfunction ensureSchemaSupportsAttachments(doc: any) {\n    const schemaJson = doc.collection.schema.jsonSchema;\n    if (!schemaJson.attachments) {\n        throw newRxError('AT1', {\n            link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n        });\n    }\n}\n\nconst _assignMethodsToAttachment = function (attachment: any) {\n    Object\n        .entries(attachment.doc.collection.attachments)\n        .forEach(([funName, fun]) => {\n            Object.defineProperty(attachment, funName, {\n                get: () => (fun as any).bind(attachment)\n            });\n        });\n};\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport class RxAttachment {\n    public doc: RxDocument;\n    public id: string;\n    public type: string;\n    public length: number;\n    public digest: string;\n    constructor({\n        doc,\n        id,\n        type,\n        length,\n        digest\n    }: any) {\n        this.doc = doc;\n        this.id = id;\n        this.type = type;\n        this.length = length;\n        this.digest = digest;\n\n        _assignMethodsToAttachment(this);\n    }\n\n    async remove(): Promise<void> {\n        this.doc._atomicQueue = this.doc._atomicQueue\n            .then(async () => {\n                const docWriteData: RxDocumentWriteData<{}> = flatClone(this.doc._data);\n                docWriteData._attachments = flatClone(docWriteData._attachments);\n                delete docWriteData._attachments[this.id];\n\n                const writeResult: RxDocumentData<any> = await writeSingle(\n                    this.doc.collection.storageInstance,\n                    {\n                        previous: _handleToStorageInstance(this.doc.collection, flatClone(this.doc._data)),\n                        document: _handleToStorageInstance(this.doc.collection, docWriteData)\n                    }\n                );\n\n                const newData = flatClone(this.doc._data);\n                newData._rev = writeResult._rev;\n                newData._attachments = writeResult._attachments;\n                this.doc._dataSync$.next(newData);\n\n            });\n        return this.doc._atomicQueue;\n    }\n\n    /**\n     * returns the data for the attachment\n     */\n    async getData(): Promise<BlobBuffer> {\n        const plainData = await this.doc.collection.storageInstance.getAttachmentData(\n            this.doc.primary,\n            this.id\n        );\n        if (shouldEncrypt(this.doc.collection.schema)) {\n            const dataString = await blobBufferUtil.toString(plainData);\n            const ret = blobBufferUtil.createBlobBuffer(\n                this.doc.collection._crypter._decryptString(dataString),\n                this.type as any\n            );\n            return ret;\n        } else {\n            return plainData;\n        }\n    }\n\n    getStringData(): Promise<string> {\n        return this.getData().then(bufferBlob => blobBufferUtil.toString(bufferBlob));\n    }\n}\n\nexport function fromStorageInstanceResult(\n    id: string,\n    attachmentData: RxAttachmentData,\n    rxDocument: RxDocument\n) {\n    return new RxAttachment({\n        doc: rxDocument,\n        id,\n        type: attachmentData.type,\n        length: attachmentData.length,\n        digest: attachmentData.digest\n    });\n}\n\nfunction shouldEncrypt(schema: RxSchema): boolean {\n    return !!(schema.jsonSchema.attachments && schema.jsonSchema.attachments.encrypted);\n}\n\nexport async function putAttachment(\n    this: RxDocument,\n    {\n        id,\n        data,\n        type = 'text/plain'\n    }: RxAttachmentCreator,\n    /**\n     * If set to true, the write will be skipped\n     * when the attachment already contains the same data.\n     */\n    skipIfSame: boolean = true\n): Promise<RxAttachment> {\n    ensureSchemaSupportsAttachments(this);\n\n    /**\n     * Then encryption plugin is only able to encrypt strings,\n     * so unpack as string first.\n     */\n\n    if (shouldEncrypt(this.collection.schema)) {\n        const dataString = await blobBufferUtil.toString(data);\n        const encrypted = this.collection._crypter._encryptString(dataString);\n        data = blobBufferUtil.createBlobBuffer(encrypted, 'text/plain');\n    }\n\n    this._atomicQueue = this._atomicQueue\n        .then(async () => {\n            if (skipIfSame && this._data._attachments && this._data._attachments[id]) {\n                const currentMeta = this._data._attachments[id];\n                const newHash = await this.collection.database.storage.hash(data);\n                if (currentMeta.type === type && currentMeta.digest === newHash) {\n                    // skip because same data and same type\n                    return this.getAttachment(id);\n                }\n            }\n\n            const docWriteData: RxDocumentWriteData<{}> = flatClone(this._data);\n            docWriteData._attachments = flatClone(docWriteData._attachments);\n            docWriteData._attachments[id] = {\n                type,\n                data: data\n            };\n\n            const writeRow = {\n                previous: _handleToStorageInstance(this.collection, flatClone(this._data)),\n                document: _handleToStorageInstance(this.collection, flatClone(docWriteData))\n            };\n\n            const writeResult = await writeSingle(\n                this.collection.storageInstance,\n                writeRow\n            );\n\n            const attachmentData = writeResult._attachments[id];\n            const attachment = fromStorageInstanceResult(\n                id,\n                attachmentData,\n                this\n            );\n\n            const newData = flatClone(this._data);\n            newData._rev = writeResult._rev;\n            newData._attachments = writeResult._attachments;\n            this._dataSync$.next(newData);\n\n            return attachment;\n        });\n    return this._atomicQueue;\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(\n    this: RxDocument,\n    id: string\n): RxAttachment | null {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n    if (!docData._attachments || !docData._attachments[id])\n        return null;\n\n    const attachmentData = docData._attachments[id];\n    const attachment = fromStorageInstanceResult(\n        id,\n        attachmentData,\n        this\n    );\n    return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments(\n    this: RxDocument\n): RxAttachment[] {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n\n    // if there are no attachments, the field is missing\n    if (!docData._attachments) {\n        return [];\n    }\n    return Object.keys(docData._attachments)\n        .map(id => {\n            return fromStorageInstanceResult(\n                id,\n                docData._attachments[id],\n                this\n            );\n        });\n}\n\nexport async function preMigrateDocument<RxDocType>(\n    data: {\n        docData: RxDocumentData<RxDocType>;\n        oldCollection: OldRxCollection\n    }\n): Promise<void> {\n    const attachments = data.docData._attachments;\n    if (attachments) {\n        const mustDecrypt = !!shouldEncrypt(data.oldCollection.schema);\n        const newAttachments: { [attachmentId: string]: RxAttachmentWriteData } = {};\n        await Promise.all(\n            Object.keys(attachments).map(async (attachmentId) => {\n                const attachment: RxAttachmentData = attachments[attachmentId];\n                const docPrimary: string = (data.docData as any)[data.oldCollection.schema.primaryPath];\n\n                let rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId);\n                if (mustDecrypt) {\n                    rawAttachmentData = await blobBufferUtil.toString(rawAttachmentData)\n                        .then(dataString => blobBufferUtil.createBlobBuffer(\n                            data.oldCollection._crypter._decryptString(dataString),\n                            (attachment as RxAttachmentData).type as any\n                        ));\n                }\n\n                newAttachments[attachmentId] = {\n                    type: attachment.type,\n                    data: rawAttachmentData\n                };\n            })\n        );\n\n        /**\n         * Hooks mutate the input\n         * instead of returning stuff\n         */\n        (data.docData as RxDocumentWriteData<RxDocType>)._attachments = newAttachments;\n    }\n}\n\nexport async function postMigrateDocument(_action: any): Promise<void> {\n    /**\n     * No longer needed because\n     * we store the attachemnts data buffers directly in the document.\n     */\n    return;\n}\n\nexport const rxdb = true;\nexport const prototypes = {\n    RxDocument: (proto: any) => {\n        proto.putAttachment = putAttachment;\n        proto.getAttachment = getAttachment;\n        proto.allAttachments = allAttachments;\n        Object.defineProperty(proto, 'allAttachments$', {\n            get: function allAttachments$() {\n                return this._dataSync$\n                    .pipe(\n                        map((data: any) => {\n                            if (!data['_attachments']) {\n                                return {};\n                            }\n                            return data['_attachments'];\n                        }),\n                        map((attachmentsData: any) => Object.entries(\n                            attachmentsData\n                        )),\n                        map(entries => {\n                            return (entries as any)\n                                .map(([id, attachmentData]: any) => {\n                                    return fromStorageInstanceResult(\n                                        id,\n                                        attachmentData,\n                                        this\n                                    );\n                                });\n                        })\n                    );\n            }\n        });\n    }\n};\nexport const overwritable = {};\nexport const hooks = {\n    preMigrateDocument,\n    postMigrateDocument\n};\n\nexport const RxDBAttachmentsPlugin: RxPlugin = {\n    name: 'attachments',\n    rxdb,\n    prototypes,\n    overwritable,\n    hooks\n};\n"]}
{"version":3,"file":"attachments.js","names":["ensureSchemaSupportsAttachments","doc","schemaJson","collection","schema","jsonSchema","attachments","newRxError","link","preMigrateDocument","data","docData","_attachments","newAttachments","Promise","all","Object","keys","map","attachmentId","attachment","docPrimary","oldCollection","primaryPath","storageInstance","getAttachmentData","rawAttachmentData","hookInput","database","type","plainData","runAsyncPluginHooks","digest","length","putAttachment","attachmentData","skipIfSame","dataSize","blobBufferUtil","size","storageStatics","storage","statics","toBase64String","dataString","hookAttachmentData","id","hashAttachmentData","then","hash","hashKey","newDigest","_atomicQueue","_data","currentMeta","getAttachment","docWriteData","flatCloneDocWithMeta","flatClone","_rev","createRevision","writeRow","previous","document","writeSingle","writeResult","fromStorageInstanceResult","newData","_dataSync$","next","_assignMethodsToAttachment","entries","forEach","funName","fun","defineProperty","get","bind","RxAttachment","remove","getData","primary","plainDataBase64","createBlobBufferFromBase64","getStringData","toString","rxDocument","getValue","allAttachments","postMigrateDocument","_action","PROMISE_RESOLVE_VOID","RxDBAttachmentsPlugin","name","rxdb","prototypes","RxDocument","proto","allAttachments$","pipe","attachmentsData","overwritable","hooks","after"],"sources":["../../../src/plugins/attachments.ts"],"sourcesContent":["import {\n    map\n} from 'rxjs/operators';\n\nimport {\n    blobBufferUtil,\n    createRevision,\n    flatClone,\n    PROMISE_RESOLVE_VOID\n} from './../util';\nimport {\n    newRxError\n} from '../rx-error';\nimport type {\n    RxDocument,\n    RxPlugin,\n    BlobBuffer,\n    OldRxCollection,\n    RxDocumentWriteData,\n    RxAttachmentData,\n    RxDocumentData,\n    RxAttachmentCreator,\n    RxAttachmentWriteData\n} from '../types';\nimport { flatCloneDocWithMeta, hashAttachmentData, writeSingle } from '../rx-storage-helper';\nimport { runAsyncPluginHooks } from '../hooks';\n\nfunction ensureSchemaSupportsAttachments(doc: any) {\n    const schemaJson = doc.collection.schema.jsonSchema;\n    if (!schemaJson.attachments) {\n        throw newRxError('AT1', {\n            link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n        });\n    }\n}\n\nconst _assignMethodsToAttachment = function (attachment: any) {\n    Object\n        .entries(attachment.doc.collection.attachments)\n        .forEach(([funName, fun]) => {\n            Object.defineProperty(attachment, funName, {\n                get: () => (fun as any).bind(attachment)\n            });\n        });\n};\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport class RxAttachment {\n    public doc: RxDocument;\n    public id: string;\n    public type: string;\n    public length: number;\n    public digest: string;\n    constructor({\n        doc,\n        id,\n        type,\n        length,\n        digest\n    }: any) {\n        this.doc = doc;\n        this.id = id;\n        this.type = type;\n        this.length = length;\n        this.digest = digest;\n\n        _assignMethodsToAttachment(this);\n    }\n\n    remove(): Promise<void> {\n        this.doc._atomicQueue = this.doc._atomicQueue\n            .then(async () => {\n                const docWriteData: RxDocumentWriteData<{}> = flatCloneDocWithMeta(this.doc._data);\n                docWriteData._attachments = flatClone(docWriteData._attachments);\n                delete docWriteData._attachments[this.id];\n\n\n                docWriteData._rev = createRevision(docWriteData, this.doc._data);\n\n                const writeResult: RxDocumentData<any> = await writeSingle(\n                    this.doc.collection.storageInstance,\n                    {\n                        previous: flatClone(this.doc._data), // TODO do we need a flatClone here?\n                        document: docWriteData\n                    },\n                    'attachment-remove'\n                );\n\n                const newData = flatClone(this.doc._data);\n                newData._rev = writeResult._rev;\n                newData._attachments = writeResult._attachments;\n                this.doc._dataSync$.next(newData);\n\n            });\n        return this.doc._atomicQueue;\n    }\n\n    /**\n     * returns the data for the attachment\n     */\n    async getData(): Promise<BlobBuffer> {\n        const plainDataBase64 = await this.doc.collection.storageInstance.getAttachmentData(\n            this.doc.primary,\n            this.id\n        );\n        const hookInput = {\n            database: this.doc.collection.database,\n            schema: this.doc.collection.schema.jsonSchema,\n            type: this.type,\n            plainData: plainDataBase64\n        };\n        await runAsyncPluginHooks('postReadAttachment', hookInput);\n        const ret = await blobBufferUtil.createBlobBufferFromBase64(\n            hookInput.plainData,\n            this.type as any\n        );\n        return ret;\n    }\n\n    async getStringData(): Promise<string> {\n        const data = await this.getData();\n        const asString = await blobBufferUtil.toString(data);\n        return asString;\n    }\n}\n\nexport function fromStorageInstanceResult(\n    id: string,\n    attachmentData: RxAttachmentData,\n    rxDocument: RxDocument\n) {\n    return new RxAttachment({\n        doc: rxDocument,\n        id,\n        type: attachmentData.type,\n        length: attachmentData.length,\n        digest: attachmentData.digest\n    });\n}\n\nexport async function putAttachment(\n    this: RxDocument,\n    attachmentData: RxAttachmentCreator,\n    /**\n     * If set to true, the write will be skipped\n     * when the attachment already contains the same data.\n     */\n    skipIfSame: boolean = true\n): Promise<RxAttachment> {\n    ensureSchemaSupportsAttachments(this);\n\n\n    const dataSize = blobBufferUtil.size(attachmentData.data);\n    const storageStatics = this.collection.database.storage.statics;\n    const dataString = await blobBufferUtil.toBase64String(attachmentData.data);\n\n    const hookAttachmentData = {\n        id: attachmentData.id,\n        type: attachmentData.type,\n        data: dataString\n    };\n    await runAsyncPluginHooks('preWriteAttachment', {\n        database: this.collection.database,\n        schema: this.collection.schema.jsonSchema,\n        attachmentData: hookAttachmentData\n    });\n\n    const {\n        id, data, type\n    } = hookAttachmentData;\n\n    const newDigest = await hashAttachmentData(\n        dataString,\n        storageStatics\n    ).then(hash => storageStatics.hashKey + '-' + hash);\n\n    this._atomicQueue = this._atomicQueue\n        .then(async () => {\n            if (skipIfSame && this._data._attachments && this._data._attachments[id]) {\n                const currentMeta = this._data._attachments[id];\n                if (currentMeta.type === type && currentMeta.digest === newDigest) {\n                    // skip because same data and same type\n                    return this.getAttachment(id);\n                }\n            }\n\n            const docWriteData: RxDocumentWriteData<{}> = flatCloneDocWithMeta(this._data);\n            docWriteData._attachments = flatClone(docWriteData._attachments);\n\n            docWriteData._attachments[id] = {\n                digest: newDigest,\n                length: dataSize,\n                type,\n                data\n            };\n\n            docWriteData._rev = createRevision(docWriteData, this._data);\n\n            const writeRow = {\n                previous: flatClone(this._data),\n                document: flatClone(docWriteData)\n            };\n\n            const writeResult = await writeSingle(\n                this.collection.storageInstance,\n                writeRow,\n                'attachment-put'\n            );\n\n            const attachmentData = writeResult._attachments[id];\n            const attachment = fromStorageInstanceResult(\n                id,\n                attachmentData,\n                this\n            );\n\n            const newData = flatClone(this._data);\n            newData._rev = writeResult._rev;\n            newData._attachments = writeResult._attachments;\n            this._dataSync$.next(newData);\n\n            return attachment;\n        });\n    return this._atomicQueue;\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(\n    this: RxDocument,\n    id: string\n): RxAttachment | null {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n    if (!docData._attachments || !docData._attachments[id])\n        return null;\n\n    const attachmentData = docData._attachments[id];\n    const attachment = fromStorageInstanceResult(\n        id,\n        attachmentData,\n        this\n    );\n    return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments(\n    this: RxDocument\n): RxAttachment[] {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n\n    // if there are no attachments, the field is missing\n    if (!docData._attachments) {\n        return [];\n    }\n    return Object.keys(docData._attachments)\n        .map(id => {\n            return fromStorageInstanceResult(\n                id,\n                docData._attachments[id],\n                this\n            );\n        });\n}\n\nexport async function preMigrateDocument<RxDocType>(\n    data: {\n        docData: RxDocumentData<RxDocType>;\n        oldCollection: OldRxCollection\n    }\n): Promise<void> {\n    const attachments = data.docData._attachments;\n    if (attachments) {\n        const newAttachments: { [attachmentId: string]: RxAttachmentWriteData } = {};\n        await Promise.all(\n            Object.keys(attachments).map(async (attachmentId) => {\n                const attachment: RxAttachmentData = attachments[attachmentId];\n                const docPrimary: string = (data.docData as any)[data.oldCollection.schema.primaryPath];\n\n                let rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId);\n\n                const hookInput = {\n                    database: data.oldCollection.database,\n                    schema: data.oldCollection.schema.jsonSchema,\n                    type: attachment.type,\n                    plainData: rawAttachmentData\n                };\n                await runAsyncPluginHooks('postReadAttachment', hookInput);\n                rawAttachmentData = hookInput.plainData;\n\n                newAttachments[attachmentId] = {\n                    digest: attachment.digest,\n                    length: attachment.length,\n                    type: attachment.type,\n                    data: rawAttachmentData\n                };\n            })\n        );\n\n        /**\n         * Hooks mutate the input\n         * instead of returning stuff\n         */\n        (data.docData as RxDocumentWriteData<RxDocType>)._attachments = newAttachments;\n    }\n}\n\nexport function postMigrateDocument(_action: any): Promise<void> {\n    /**\n     * No longer needed because\n     * we store the attachemnts data buffers directly in the document.\n     */\n    return PROMISE_RESOLVE_VOID;\n}\n\nexport const RxDBAttachmentsPlugin: RxPlugin = {\n    name: 'attachments',\n    rxdb: true,\n    prototypes: {\n        RxDocument: (proto: any) => {\n            proto.putAttachment = putAttachment;\n            proto.getAttachment = getAttachment;\n            proto.allAttachments = allAttachments;\n            Object.defineProperty(proto, 'allAttachments$', {\n                get: function allAttachments$() {\n                    return this._dataSync$\n                        .pipe(\n                            map((data: any) => {\n                                if (!data['_attachments']) {\n                                    return {};\n                                }\n                                return data['_attachments'];\n                            }),\n                            map((attachmentsData: any) => Object.entries(\n                                attachmentsData\n                            )),\n                            map(entries => {\n                                return (entries as any)\n                                    .map(([id, attachmentData]: any) => {\n                                        return fromStorageInstanceResult(\n                                            id,\n                                            attachmentData,\n                                            this\n                                        );\n                                    });\n                            })\n                        );\n                }\n            });\n        }\n    },\n    overwritable: {},\n    hooks: {\n        preMigrateDocument: {\n            after: preMigrateDocument\n        },\n        postMigrateDocument: {\n            after: postMigrateDocument\n        }\n    }\n};\n"],"mappings":"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"}
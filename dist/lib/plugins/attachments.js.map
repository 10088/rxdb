{"version":3,"sources":["../../../src/plugins/attachments.ts"],"names":["ensureSchemaSupportsAttachments","doc","schemaJson","collection","schema","jsonSchema","attachments","link","_assignMethodsToAttachment","attachment","Object","entries","forEach","funName","fun","defineProperty","get","bind","RxAttachment","id","type","length","digest","remove","_atomicQueue","then","docWriteData","_data","_attachments","storageInstance","previous","document","writeResult","newData","_rev","_dataSync$","next","getData","getAttachmentData","primary","plainData","shouldEncrypt","blobBufferUtil","toString","dataString","ret","createBlobBuffer","_crypter","_decryptString","getStringData","bufferBlob","fromStorageInstanceResult","attachmentData","rxDocument","encrypted","putAttachment","data","skipIfSame","_encryptString","statics","database","storage","currentMeta","hash","newHash","newDigest","hashKey","getAttachment","getAttachmentDataMeta","meta","writeRow","docData","getValue","allAttachments","keys","map","preMigrateDocument","mustDecrypt","oldCollection","newAttachments","Promise","all","attachmentId","docPrimary","primaryPath","rawAttachmentData","postMigrateDocument","_action","storageStatics","size","rxdb","prototypes","RxDocument","proto","allAttachments$","pipe","attachmentsData","overwritable","hooks","RxDBAttachmentsPlugin","name"],"mappings":"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","sourcesContent":["import {\n    map\n} from 'rxjs/operators';\nimport {\n    blobBufferUtil,\n    flatClone\n} from './../util';\nimport {\n    newRxError\n} from '../rx-error';\nimport type {\n    RxDocument,\n    RxPlugin,\n    BlobBuffer,\n    OldRxCollection,\n    RxDocumentWriteData,\n    RxAttachmentData,\n    RxDocumentData,\n    RxAttachmentCreator,\n    RxAttachmentWriteData,\n    RxStorageStatics,\n    RxAttachmentDataMeta\n} from '../types';\nimport type { RxSchema } from '../rx-schema';\nimport { writeSingle } from '../rx-storage-helper';\nimport { _handleToStorageInstance } from '../rx-collection-helper';\n\nfunction ensureSchemaSupportsAttachments(doc: any) {\n    const schemaJson = doc.collection.schema.jsonSchema;\n    if (!schemaJson.attachments) {\n        throw newRxError('AT1', {\n            link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n        });\n    }\n}\n\nconst _assignMethodsToAttachment = function (attachment: any) {\n    Object\n        .entries(attachment.doc.collection.attachments)\n        .forEach(([funName, fun]) => {\n            Object.defineProperty(attachment, funName, {\n                get: () => (fun as any).bind(attachment)\n            });\n        });\n};\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport class RxAttachment {\n    public doc: RxDocument;\n    public id: string;\n    public type: string;\n    public length: number;\n    public digest: string;\n    constructor({\n        doc,\n        id,\n        type,\n        length,\n        digest\n    }: any) {\n        this.doc = doc;\n        this.id = id;\n        this.type = type;\n        this.length = length;\n        this.digest = digest;\n\n        _assignMethodsToAttachment(this);\n    }\n\n    async remove(): Promise<void> {\n        this.doc._atomicQueue = this.doc._atomicQueue\n            .then(async () => {\n                const docWriteData: RxDocumentWriteData<{}> = flatClone(this.doc._data);\n                docWriteData._attachments = flatClone(docWriteData._attachments);\n                delete docWriteData._attachments[this.id];\n\n                const writeResult: RxDocumentData<any> = await writeSingle(\n                    this.doc.collection.storageInstance,\n                    {\n                        previous: _handleToStorageInstance(this.doc.collection, flatClone(this.doc._data)),\n                        document: _handleToStorageInstance(this.doc.collection, docWriteData)\n                    }\n                );\n\n                const newData = flatClone(this.doc._data);\n                newData._rev = writeResult._rev;\n                newData._attachments = writeResult._attachments;\n                this.doc._dataSync$.next(newData);\n\n            });\n        return this.doc._atomicQueue;\n    }\n\n    /**\n     * returns the data for the attachment\n     */\n    async getData(): Promise<BlobBuffer> {\n        const plainData = await this.doc.collection.storageInstance.getAttachmentData(\n            this.doc.primary,\n            this.id\n        );\n        if (shouldEncrypt(this.doc.collection.schema)) {\n            const dataString = await blobBufferUtil.toString(plainData);\n            const ret = blobBufferUtil.createBlobBuffer(\n                this.doc.collection._crypter._decryptString(dataString),\n                this.type as any\n            );\n            return ret;\n        } else {\n            return plainData;\n        }\n    }\n\n    getStringData(): Promise<string> {\n        return this.getData().then(bufferBlob => blobBufferUtil.toString(bufferBlob));\n    }\n}\n\nexport function fromStorageInstanceResult(\n    id: string,\n    attachmentData: RxAttachmentData,\n    rxDocument: RxDocument\n) {\n    return new RxAttachment({\n        doc: rxDocument,\n        id,\n        type: attachmentData.type,\n        length: attachmentData.length,\n        digest: attachmentData.digest\n    });\n}\n\nfunction shouldEncrypt(schema: RxSchema): boolean {\n    return !!(schema.jsonSchema.attachments && schema.jsonSchema.attachments.encrypted);\n}\n\nexport async function putAttachment(\n    this: RxDocument,\n    {\n        id,\n        data,\n        type = 'text/plain'\n    }: RxAttachmentCreator,\n    /**\n     * If set to true, the write will be skipped\n     * when the attachment already contains the same data.\n     */\n    skipIfSame: boolean = true\n): Promise<RxAttachment> {\n    ensureSchemaSupportsAttachments(this);\n\n    /**\n     * Then encryption plugin is only able to encrypt strings,\n     * so unpack as string first.\n     */\n\n    if (shouldEncrypt(this.collection.schema)) {\n        const dataString = await blobBufferUtil.toString(data);\n        const encrypted = this.collection._crypter._encryptString(dataString);\n        data = blobBufferUtil.createBlobBuffer(encrypted, 'text/plain');\n    }\n\n    const statics = this.collection.database.storage.statics;\n    this._atomicQueue = this._atomicQueue\n        .then(async () => {\n            if (skipIfSame && this._data._attachments && this._data._attachments[id]) {\n                const currentMeta = this._data._attachments[id];\n                const newHash = await statics.hash(data);\n                const newDigest = statics.hashKey + '-' + newHash;\n                if (currentMeta.type === type && currentMeta.digest === newDigest) {\n                    // skip because same data and same type\n                    return this.getAttachment(id);\n                }\n            }\n\n            const docWriteData: RxDocumentWriteData<{}> = flatClone(this._data);\n            docWriteData._attachments = flatClone(docWriteData._attachments);\n\n            const meta = await getAttachmentDataMeta(\n                this.collection.database.storage.statics,\n                data\n            );\n            docWriteData._attachments[id] = {\n                digest: meta.digest,\n                length: meta.length,\n                type,\n                data: data\n            };\n\n            const writeRow = {\n                previous: _handleToStorageInstance(this.collection, flatClone(this._data)),\n                document: _handleToStorageInstance(this.collection, flatClone(docWriteData))\n            };\n\n            const writeResult = await writeSingle(\n                this.collection.storageInstance,\n                writeRow\n            );\n\n            const attachmentData = writeResult._attachments[id];\n            const attachment = fromStorageInstanceResult(\n                id,\n                attachmentData,\n                this\n            );\n\n            const newData = flatClone(this._data);\n            newData._rev = writeResult._rev;\n            newData._attachments = writeResult._attachments;\n            this._dataSync$.next(newData);\n\n            return attachment;\n        });\n    return this._atomicQueue;\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(\n    this: RxDocument,\n    id: string\n): RxAttachment | null {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n    if (!docData._attachments || !docData._attachments[id])\n        return null;\n\n    const attachmentData = docData._attachments[id];\n    const attachment = fromStorageInstanceResult(\n        id,\n        attachmentData,\n        this\n    );\n    return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments(\n    this: RxDocument\n): RxAttachment[] {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n\n    // if there are no attachments, the field is missing\n    if (!docData._attachments) {\n        return [];\n    }\n    return Object.keys(docData._attachments)\n        .map(id => {\n            return fromStorageInstanceResult(\n                id,\n                docData._attachments[id],\n                this\n            );\n        });\n}\n\nexport async function preMigrateDocument<RxDocType>(\n    data: {\n        docData: RxDocumentData<RxDocType>;\n        oldCollection: OldRxCollection\n    }\n): Promise<void> {\n    const attachments = data.docData._attachments;\n    if (attachments) {\n        const mustDecrypt = !!shouldEncrypt(data.oldCollection.schema);\n        const newAttachments: { [attachmentId: string]: RxAttachmentWriteData } = {};\n        await Promise.all(\n            Object.keys(attachments).map(async (attachmentId) => {\n                const attachment: RxAttachmentData = attachments[attachmentId];\n                const docPrimary: string = (data.docData as any)[data.oldCollection.schema.primaryPath];\n\n                let rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId);\n                if (mustDecrypt) {\n                    rawAttachmentData = await blobBufferUtil.toString(rawAttachmentData)\n                        .then(dataString => blobBufferUtil.createBlobBuffer(\n                            data.oldCollection._crypter._decryptString(dataString),\n                            (attachment as RxAttachmentData).type as any\n                        ));\n                }\n\n                const meta = await getAttachmentDataMeta(\n                    data.oldCollection.database.storage.statics,\n                    rawAttachmentData\n                );\n                newAttachments[attachmentId] = {\n                    digest: meta.digest,\n                    length: meta.length,\n                    type: attachment.type,\n                    data: rawAttachmentData\n                };\n            })\n        );\n\n        /**\n         * Hooks mutate the input\n         * instead of returning stuff\n         */\n        (data.docData as RxDocumentWriteData<RxDocType>)._attachments = newAttachments;\n    }\n}\n\nexport async function postMigrateDocument(_action: any): Promise<void> {\n    /**\n     * No longer needed because\n     * we store the attachemnts data buffers directly in the document.\n     */\n    return;\n}\n\nexport async function getAttachmentDataMeta(\n    storageStatics: RxStorageStatics,\n    data: BlobBuffer\n): Promise<RxAttachmentDataMeta> {\n    const hash = await storageStatics.hash(data);\n    const length = blobBufferUtil.size(data);\n    return {\n        digest: storageStatics.hashKey + '-' + hash,\n        length\n    }\n}\n\nexport const rxdb = true;\nexport const prototypes = {\n    RxDocument: (proto: any) => {\n        proto.putAttachment = putAttachment;\n        proto.getAttachment = getAttachment;\n        proto.allAttachments = allAttachments;\n        Object.defineProperty(proto, 'allAttachments$', {\n            get: function allAttachments$() {\n                return this._dataSync$\n                    .pipe(\n                        map((data: any) => {\n                            if (!data['_attachments']) {\n                                return {};\n                            }\n                            return data['_attachments'];\n                        }),\n                        map((attachmentsData: any) => Object.entries(\n                            attachmentsData\n                        )),\n                        map(entries => {\n                            return (entries as any)\n                                .map(([id, attachmentData]: any) => {\n                                    return fromStorageInstanceResult(\n                                        id,\n                                        attachmentData,\n                                        this\n                                    );\n                                });\n                        })\n                    );\n            }\n        });\n    }\n};\nexport const overwritable = {};\nexport const hooks = {\n    preMigrateDocument,\n    postMigrateDocument\n};\n\nexport const RxDBAttachmentsPlugin: RxPlugin = {\n    name: 'attachments',\n    rxdb,\n    prototypes,\n    overwritable,\n    hooks\n};\n"],"file":"attachments.js"}
{"version":3,"file":"query-planner.js","names":["INDEX_MAX","String","fromCharCode","INDEX_MIN","Infinity","getQueryPlan","schema","query","primaryPath","getPrimaryFieldOfPrimaryKey","primaryKey","selector","indexes","slice","index","push","optimalSortIndex","sort","map","sortField","Object","keys","optimalSortIndexCompareString","join","hasDescSorting","find","values","currentBestQuality","currentBestQueryPlan","forEach","opts","indexField","matcher","operators","length","startKey","endKey","inclusiveStart","inclusiveEnd","matcherOpts","operator","isLogicalOperator","operatorValue","partialOpts","getMatcherQueryOpts","assign","queryPlan","startKeys","opt","endKeys","sortFieldsSameAsIndexFields","quality","rateQueryPlan","LOGICAL_OPERATORS","Set","has","Error","pointsPerMatchingKey","idxOfFirstMinStartKey","findIndex","keyValue","idxOfFirstMaxEndKey","pointsIfNoReSortMustBeDone"],"sources":["../../src/query-planner.ts"],"sourcesContent":["import { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport type {\n    FilledMangoQuery,\n    RxDocumentData,\n    RxJsonSchema,\n    RxQueryPlan,\n    RxQueryPlanerOpts\n} from './types';\n\n\nexport const INDEX_MAX = String.fromCharCode(65535);\nexport const INDEX_MIN = -Infinity;\n\n/**\n * Returns the query plan which contains\n * information about how to run the query\n * and which indexes to use.\n * \n * This is used in some storage like Memory, dexie.js and IndexedDB.\n */\nexport function getQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>\n): RxQueryPlan {\n    const primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    const selector = query.selector;\n\n    let indexes: string[][] = schema.indexes ? schema.indexes.slice(0) as any : [];\n    if (query.index) {\n        indexes = [query.index];\n    } else {\n        indexes.push([primaryPath]);\n    }\n\n    const optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);\n    const optimalSortIndexCompareString = optimalSortIndex.join(',');\n    /**\n     * Most storages do not support descending indexes\n     * so having a 'desc' in the sorting, means we always have to re-sort the results.\n     */\n    const hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc')\n\n    let currentBestQuality = -1;\n    let currentBestQueryPlan: RxQueryPlan | undefined;\n\n    indexes.forEach((index) => {\n        const opts: RxQueryPlanerOpts[] = index.map(indexField => {\n            const matcher = selector[indexField];\n            const operators = matcher ? Object.keys(matcher) : [];\n            if (\n                !matcher ||\n                !operators.length\n            ) {\n                return {\n                    startKey: INDEX_MIN,\n                    endKey: INDEX_MAX,\n                    inclusiveStart: true,\n                    inclusiveEnd: true\n                };\n            }\n\n            let matcherOpts: RxQueryPlanerOpts = {} as any;\n            operators.forEach(operator => {\n                if (isLogicalOperator(operator)) {\n                    const operatorValue = matcher[operator];\n                    const partialOpts = getMatcherQueryOpts(operator, operatorValue);\n                    matcherOpts = Object.assign(matcherOpts, partialOpts);\n                }\n            });\n\n            // fill missing attributes\n            if (typeof matcherOpts.startKey === 'undefined') {\n                matcherOpts.startKey = INDEX_MIN;\n            }\n            if (typeof matcherOpts.endKey === 'undefined') {\n                matcherOpts.endKey = INDEX_MAX;\n            }\n            if (typeof matcherOpts.inclusiveStart === 'undefined') {\n                matcherOpts.inclusiveStart = true;\n            }\n            if (typeof matcherOpts.inclusiveEnd === 'undefined') {\n                matcherOpts.inclusiveEnd = true;\n            }\n\n            return matcherOpts;\n        });\n\n        const queryPlan: RxQueryPlan = {\n            index,\n            startKeys: opts.map(opt => opt.startKey),\n            endKeys: opts.map(opt => opt.endKey),\n            inclusiveEnd: !opts.find(opt => !opt.inclusiveEnd),\n            inclusiveStart: !opts.find(opt => !opt.inclusiveStart),\n            sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === index.join(',')\n        };\n        const quality = rateQueryPlan(\n            schema,\n            query,\n            queryPlan\n        );\n        if (\n            (\n                quality > 0 &&\n                quality > currentBestQuality\n            ) ||\n            query.index\n        ) {\n            currentBestQuality = quality;\n            currentBestQueryPlan = queryPlan;\n        }\n    });\n\n    /**\n     * No index found, use the default index\n     */\n    if (!currentBestQueryPlan) {\n        return {\n            index: [primaryPath],\n            startKeys: [INDEX_MIN],\n            endKeys: [INDEX_MAX],\n            inclusiveEnd: true,\n            inclusiveStart: true,\n            sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === primaryPath\n        }\n    }\n\n    return currentBestQueryPlan;\n}\n\nconst LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);\nexport function isLogicalOperator(operator: string): boolean {\n    return LOGICAL_OPERATORS.has(operator);\n}\n\nexport function getMatcherQueryOpts(operator: string, operatorValue: any): Partial<RxQueryPlanerOpts> {\n    switch (operator) {\n        case '$eq':\n            return {\n                startKey: operatorValue,\n                endKey: operatorValue\n            };\n        case '$lte':\n            return {\n                endKey: operatorValue\n            };\n        case '$gte':\n            return {\n                startKey: operatorValue\n            };\n        case '$lt':\n            return {\n                endKey: operatorValue,\n                inclusiveEnd: false\n            };\n        case '$gt':\n            return {\n                startKey: operatorValue,\n                inclusiveStart: false\n            };\n        default:\n            throw new Error('SNH');\n    }\n}\n\n\n/**\n * Returns a number that determines the quality of the query plan.\n * Higher number means better query plan.\n */\nexport function rateQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>,\n    queryPlan: RxQueryPlan\n): number {\n    let quality: number = 0;\n\n    const pointsPerMatchingKey = 10;\n    const idxOfFirstMinStartKey = queryPlan.startKeys.findIndex(keyValue => keyValue === INDEX_MIN);\n    if (idxOfFirstMinStartKey > 0) {\n        quality = quality + (idxOfFirstMinStartKey * pointsPerMatchingKey)\n    }\n\n    const idxOfFirstMaxEndKey = queryPlan.endKeys.findIndex(keyValue => keyValue === INDEX_MAX);\n    if (idxOfFirstMaxEndKey > 0) {\n        quality = quality + (idxOfFirstMaxEndKey * pointsPerMatchingKey)\n    }\n\n    const pointsIfNoReSortMustBeDone = 5;\n    if (queryPlan.sortFieldsSameAsIndexFields) {\n        quality = quality + pointsIfNoReSortMustBeDone;\n    }\n\n    return quality;\n}\n"],"mappings":"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"}
{"version":3,"sources":["../../src/rx-schema-helper.ts"],"names":["getPseudoSchemaForVersion","version","primaryKey","pseudoSchema","type","properties","required","getSchemaByObjectPath","rxJsonSchema","path","usePath","replace","ret","objectPath","get","fillPrimaryKey","primaryPath","jsonSchema","documentData","cloned","newPrimary","getComposedPrimaryKeyOfDocumentData","existingPrimary","args","schema","getPrimaryFieldOfPrimaryKey","key","compositePrimary","fields","map","field","value","join","separator"],"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AASA;;AAEA;AACA;AACA;AACA;AACO,SAASA,yBAAT,CACHC,OADG,EAEHC,UAFG,EAGY;AAAA;;AACf,MAAMC,YAA6B,GAAG;AAClCF,IAAAA,OAAO,EAAPA,OADkC;AAElCG,IAAAA,IAAI,EAAE,QAF4B;AAGlCF,IAAAA,UAAU,EAAEA,UAHsB;AAIlCG,IAAAA,UAAU,iCACLH,UADK,IACQ;AACVE,MAAAA,IAAI,EAAE;AADI,KADR,cAJwB;AASlCE,IAAAA,QAAQ,EAAE,CAACJ,UAAD;AATwB,GAAtC;AAWA,SAAOC,YAAP;AACH;AAED;AACA;AACA;;;AACO,SAASI,qBAAT,CACHC,YADG,EAEHC,IAFG,EAGO;AACV,MAAIC,OAAe,GAAGD,IAAtB;AACAC,EAAAA,OAAO,GAAGA,OAAO,CAACC,OAAR,CAAgB,KAAhB,EAAuB,cAAvB,CAAV;AACAD,EAAAA,OAAO,GAAG,gBAAgBA,OAA1B;AACAA,EAAAA,OAAO,GAAG,oBAASA,OAAT,CAAV;;AAEA,MAAME,GAAG,GAAGC,uBAAWC,GAAX,CAAeN,YAAf,EAA6BE,OAA7B,CAAZ;;AACA,SAAOE,GAAP;AACH;;AAEM,SAASG,cAAT,CACHC,WADG,EAEHC,UAFG,EAGHC,YAHG,EAIc;AACjB,MAAMC,MAAM,GAAG,qBAAUD,YAAV,CAAf;AACA,MAAME,UAAU,GAAGC,mCAAmC,CAClDJ,UADkD,EAElDC,YAFkD,CAAtD;AAIA,MAAMI,eAAmC,GAAGJ,YAAY,CAACF,WAAD,CAAxD;;AACA,MACIM,eAAe,IACfA,eAAe,KAAKF,UAFxB,EAGE;AACE,UAAM,yBACF,OADE,EAEF;AACIG,MAAAA,IAAI,EAAE;AACFL,QAAAA,YAAY,EAAZA,YADE;AAEFI,QAAAA,eAAe,EAAfA,eAFE;AAGFF,QAAAA,UAAU,EAAVA;AAHE,OADV;AAMII,MAAAA,MAAM,EAAEP;AANZ,KAFE,CAAN;AAUH;;AAEAE,EAAAA,MAAD,CAAgBH,WAAhB,IAA+BI,UAA/B;AACA,SAAOD,MAAP;AACH;;AAEM,SAASM,2BAAT,CACHvB,UADG,EAEY;AACf,MAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AAChC,WAAOA,UAAP;AACH,GAFD,MAEO;AACH,WAAQA,UAAD,CAA+CwB,GAAtD;AACH;AACJ;AAED;AACA;AACA;;;AACO,SAASL,mCAAT,CACHJ,UADG,EAEHC,YAFG,EAGG;AACN,MAAI,OAAOD,UAAU,CAACf,UAAlB,KAAiC,QAArC,EAA+C;AAC3C,WAAQgB,YAAD,CAAsBD,UAAU,CAACf,UAAjC,CAAP;AACH;;AAED,MAAMyB,gBAAgD,GAAGV,UAAU,CAACf,UAApE;AACA,SAAOyB,gBAAgB,CAACC,MAAjB,CAAwBC,GAAxB,CAA4B,UAAAC,KAAK,EAAI;AACxC,QAAMC,KAAK,GAAGlB,uBAAWC,GAAX,CAAeI,YAAf,EAAoCY,KAApC,CAAd;;AACA,QAAI,OAAOC,KAAP,KAAiB,WAArB,EAAkC;AAC9B,YAAM,yBAAW,OAAX,EAAoB;AAAER,QAAAA,IAAI,EAAE;AAAEO,UAAAA,KAAK,EAALA,KAAF;AAASZ,UAAAA,YAAY,EAAZA;AAAT;AAAR,OAApB,CAAN;AACH;;AACD,WAAOa,KAAP;AACH,GANM,EAMJC,IANI,CAMCL,gBAAgB,CAACM,SANlB,CAAP;AAOH","sourcesContent":["import objectPath from 'object-path';\nimport { newRxError } from './rx-error';\nimport type {\n    CompositePrimaryKey,\n    JsonSchema,\n    PrimaryKey,\n    RxDocumentData,\n    RxJsonSchema,\n    StringKeys\n} from './types';\nimport { flatClone, trimDots } from './util';\n\n/**\n * Helper function to create a valid RxJsonSchema\n * with a given version.\n */\nexport function getPseudoSchemaForVersion<T = any>(\n    version: number,\n    primaryKey: StringKeys<T>\n): RxJsonSchema<T> {\n    const pseudoSchema: RxJsonSchema<T> = {\n        version,\n        type: 'object',\n        primaryKey: primaryKey as any,\n        properties: {\n            [primaryKey]: {\n                type: 'string'\n            }\n        } as any,\n        required: [primaryKey]\n    };\n    return pseudoSchema;\n}\n\n/**\n * Returns the sub-schema for a given path\n */\nexport function getSchemaByObjectPath<T = any>(\n    rxJsonSchema: RxJsonSchema<T>,\n    path: keyof T | string\n): JsonSchema {\n    let usePath: string = path as string;\n    usePath = usePath.replace(/\\./g, '.properties.');\n    usePath = 'properties.' + usePath;\n    usePath = trimDots(usePath);\n\n    const ret = objectPath.get(rxJsonSchema, usePath);\n    return ret;\n}\n\nexport function fillPrimaryKey<T>(\n    primaryPath: keyof T,\n    jsonSchema: RxJsonSchema<T>,\n    documentData: RxDocumentData<T>\n): RxDocumentData<T> {\n    const cloned = flatClone(documentData);\n    const newPrimary = getComposedPrimaryKeyOfDocumentData<T>(\n        jsonSchema,\n        documentData\n    );\n    const existingPrimary: string | undefined = documentData[primaryPath] as any;\n    if (\n        existingPrimary &&\n        existingPrimary !== newPrimary\n    ) {\n        throw newRxError(\n            'DOC19',\n            {\n                args: {\n                    documentData,\n                    existingPrimary,\n                    newPrimary,\n                },\n                schema: jsonSchema\n            });\n    }\n\n    (cloned as any)[primaryPath] = newPrimary;\n    return cloned;\n}\n\nexport function getPrimaryFieldOfPrimaryKey<RxDocType>(\n    primaryKey: PrimaryKey<RxDocType>\n): keyof RxDocType {\n    if (typeof primaryKey === 'string') {\n        return primaryKey as any;\n    } else {\n        return (primaryKey as CompositePrimaryKey<RxDocType>).key;\n    }\n}\n\n/**\n * Returns the composed primaryKey of a document by its data.\n */\nexport function getComposedPrimaryKeyOfDocumentData<RxDocType>(\n    jsonSchema: RxJsonSchema<RxDocType>,\n    documentData: Partial<RxDocType>\n): string {\n    if (typeof jsonSchema.primaryKey === 'string') {\n        return (documentData as any)[jsonSchema.primaryKey];\n    }\n\n    const compositePrimary: CompositePrimaryKey<RxDocType> = jsonSchema.primaryKey as any;\n    return compositePrimary.fields.map(field => {\n        const value = objectPath.get(documentData as any, field as string);\n        if (typeof value === 'undefined') {\n            throw newRxError('DOC18', { args: { field, documentData } });\n        }\n        return value;\n    }).join(compositePrimary.separator);\n}\n"],"file":"rx-schema-helper.js"}
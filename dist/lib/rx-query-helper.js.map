{"version":3,"file":"rx-query-helper.js","names":["normalizeMangoQuery","schema","mangoQuery","primaryKey","getPrimaryFieldOfPrimaryKey","normalizedMangoQuery","flatClone","skip","selector","Object","entries","forEach","field","matcher","$eq","index","indexAr","Array","isArray","slice","includes","push","sort","map","indexes","fieldsWithLogicalOperator","Set","hasLogical","keys","find","operator","isLogicalOperator","add","currentFieldsAmount","currentBestIndexForSort","useIndex","isMaybeReadonlyArray","firstWrongIndex","findIndex","indexField","has","isPrimaryInSort","p","firstPropertyNameOfObject"],"sources":["../../src/rx-query-helper.ts"],"sourcesContent":["import { isLogicalOperator } from './query-planner';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport type {\n    FilledMangoQuery,\n    MangoQuery,\n    RxDocumentData,\n    RxJsonSchema\n} from './types';\nimport {\n    firstPropertyNameOfObject,\n    flatClone,\n    isMaybeReadonlyArray\n} from './util';\n\n/**\n * Normalize the query to ensure we have all fields set\n * and queries that represent the same query logic are detected as equal by the caching.\n */\nexport function normalizeMangoQuery<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    mangoQuery: MangoQuery<RxDocType>\n): FilledMangoQuery<RxDocType> {\n    const primaryKey: string = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    const normalizedMangoQuery: FilledMangoQuery<RxDocType> = flatClone(mangoQuery) as any;\n\n    if (typeof normalizedMangoQuery.skip !== 'number') {\n        normalizedMangoQuery.skip = 0;\n    }\n\n    if (!normalizedMangoQuery.selector) {\n        normalizedMangoQuery.selector = {};\n    } else {\n        normalizedMangoQuery.selector = flatClone(normalizedMangoQuery.selector);\n        /**\n         * In mango query, it is possible to have an\n         * equals comparison by directly assigning a value\n         * to a property, without the '$eq' operator.\n         * Like:\n         * selector: {\n         *   foo: 'bar'\n         * }\n         * For normalization, we have to normalize this\n         * so our checks can perform properly.\n         */\n        Object\n            .entries(normalizedMangoQuery.selector)\n            .forEach(([field, matcher]) => {\n                if (typeof matcher !== 'object' || matcher === null) {\n                    normalizedMangoQuery.selector[field] = {\n                        $eq: matcher\n                    };\n                }\n            });\n    }\n\n    /**\n     * Ensure that if an index is specified,\n     * the primaryKey is inside of it.\n     */\n    if (normalizedMangoQuery.index) {\n        const indexAr = Array.isArray(normalizedMangoQuery.index) ? normalizedMangoQuery.index.slice(0) : [normalizedMangoQuery.index];\n        if (!indexAr.includes(primaryKey)) {\n            indexAr.push(primaryKey);\n        }\n        normalizedMangoQuery.index = indexAr;\n    }\n\n    /**\n     * To ensure a deterministic sorting,\n     * we have to ensure the primary key is always part\n     * of the sort query.\n     * Primary sorting is added as last sort parameter,\n     * similiar to how we add the primary key to indexes that do not have it.\n     * \n     */\n    if (!normalizedMangoQuery.sort) {\n        /**\n         * If no sort is given at all,\n         * we can assume that the user does not care about sort order at al.\n         * \n         * we cannot just use the primary key as sort parameter\n         * because it would likely cause the query to run over the primary key index\n         * which has a bad performance in most cases.\n         */\n        if (normalizedMangoQuery.index) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field: string) => ({ [field as any]: 'asc' } as any));\n        } else {\n            /**\n             * Find the index that best matches the fields with the logical operators\n             */\n            if (schema.indexes) {\n                const fieldsWithLogicalOperator: Set<string> = new Set();\n                Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n                    let hasLogical = false;\n                    if (typeof matcher === 'object' && matcher !== null) {\n                        hasLogical = !!Object.keys(matcher).find(operator => isLogicalOperator(operator));\n                    } else {\n                        hasLogical = true;\n                    }\n                    if (hasLogical) {\n                        fieldsWithLogicalOperator.add(field);\n                    }\n                });\n\n\n                let currentFieldsAmount = -1;\n                let currentBestIndexForSort: string[] | readonly string[] | undefined;\n                schema.indexes.forEach(index => {\n                    const useIndex = isMaybeReadonlyArray(index) ? index : [index];\n                    const firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));\n                    if (\n                        firstWrongIndex > 0 &&\n                        firstWrongIndex > currentFieldsAmount\n                    ) {\n                        currentFieldsAmount = firstWrongIndex;\n                        currentBestIndexForSort = useIndex;\n                    }\n                });\n                if (currentBestIndexForSort) {\n                    normalizedMangoQuery.sort = currentBestIndexForSort.map((field: string) => ({ [field as any]: 'asc' } as any));\n                }\n\n            }\n\n            /**\n             * Fall back to the primary key as sort order\n             * if no better one has been found\n             */\n            if (!normalizedMangoQuery.sort) {\n                normalizedMangoQuery.sort = [{ [primaryKey]: 'asc' }] as any;\n            }\n        }\n    } else {\n        const isPrimaryInSort = normalizedMangoQuery.sort\n            .find(p => firstPropertyNameOfObject(p) === primaryKey);\n        if (!isPrimaryInSort) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);\n            normalizedMangoQuery.sort.push({ [primaryKey]: 'asc' } as any);\n        }\n    }\n\n    return normalizedMangoQuery;\n}\n"],"mappings":"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"}
{"version":3,"file":"rx-query-helper.js","names":["isLogicalOperator","getPrimaryFieldOfPrimaryKey","firstPropertyNameOfObject","flatClone","isMaybeReadonlyArray","normalizeMangoQuery","schema","mangoQuery","primaryKey","normalizedMangoQuery","skip","selector","Object","entries","forEach","field","matcher","$eq","index","indexAr","Array","isArray","slice","includes","push","sort","map","indexes","fieldsWithLogicalOperator","Set","hasLogical","keys","find","operator","add","currentFieldsAmount","currentBestIndexForSort","useIndex","firstWrongIndex","findIndex","indexField","has","isPrimaryInSort","p"],"sources":["../../src/rx-query-helper.ts"],"sourcesContent":["import { isLogicalOperator } from './query-planner';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport type {\n    FilledMangoQuery,\n    MangoQuery,\n    RxDocumentData,\n    RxJsonSchema\n} from './types';\nimport {\n    firstPropertyNameOfObject,\n    flatClone,\n    isMaybeReadonlyArray\n} from './util';\n\n/**\n * Normalize the query to ensure we have all fields set\n * and queries that represent the same query logic are detected as equal by the caching.\n */\nexport function normalizeMangoQuery<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    mangoQuery: MangoQuery<RxDocType>\n): FilledMangoQuery<RxDocType> {\n    const primaryKey: string = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    const normalizedMangoQuery: FilledMangoQuery<RxDocType> = flatClone(mangoQuery) as any;\n\n    if (typeof normalizedMangoQuery.skip !== 'number') {\n        normalizedMangoQuery.skip = 0;\n    }\n\n    if (!normalizedMangoQuery.selector) {\n        normalizedMangoQuery.selector = {};\n    } else {\n        normalizedMangoQuery.selector = flatClone(normalizedMangoQuery.selector);\n        /**\n         * In mango query, it is possible to have an\n         * equals comparison by directly assigning a value\n         * to a property, without the '$eq' operator.\n         * Like:\n         * selector: {\n         *   foo: 'bar'\n         * }\n         * For normalization, we have to normalize this\n         * so our checks can perform properly.\n         */\n        Object\n            .entries(normalizedMangoQuery.selector)\n            .forEach(([field, matcher]) => {\n                if (typeof matcher !== 'object' || matcher === null) {\n                    normalizedMangoQuery.selector[field] = {\n                        $eq: matcher\n                    };\n                }\n            });\n    }\n\n    /**\n     * Ensure that if an index is specified,\n     * the primaryKey is inside of it.\n     */\n    if (normalizedMangoQuery.index) {\n        const indexAr = Array.isArray(normalizedMangoQuery.index) ? normalizedMangoQuery.index.slice(0) : [normalizedMangoQuery.index];\n        if (!indexAr.includes(primaryKey)) {\n            indexAr.push(primaryKey);\n        }\n        normalizedMangoQuery.index = indexAr;\n    }\n\n    /**\n     * To ensure a deterministic sorting,\n     * we have to ensure the primary key is always part\n     * of the sort query.\n     * Primary sorting is added as last sort parameter,\n     * similiar to how we add the primary key to indexes that do not have it.\n     * \n     */\n    if (!normalizedMangoQuery.sort) {\n        /**\n         * If no sort is given at all,\n         * we can assume that the user does not care about sort order at al.\n         * \n         * we cannot just use the primary key as sort parameter\n         * because it would likely cause the query to run over the primary key index\n         * which has a bad performance in most cases.\n         */\n        if (normalizedMangoQuery.index) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field: string) => ({ [field as any]: 'asc' } as any));\n        } else {\n            /**\n             * Find the index that best matches the fields with the logical operators\n             */\n            if (schema.indexes) {\n                const fieldsWithLogicalOperator: Set<string> = new Set();\n                Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n                    let hasLogical = false;\n                    if (typeof matcher === 'object' && matcher !== null) {\n                        hasLogical = !!Object.keys(matcher).find(operator => isLogicalOperator(operator));\n                    } else {\n                        hasLogical = true;\n                    }\n                    if (hasLogical) {\n                        fieldsWithLogicalOperator.add(field);\n                    }\n                });\n\n\n                let currentFieldsAmount = -1;\n                let currentBestIndexForSort: string[] | readonly string[] | undefined;\n                schema.indexes.forEach(index => {\n                    const useIndex = isMaybeReadonlyArray(index) ? index : [index];\n                    const firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));\n                    if (\n                        firstWrongIndex > 0 &&\n                        firstWrongIndex > currentFieldsAmount\n                    ) {\n                        currentFieldsAmount = firstWrongIndex;\n                        currentBestIndexForSort = useIndex;\n                    }\n                });\n                if (currentBestIndexForSort) {\n                    normalizedMangoQuery.sort = currentBestIndexForSort.map((field: string) => ({ [field as any]: 'asc' } as any));\n                }\n\n            }\n\n            /**\n             * Fall back to the primary key as sort order\n             * if no better one has been found\n             */\n            if (!normalizedMangoQuery.sort) {\n                normalizedMangoQuery.sort = [{ [primaryKey]: 'asc' }] as any;\n            }\n        }\n    } else {\n        const isPrimaryInSort = normalizedMangoQuery.sort\n            .find(p => firstPropertyNameOfObject(p) === primaryKey);\n        if (!isPrimaryInSort) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);\n            normalizedMangoQuery.sort.push({ [primaryKey]: 'asc' } as any);\n        }\n    }\n\n    return normalizedMangoQuery;\n}\n"],"mappings":"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"}
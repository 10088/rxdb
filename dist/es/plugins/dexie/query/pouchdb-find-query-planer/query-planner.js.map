{"version":3,"sources":["../../../../../../src/plugins/dexie/query/pouchdb-find-query-planer/query-planner.ts"],"names":["getUserFields","getKey","compare","arrayEquals","arrayToObject","flatten","max","mergeObjects","oneArrayIsStrictSubArrayOfOther","oneArrayIsSubArrayOfOther","oneSetIsSubArrayOfOther","uniq","COLLATE_LO","COLLATE_HI","SHORT_CIRCUIT_QUERY","queryOpts","limit","startkey","endkey","inMemoryFields","checkFieldInIndex","index","field","indexFields","def","fields","map","i","len","length","indexField","userOperatorLosesPrecision","selector","matcher","userOperator","sortFieldsByIndex","userFields","slice","sort","a","b","aIdx","indexOf","bIdx","Number","MAX_VALUE","getBasicInMemoryFields","needToFilterInMemory","getInMemoryFieldsFromNe","Object","keys","forEach","operator","push","getInMemoryFields","coreInMemoryFields","result","checkIndexFieldsMatch","sortOrder","sortMatches","selectorMatches","logicalMatchers","isNonLogicalMatcher","checkFieldsLogicallySound","firstField","isInvalidNe","checkIndexMatches","fieldsMatch","findMatchingIndexes","indexes","filter","findBestMatchingIndex","useIndex","matchingIndexes","Error","error","message","toString","defaultIndex","defaultUsed","userFieldsMap","scoreIndex","score","useIndexDdoc","useIndexName","find","ddoc","name","getSingleFieldQueryOptsFor","userValue","key","inclusive_end","inclusive_start","getSingleFieldCoreQueryPlan","userOperators","combinedOpts","newQueryOpts","getMultiFieldCoreQueryPlan","getMultiFieldQueryOpts","inclusiveStart","inclusiveEnd","finish","some","usingGtlt","previousKeys","previousWasEq","previousWasSame","gtltLostSpecificity","j","newOpts","res","shouldShortCircuit","values","val","getDefaultQueryPlan","_idx","getCoreQueryPlan","planQuery","request","assign","userFieldsRes","use_index","coreQueryPlan"],"mappings":"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","sourcesContent":["import {\n    getUserFields\n} from './utils';\nimport {\n    getKey,\n    compare\n} from 'pouchdb-selector-core';\nimport {\n    arrayEquals,\n    arrayToObject,\n    flatten,\n    max,\n    mergeObjects,\n    oneArrayIsStrictSubArrayOfOther,\n    oneArrayIsSubArrayOfOther,\n    oneSetIsSubArrayOfOther,\n    uniq\n} from './main-utils';\n\n// couchdb lowest collation value\nconst COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\n// const COLLATE_HI = { '\\uffff': {} };\n// overwritten COLLATE_HI for dexie.js RxStorage.\nconst COLLATE_HI = '\\uffff';\n\n\nconst SHORT_CIRCUIT_QUERY = {\n    queryOpts: { limit: 0, startkey: COLLATE_HI, endkey: COLLATE_LO },\n    inMemoryFields: [],\n};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index: any, field: string) {\n    const indexFields = index.def.fields.map(getKey);\n    for (let i = 0, len = indexFields.length; i < len; i++) {\n        const indexField = indexFields[i];\n        if (field === indexField) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector: any, field: string) {\n    const matcher = selector[field];\n    const userOperator = getKey(matcher);\n\n    return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields: any[], index: any) {\n    const indexFields = index.def.fields.map(getKey);\n\n    return userFields.slice().sort(function (a, b) {\n        let aIdx = indexFields.indexOf(a);\n        let bIdx = indexFields.indexOf(b);\n        if (aIdx === -1) {\n            aIdx = Number.MAX_VALUE;\n        }\n        if (bIdx === -1) {\n            bIdx = Number.MAX_VALUE;\n        }\n        return compare(aIdx, bIdx);\n    });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index: any, selector: any, userFields: any) {\n\n    userFields = sortFieldsByIndex(userFields, index);\n\n    // check if any of the user selectors lose precision\n    let needToFilterInMemory = false;\n    for (let i = 0, len = userFields.length; i < len; i++) {\n        const field = userFields[i];\n        if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n            return userFields.slice(i);\n        }\n        if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n            needToFilterInMemory = true;\n        }\n    }\n    return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector: any) {\n    const fields: any[] = [];\n    Object.keys(selector).forEach(function (field) {\n        const matcher = selector[field];\n        Object.keys(matcher).forEach(function (operator) {\n            if (operator === '$ne') {\n                fields.push(field);\n            }\n        });\n    });\n    return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields: any, index: any, selector: any, userFields: any) {\n    const result = (flatten as any)(\n        // in-memory fields reported as necessary by the query planner\n        coreInMemoryFields,\n        // combine with another pass that checks for any we may have missed\n        getBasicInMemoryFields(index, selector, userFields),\n        // combine with another pass that checks for $ne's\n        getInMemoryFieldsFromNe(selector)\n    );\n\n    return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields: any, sortOrder: any, fields: any) {\n    if (sortOrder) {\n        // array has to be a strict subarray of index array. furthermore,\n        // the sortOrder fields need to all be represented in the index\n        const sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n        const selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\n        return sortMatches && selectorMatches;\n    }\n\n    // all of the user's specified fields still need to be\n    // on the left side of the index array, although the order\n    // doesn't matter\n    return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nconst logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher: any) {\n    return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields: any, selector: any) {\n    const firstField = indexFields[0];\n    const matcher = selector[firstField];\n\n    if (typeof matcher === 'undefined') {\n        /* istanbul ignore next */\n        return true;\n    }\n\n    const isInvalidNe = Object.keys(matcher).length === 1 &&\n        getKey(matcher) === '$ne';\n\n    return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index: any, sortOrder: any, fields: any, selector: any) {\n\n    const indexFields = index.def.fields.map(getKey);\n\n    const fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n    if (!fieldsMatch) {\n        return false;\n    }\n\n    return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector: any, userFields: any, sortOrder: any, indexes: any) {\n    return indexes.filter(function (index: any) {\n        return checkIndexMatches(index, sortOrder, userFields, selector);\n    });\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector: any, userFields: any, sortOrder: any, indexes: any, useIndex: any) {\n\n    const matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n    if (matchingIndexes.length === 0) {\n        if (useIndex) {\n            throw new Error({\n                error: 'no_usable_index',\n                message: 'There is no index available for this selector.'\n            }.toString());\n        }\n        //return `all_docs` as a default index;\n        //I'm assuming that _all_docs is always first\n        const defaultIndex = indexes[0];\n        defaultIndex.defaultUsed = true;\n        return defaultIndex;\n    }\n    if (matchingIndexes.length === 1 && !useIndex) {\n        return matchingIndexes[0];\n    }\n\n    const userFieldsMap = arrayToObject(userFields);\n\n    function scoreIndex(index: any) {\n        const indexFields = index.def.fields.map(getKey);\n        let score = 0;\n        for (let i = 0, len = indexFields.length; i < len; i++) {\n            const indexField = indexFields[i];\n            if (userFieldsMap[indexField]) {\n                score++;\n            }\n        }\n        return score;\n    }\n\n    if (useIndex) {\n        const useIndexDdoc = '_design/' + useIndex[0];\n        const useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n        const index = matchingIndexes.find(function (index: any) {\n            if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n                return true;\n            }\n\n            if (index.ddoc === useIndexDdoc) {\n                /* istanbul ignore next */\n                return true;\n            }\n\n            return false;\n        });\n\n        if (!index) {\n            throw new Error({\n                error: 'unknown_error',\n                message: 'Could not find that index or could not use that index for the query'\n            }.toString());\n        }\n        return index;\n    }\n\n    return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator: any, userValue: any) {\n    switch (userOperator) {\n        case '$eq':\n            return { key: userValue };\n        case '$lte':\n            return { endkey: userValue };\n        case '$gte':\n            return { startkey: userValue };\n        case '$lt':\n            return {\n                endkey: userValue,\n                inclusive_end: false\n            };\n        case '$gt':\n            return {\n                startkey: userValue,\n                inclusive_start: false\n            };\n    }\n\n    return {\n        startkey: COLLATE_LO\n    };\n}\n\nfunction getSingleFieldCoreQueryPlan(selector: any, index: any) {\n    const field = getKey(index.def.fields[0]);\n    //ignoring this because the test to exercise the branch is skipped at the moment\n    /* istanbul ignore next */\n    const matcher = selector[field] || {};\n    const inMemoryFields: any[] = [];\n\n    const userOperators = Object.keys(matcher);\n\n    let combinedOpts: any;\n\n    userOperators.forEach(function (userOperator) {\n\n        if (isNonLogicalMatcher(userOperator)) {\n            inMemoryFields.push(field);\n        }\n\n        const userValue = matcher[userOperator];\n\n        const newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n        if (combinedOpts) {\n            combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n        } else {\n            combinedOpts = newQueryOpts;\n        }\n    });\n\n    return {\n        queryOpts: combinedOpts,\n        inMemoryFields: inMemoryFields\n    };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator: any, userValue: any) {\n    switch (userOperator) {\n        case '$eq':\n            return {\n                startkey: userValue,\n                endkey: userValue\n            };\n        case '$lte':\n            return {\n                endkey: userValue\n            };\n        case '$gte':\n            return {\n                startkey: userValue\n            };\n        case '$lt':\n            return {\n                endkey: userValue,\n                inclusive_end: false\n            };\n        case '$gt':\n            return {\n                startkey: userValue,\n                inclusive_start: false\n            };\n    }\n}\n\nfunction getMultiFieldQueryOpts(selector: any, index: any) {\n\n    const indexFields = index.def.fields.map(getKey);\n\n    let inMemoryFields: any[] = [];\n    const startkey = [];\n    const endkey = [];\n    let inclusiveStart: any;\n    let inclusiveEnd: any;\n\n\n    function finish(i: any) {\n\n        if (inclusiveStart !== false) {\n            startkey.push(COLLATE_LO);\n        }\n        if (inclusiveEnd !== false) {\n            endkey.push(COLLATE_HI);\n        }\n        // keep track of the fields where we lost specificity,\n        // and therefore need to filter in-memory\n        inMemoryFields = indexFields.slice(i);\n    }\n\n    for (let i = 0, len = indexFields.length; i < len; i++) {\n        const indexField = indexFields[i];\n\n        const matcher = selector[indexField];\n\n        if (!matcher || !Object.keys(matcher).length) { // fewer fields in user query than in index\n            finish(i);\n            break;\n        } else if (Object.keys(matcher).some(isNonLogicalMatcher)) { // non-logical are ignored\n            finish(i);\n            break;\n        } else if (i > 0) {\n            const usingGtlt = (\n                '$gt' in matcher || '$gte' in matcher ||\n                '$lt' in matcher || '$lte' in matcher);\n            const previousKeys = Object.keys(selector[indexFields[i - 1]]);\n            const previousWasEq = arrayEquals(previousKeys, ['$eq']);\n            const previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n            const gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n            if (gtltLostSpecificity) {\n                finish(i);\n                break;\n            }\n        }\n\n        const userOperators = Object.keys(matcher);\n\n        let combinedOpts: any = null;\n\n        for (let j = 0; j < userOperators.length; j++) {\n            const userOperator = userOperators[j];\n            const userValue = matcher[userOperator];\n\n            const newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n            if (combinedOpts) {\n                combinedOpts = mergeObjects([combinedOpts, newOpts]);\n            } else {\n                combinedOpts = newOpts;\n            }\n        }\n\n        startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n        endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n        if ('inclusive_start' in combinedOpts) {\n            inclusiveStart = combinedOpts.inclusive_start;\n        }\n        if ('inclusive_end' in combinedOpts) {\n            inclusiveEnd = combinedOpts.inclusive_end;\n        }\n    }\n\n    const res: any = {\n        startkey: startkey,\n        endkey: endkey\n    };\n\n    if (typeof inclusiveStart !== 'undefined') {\n        res.inclusive_start = inclusiveStart;\n    }\n    if (typeof inclusiveEnd !== 'undefined') {\n        res.inclusive_end = inclusiveEnd;\n    }\n\n    return {\n        queryOpts: res,\n        inMemoryFields: inMemoryFields\n    };\n}\n\nfunction shouldShortCircuit(selector: any) {\n    // We have a field to select from, but not a valid value\n    // this should result in a short circuited query \n    // just like the http adapter (couchdb) and mongodb\n    // see tests for issue #7810\n\n    const values = Object.values(selector);\n    return values.some(function (val: any) {\n        return typeof val === 'object' && Object.keys(val).length === 0;\n    });\n}\n\nfunction getDefaultQueryPlan(selector: any, _idx?: any) {\n    //using default index, so all fields need to be done in memory\n    return {\n        queryOpts: { startkey: null },\n        inMemoryFields: [Object.keys(selector)]\n    };\n}\n\nfunction getCoreQueryPlan(selector: any, index: any) {\n    if (index.defaultUsed) {\n        return getDefaultQueryPlan(selector, index);\n    }\n\n    if (index.def.fields.length === 1) {\n        // one field in index, so the value was indexed as a singleton\n        return getSingleFieldCoreQueryPlan(selector, index);\n    }\n    // else index has multiple fields, so the value was indexed as an array\n    return getMultiFieldQueryOpts(selector, index);\n}\n\nexport function planQuery(request: any, indexes: any) {\n\n    const selector = request.selector;\n    const sort = request.sort;\n\n    if (shouldShortCircuit(selector)) {\n        return Object.assign({}, SHORT_CIRCUIT_QUERY, { index: indexes[0] });\n    }\n\n    const userFieldsRes = getUserFields(selector, sort);\n\n    const userFields = userFieldsRes.fields;\n    const sortOrder = userFieldsRes.sortOrder;\n    const index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\n    const coreQueryPlan = getCoreQueryPlan(selector, index);\n    const queryOpts = coreQueryPlan.queryOpts;\n    const coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n    const inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n    const res = {\n        queryOpts: queryOpts,\n        index: index,\n        inMemoryFields: inMemoryFields\n    };\n    return res;\n}\n"],"file":"query-planner.js"}
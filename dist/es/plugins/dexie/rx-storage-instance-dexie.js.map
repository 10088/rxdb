{"version":3,"file":"rx-storage-instance-dexie.js","names":["Subject","now","PROMISE_RESOLVE_VOID","RX_META_LWT_MINIMUM","sortDocumentsByLastWriteTime","lastOfArray","ensureNotFalsy","closeDexieDb","fromDexieToStorage","fromStorageToDexie","getDexieDbWithTables","getDocsInDb","RX_STORAGE_NAME_DEXIE","dexieQuery","getPrimaryFieldOfPrimaryKey","categorizeBulkWriteRows","getNewestOfDocumentStates","addRxStorageMultiInstanceSupport","newRxError","instanceId","RxStorageInstanceDexie","storage","databaseName","collectionName","schema","internals","options","settings","changes$","closed","primaryPath","primaryKey","bulkWrite","documentWrites","context","ensureNotClosed","state","ret","success","error","documentKeys","map","writeRow","document","categorized","dexieDb","transaction","dexieTable","dexieDeletedTable","docsInDbMap","Map","docsInDbWithInternals","forEach","docWithDexieInternals","doc","set","errors","err","documentId","bulkPutDocs","bulkRemoveDocs","bulkPutDeletedDocs","bulkRemoveDeletedDocs","bulkInsertDocs","row","docId","push","bulkUpdateDocs","_deleted","previous","args","Promise","all","length","bulkPut","d","bulkDelete","eventBulk","events","lastState","Object","values","checkpoint","id","lwt","_meta","endTime","event","next","findDocumentsById","ids","deleted","idx","documentInDb","docsInDb","bulkGet","query","preparedQuery","getChangedDocumentsSince","limit","sinceLwt","sinceId","table","where","above","toArray","changedDocuments","changedDocsNormal","changedDocsDeleted","changedDocs","concat","slice","lastDoc","documents","remove","clear","close","changeStream","asObservable","cleanup","minimumDeletedTime","maxDeletionTime","below","toRemove","removeIds","getAttachmentData","_documentId","_attachmentId","Error","complete","conflictResultionTasks","resolveConflictResultionTask","_taskSolution","createDexieStorageInstance","params","instance","resolve"],"sources":["../../../../src/plugins/dexie/rx-storage-instance-dexie.ts"],"sourcesContent":["import {\n    Subject,\n    Observable\n} from 'rxjs';\nimport {\n    now,\n    PROMISE_RESOLVE_VOID,\n    RX_META_LWT_MINIMUM,\n    sortDocumentsByLastWriteTime,\n    lastOfArray,\n    ensureNotFalsy\n} from '../../util';\nimport type {\n    RxStorageInstance,\n    RxStorageChangeEvent,\n    RxDocumentData,\n    BulkWriteRow,\n    RxStorageBulkWriteResponse,\n    RxStorageQueryResult,\n    RxJsonSchema,\n    RxStorageInstanceCreationParams,\n    EventBulk,\n    StringKeys,\n    RxDocumentDataById,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxStorageDefaultCheckpoint,\n    CategorizeBulkWriteRowsOutput\n} from '../../types';\nimport {\n    DexiePreparedQuery,\n    DexieSettings,\n    DexieStorageInternals\n} from '../../types/plugins/dexie';\nimport { RxStorageDexie } from './rx-storage-dexie';\nimport {\n    closeDexieDb,\n    fromDexieToStorage,\n    fromStorageToDexie,\n    getDexieDbWithTables,\n    getDocsInDb,\n    RX_STORAGE_NAME_DEXIE\n} from './dexie-helper';\nimport { dexieQuery } from './dexie-query';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport { categorizeBulkWriteRows, getNewestOfDocumentStates } from '../../rx-storage-helper';\nimport { addRxStorageMultiInstanceSupport } from '../../rx-storage-multiinstance';\nimport { newRxError } from '../../rx-error';\n\nlet instanceId = now();\n\nexport class RxStorageInstanceDexie<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    DexieStorageInternals,\n    DexieSettings,\n    RxStorageDefaultCheckpoint\n> {\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = new Subject();\n    public readonly instanceId = instanceId++;\n    public closed = false;\n\n    constructor(\n        public readonly storage: RxStorageDexie,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: DexieStorageInternals,\n        public readonly options: Readonly<DexieSettings>,\n        public readonly settings: DexieSettings\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n    }\n\n    async bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            success: {},\n            error: {}\n        };\n\n        const documentKeys: string[] = documentWrites.map(writeRow => writeRow.document[this.primaryPath] as any);\n        let categorized: CategorizeBulkWriteRowsOutput<RxDocType> | undefined = null as any;\n        await state.dexieDb.transaction(\n            'rw',\n            state.dexieTable,\n            state.dexieDeletedTable,\n            async () => {\n                const docsInDbMap = new Map<string, RxDocumentData<RxDocType>>();\n                const docsInDbWithInternals = await getDocsInDb<RxDocType>(this.internals, documentKeys);\n                docsInDbWithInternals.forEach(docWithDexieInternals => {\n                    const doc = docWithDexieInternals ? fromDexieToStorage(docWithDexieInternals) : docWithDexieInternals;\n                    if (doc) {\n                        docsInDbMap.set(doc[this.primaryPath], doc);\n                    }\n                    return doc;\n                });\n\n                categorized = categorizeBulkWriteRows<RxDocType>(\n                    this,\n                    this.primaryPath as any,\n                    docsInDbMap,\n                    documentWrites,\n                    context\n                );\n                categorized.errors.forEach(err => {\n                    ret.error[err.documentId] = err;\n                });\n\n                /**\n                 * Batch up the database operations\n                 * so we can later run them in bulk.\n                 */\n                const bulkPutDocs: any[] = [];\n                const bulkRemoveDocs: string[] = [];\n                const bulkPutDeletedDocs: any[] = [];\n                const bulkRemoveDeletedDocs: string[] = [];\n\n                categorized.bulkInsertDocs.forEach(row => {\n                    const docId: string = (row.document as any)[this.primaryPath];\n                    ret.success[docId] = row.document;\n                    bulkPutDocs.push(row.document);\n                });\n                categorized.bulkUpdateDocs.forEach(row => {\n                    const docId: string = (row.document as any)[this.primaryPath];\n                    ret.success[docId] = row.document;\n                    if (\n                        row.document._deleted &&\n                        (row.previous && !row.previous._deleted)\n                    ) {\n                        // newly deleted\n                        bulkRemoveDocs.push(docId);\n                        bulkPutDeletedDocs.push(row.document);\n                    } else if (\n                        row.document._deleted &&\n                        row.previous && row.previous._deleted\n                    ) {\n                        // deleted was modified but is still deleted\n                        bulkPutDeletedDocs.push(row.document);\n                    } else if (!row.document._deleted) {\n                        // non-deleted was changed\n                        bulkPutDocs.push(row.document);\n                    } else {\n                        throw newRxError('SNH', { args: { row } });\n                    }\n                });\n\n                await Promise.all([\n                    bulkPutDocs.length > 0 ? state.dexieTable.bulkPut(bulkPutDocs.map(d => fromStorageToDexie(d))) : PROMISE_RESOLVE_VOID,\n                    bulkRemoveDocs.length > 0 ? state.dexieTable.bulkDelete(bulkRemoveDocs) : PROMISE_RESOLVE_VOID,\n                    bulkPutDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkPut(bulkPutDeletedDocs.map(d => fromStorageToDexie(d))) : PROMISE_RESOLVE_VOID,\n                    bulkRemoveDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkDelete(bulkRemoveDeletedDocs) : PROMISE_RESOLVE_VOID\n                ]);\n            });\n\n        if (ensureNotFalsy(categorized).eventBulk.events.length > 0) {\n            const lastState = getNewestOfDocumentStates(\n                this.primaryPath as any,\n                Object.values(ret.success)\n            );\n            ensureNotFalsy(categorized).eventBulk.checkpoint = {\n                id: lastState[this.primaryPath],\n                lwt: lastState._meta.lwt\n            };\n            const endTime = now();\n            ensureNotFalsy(categorized).eventBulk.events.forEach(event => (event as any).endTime = endTime);\n            this.changes$.next(ensureNotFalsy(categorized).eventBulk);\n        }\n\n        return ret;\n    }\n\n    async findDocumentsById(\n        ids: string[],\n        deleted: boolean\n    ): Promise<RxDocumentDataById<RxDocType>> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        const ret: RxDocumentDataById<RxDocType> = {};\n\n        await state.dexieDb.transaction(\n            'r',\n            state.dexieTable,\n            state.dexieDeletedTable,\n            async () => {\n                let docsInDb: RxDocumentData<RxDocType>[];\n                if (deleted) {\n                    docsInDb = await getDocsInDb<RxDocType>(this.internals, ids);\n                } else {\n                    docsInDb = await state.dexieTable.bulkGet(ids)\n                }\n                ids.forEach((id, idx) => {\n                    const documentInDb = docsInDb[idx];\n                    if (\n                        documentInDb &&\n                        (!documentInDb._deleted || deleted)\n                    ) {\n                        ret[id] = fromDexieToStorage(documentInDb);\n                    }\n                });\n            });\n        return ret;\n    }\n\n    query(preparedQuery: DexiePreparedQuery<RxDocType>): Promise<RxStorageQueryResult<RxDocType>> {\n        ensureNotClosed(this);\n        return dexieQuery(\n            this,\n            preparedQuery\n        );\n    }\n\n    async getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: RxStorageDefaultCheckpoint\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        checkpoint: RxStorageDefaultCheckpoint;\n    }> {\n        ensureNotClosed(this);\n        const sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n        const sinceId = checkpoint ? checkpoint.id : '';\n        const state = await this.internals;\n\n\n        const [changedDocsNormal, changedDocsDeleted] = await Promise.all(\n            [\n                state.dexieTable,\n                state.dexieDeletedTable\n            ].map(async (table) => {\n                const query = table\n                    .where('[_meta.lwt+' + this.primaryPath + ']')\n                    .above([sinceLwt, sinceId])\n                    .limit(limit);\n                const changedDocuments: RxDocumentData<RxDocType>[] = await query.toArray();\n                return changedDocuments.map(d => fromDexieToStorage(d));\n            })\n        );\n        let changedDocs = changedDocsNormal.concat(changedDocsDeleted);\n\n        changedDocs = sortDocumentsByLastWriteTime(this.primaryPath as any, changedDocs);\n        changedDocs = changedDocs.slice(0, limit);\n\n        const lastDoc = lastOfArray(changedDocs);\n        return {\n            documents: changedDocs,\n            checkpoint: lastDoc ? {\n                id: lastDoc[this.primaryPath] as any,\n                lwt: lastDoc._meta.lwt\n            } : checkpoint ? checkpoint : {\n                id: '',\n                lwt: 0\n            }\n        };\n    }\n\n    async remove(): Promise<void> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        await Promise.all([\n            state.dexieDeletedTable.clear(),\n            state.dexieTable.clear()\n        ]);\n        return this.close();\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\n        ensureNotClosed(this);\n        return this.changes$.asObservable();\n    }\n\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        await state.dexieDb.transaction(\n            'rw',\n            state.dexieDeletedTable,\n            async () => {\n                const maxDeletionTime = now() - minimumDeletedTime;\n                const toRemove = await state.dexieDeletedTable\n                    .where('_meta.lwt')\n                    .below(maxDeletionTime)\n                    .toArray();\n                const removeIds: string[] = toRemove.map(doc => doc[this.primaryPath]);\n                await state.dexieDeletedTable.bulkDelete(removeIds);\n            }\n        );\n\n        /**\n         * TODO instead of deleting all deleted docs at once,\n         * only clean up some of them and return false if there are more documents to clean up.\n         * This ensures that when many documents have to be purged,\n         * we do not block the more important tasks too long.\n         */\n        return true;\n    }\n\n    getAttachmentData(_documentId: string, _attachmentId: string): Promise<string> {\n        ensureNotClosed(this);\n        throw new Error('Attachments are not implemented in the dexie RxStorage. Make a pull request.');\n    }\n\n    close(): Promise<void> {\n        ensureNotClosed(this);\n        this.closed = true;\n        this.changes$.complete();\n        closeDexieDb(this.internals);\n        return PROMISE_RESOLVE_VOID;\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return new Subject();\n    }\n    async resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> { }\n\n}\n\n\nexport function createDexieStorageInstance<RxDocType>(\n    storage: RxStorageDexie,\n    params: RxStorageInstanceCreationParams<RxDocType, DexieSettings>,\n    settings: DexieSettings\n): Promise<RxStorageInstanceDexie<RxDocType>> {\n    const internals = getDexieDbWithTables(\n        params.databaseName,\n        params.collectionName,\n        settings,\n        params.schema\n    );\n\n    const instance = new RxStorageInstanceDexie(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n\n    addRxStorageMultiInstanceSupport(\n        RX_STORAGE_NAME_DEXIE,\n        params,\n        instance\n    );\n\n    return Promise.resolve(instance);\n}\n\n\n\nfunction ensureNotClosed(\n    instance: RxStorageInstanceDexie<any>\n) {\n    if (instance.closed) {\n        throw new Error('RxStorageInstanceDexie is closed ' + instance.databaseName + '-' + instance.collectionName);\n    }\n}\n"],"mappings":"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"}
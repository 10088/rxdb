{"version":3,"sources":["../../../src/plugins/attachments.ts"],"names":["map","blobBufferUtil","flatClone","newRxError","writeSingle","_handleToStorageInstance","ensureSchemaSupportsAttachments","doc","schemaJson","collection","schema","jsonSchema","attachments","link","_assignMethodsToAttachment","attachment","Object","entries","forEach","funName","fun","defineProperty","get","bind","RxAttachment","id","type","length","digest","remove","_atomicQueue","then","docWriteData","_data","_attachments","storageInstance","previous","document","writeResult","newData","_rev","_dataSync$","next","getData","getAttachmentData","primary","plainData","shouldEncrypt","toString","dataString","ret","createBlobBuffer","_crypter","_decryptString","getStringData","bufferBlob","fromStorageInstanceResult","attachmentData","rxDocument","encrypted","putAttachment","data","skipIfSame","_encryptString","currentMeta","database","storage","statics","hash","newHash","getAttachment","getAttachmentDataMeta","meta","writeRow","docData","getValue","allAttachments","keys","preMigrateDocument","mustDecrypt","oldCollection","newAttachments","Promise","all","attachmentId","docPrimary","primaryPath","rawAttachmentData","postMigrateDocument","_action","storageStatics","size","rxdb","prototypes","RxDocument","proto","allAttachments$","pipe","attachmentsData","overwritable","hooks","RxDBAttachmentsPlugin","name"],"mappings":"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","sourcesContent":["import {\n    map\n} from 'rxjs/operators';\nimport {\n    blobBufferUtil,\n    flatClone\n} from './../util';\nimport {\n    newRxError\n} from '../rx-error';\nimport type {\n    RxDocument,\n    RxPlugin,\n    BlobBuffer,\n    OldRxCollection,\n    RxDocumentWriteData,\n    RxAttachmentData,\n    RxDocumentData,\n    RxAttachmentCreator,\n    RxAttachmentWriteData,\n    RxStorageStatics,\n    RxAttachmentDataMeta\n} from '../types';\nimport type { RxSchema } from '../rx-schema';\nimport { writeSingle } from '../rx-storage-helper';\nimport { _handleToStorageInstance } from '../rx-collection-helper';\n\nfunction ensureSchemaSupportsAttachments(doc: any) {\n    const schemaJson = doc.collection.schema.jsonSchema;\n    if (!schemaJson.attachments) {\n        throw newRxError('AT1', {\n            link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n        });\n    }\n}\n\nconst _assignMethodsToAttachment = function (attachment: any) {\n    Object\n        .entries(attachment.doc.collection.attachments)\n        .forEach(([funName, fun]) => {\n            Object.defineProperty(attachment, funName, {\n                get: () => (fun as any).bind(attachment)\n            });\n        });\n};\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport class RxAttachment {\n    public doc: RxDocument;\n    public id: string;\n    public type: string;\n    public length: number;\n    public digest: string;\n    constructor({\n        doc,\n        id,\n        type,\n        length,\n        digest\n    }: any) {\n        this.doc = doc;\n        this.id = id;\n        this.type = type;\n        this.length = length;\n        this.digest = digest;\n\n        _assignMethodsToAttachment(this);\n    }\n\n    async remove(): Promise<void> {\n        this.doc._atomicQueue = this.doc._atomicQueue\n            .then(async () => {\n                const docWriteData: RxDocumentWriteData<{}> = flatClone(this.doc._data);\n                docWriteData._attachments = flatClone(docWriteData._attachments);\n                delete docWriteData._attachments[this.id];\n\n                const writeResult: RxDocumentData<any> = await writeSingle(\n                    this.doc.collection.storageInstance,\n                    {\n                        previous: _handleToStorageInstance(this.doc.collection, flatClone(this.doc._data)),\n                        document: _handleToStorageInstance(this.doc.collection, docWriteData)\n                    }\n                );\n\n                const newData = flatClone(this.doc._data);\n                newData._rev = writeResult._rev;\n                newData._attachments = writeResult._attachments;\n                this.doc._dataSync$.next(newData);\n\n            });\n        return this.doc._atomicQueue;\n    }\n\n    /**\n     * returns the data for the attachment\n     */\n    async getData(): Promise<BlobBuffer> {\n        const plainData = await this.doc.collection.storageInstance.getAttachmentData(\n            this.doc.primary,\n            this.id\n        );\n        if (shouldEncrypt(this.doc.collection.schema)) {\n            const dataString = await blobBufferUtil.toString(plainData);\n            const ret = blobBufferUtil.createBlobBuffer(\n                this.doc.collection._crypter._decryptString(dataString),\n                this.type as any\n            );\n            return ret;\n        } else {\n            return plainData;\n        }\n    }\n\n    getStringData(): Promise<string> {\n        return this.getData().then(bufferBlob => blobBufferUtil.toString(bufferBlob));\n    }\n}\n\nexport function fromStorageInstanceResult(\n    id: string,\n    attachmentData: RxAttachmentData,\n    rxDocument: RxDocument\n) {\n    return new RxAttachment({\n        doc: rxDocument,\n        id,\n        type: attachmentData.type,\n        length: attachmentData.length,\n        digest: attachmentData.digest\n    });\n}\n\nfunction shouldEncrypt(schema: RxSchema): boolean {\n    return !!(schema.jsonSchema.attachments && schema.jsonSchema.attachments.encrypted);\n}\n\nexport async function putAttachment(\n    this: RxDocument,\n    {\n        id,\n        data,\n        type = 'text/plain'\n    }: RxAttachmentCreator,\n    /**\n     * If set to true, the write will be skipped\n     * when the attachment already contains the same data.\n     */\n    skipIfSame: boolean = true\n): Promise<RxAttachment> {\n    ensureSchemaSupportsAttachments(this);\n\n    /**\n     * Then encryption plugin is only able to encrypt strings,\n     * so unpack as string first.\n     */\n\n    if (shouldEncrypt(this.collection.schema)) {\n        const dataString = await blobBufferUtil.toString(data);\n        const encrypted = this.collection._crypter._encryptString(dataString);\n        data = blobBufferUtil.createBlobBuffer(encrypted, 'text/plain');\n    }\n\n    this._atomicQueue = this._atomicQueue\n        .then(async () => {\n            if (skipIfSame && this._data._attachments && this._data._attachments[id]) {\n                const currentMeta = this._data._attachments[id];\n                const newHash = await this.collection.database.storage.statics.hash(data);\n                if (currentMeta.type === type && currentMeta.digest === newHash) {\n                    // skip because same data and same type\n                    return this.getAttachment(id);\n                }\n            }\n\n            const docWriteData: RxDocumentWriteData<{}> = flatClone(this._data);\n            docWriteData._attachments = flatClone(docWriteData._attachments);\n\n            const meta = await getAttachmentDataMeta(\n                this.collection.database.storage.statics,\n                data\n            );\n            docWriteData._attachments[id] = {\n                digest: meta.digest,\n                length: meta.length,\n                type,\n                data: data\n            };\n\n            const writeRow = {\n                previous: _handleToStorageInstance(this.collection, flatClone(this._data)),\n                document: _handleToStorageInstance(this.collection, flatClone(docWriteData))\n            };\n\n            const writeResult = await writeSingle(\n                this.collection.storageInstance,\n                writeRow\n            );\n\n            const attachmentData = writeResult._attachments[id];\n            const attachment = fromStorageInstanceResult(\n                id,\n                attachmentData,\n                this\n            );\n\n            const newData = flatClone(this._data);\n            newData._rev = writeResult._rev;\n            newData._attachments = writeResult._attachments;\n            this._dataSync$.next(newData);\n\n            return attachment;\n        });\n    return this._atomicQueue;\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(\n    this: RxDocument,\n    id: string\n): RxAttachment | null {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n    if (!docData._attachments || !docData._attachments[id])\n        return null;\n\n    const attachmentData = docData._attachments[id];\n    const attachment = fromStorageInstanceResult(\n        id,\n        attachmentData,\n        this\n    );\n    return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments(\n    this: RxDocument\n): RxAttachment[] {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n\n    // if there are no attachments, the field is missing\n    if (!docData._attachments) {\n        return [];\n    }\n    return Object.keys(docData._attachments)\n        .map(id => {\n            return fromStorageInstanceResult(\n                id,\n                docData._attachments[id],\n                this\n            );\n        });\n}\n\nexport async function preMigrateDocument<RxDocType>(\n    data: {\n        docData: RxDocumentData<RxDocType>;\n        oldCollection: OldRxCollection\n    }\n): Promise<void> {\n    const attachments = data.docData._attachments;\n    if (attachments) {\n        const mustDecrypt = !!shouldEncrypt(data.oldCollection.schema);\n        const newAttachments: { [attachmentId: string]: RxAttachmentWriteData } = {};\n        await Promise.all(\n            Object.keys(attachments).map(async (attachmentId) => {\n                const attachment: RxAttachmentData = attachments[attachmentId];\n                const docPrimary: string = (data.docData as any)[data.oldCollection.schema.primaryPath];\n\n                let rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId);\n                if (mustDecrypt) {\n                    rawAttachmentData = await blobBufferUtil.toString(rawAttachmentData)\n                        .then(dataString => blobBufferUtil.createBlobBuffer(\n                            data.oldCollection._crypter._decryptString(dataString),\n                            (attachment as RxAttachmentData).type as any\n                        ));\n                }\n\n                const meta = await getAttachmentDataMeta(\n                    data.oldCollection.database.storage.statics,\n                    rawAttachmentData\n                );\n                newAttachments[attachmentId] = {\n                    digest: meta.digest,\n                    length: meta.length,\n                    type: attachment.type,\n                    data: rawAttachmentData\n                };\n            })\n        );\n\n        /**\n         * Hooks mutate the input\n         * instead of returning stuff\n         */\n        (data.docData as RxDocumentWriteData<RxDocType>)._attachments = newAttachments;\n    }\n}\n\nexport async function postMigrateDocument(_action: any): Promise<void> {\n    /**\n     * No longer needed because\n     * we store the attachemnts data buffers directly in the document.\n     */\n    return;\n}\n\nexport async function getAttachmentDataMeta(\n    storageStatics: RxStorageStatics,\n    data: BlobBuffer\n): Promise<RxAttachmentDataMeta> {\n    const hash = await storageStatics.hash(data);\n    const length = blobBufferUtil.size(data);\n    return {\n        digest: hash,\n        length\n    }\n}\n\nexport const rxdb = true;\nexport const prototypes = {\n    RxDocument: (proto: any) => {\n        proto.putAttachment = putAttachment;\n        proto.getAttachment = getAttachment;\n        proto.allAttachments = allAttachments;\n        Object.defineProperty(proto, 'allAttachments$', {\n            get: function allAttachments$() {\n                return this._dataSync$\n                    .pipe(\n                        map((data: any) => {\n                            if (!data['_attachments']) {\n                                return {};\n                            }\n                            return data['_attachments'];\n                        }),\n                        map((attachmentsData: any) => Object.entries(\n                            attachmentsData\n                        )),\n                        map(entries => {\n                            return (entries as any)\n                                .map(([id, attachmentData]: any) => {\n                                    return fromStorageInstanceResult(\n                                        id,\n                                        attachmentData,\n                                        this\n                                    );\n                                });\n                        })\n                    );\n            }\n        });\n    }\n};\nexport const overwritable = {};\nexport const hooks = {\n    preMigrateDocument,\n    postMigrateDocument\n};\n\nexport const RxDBAttachmentsPlugin: RxPlugin = {\n    name: 'attachments',\n    rxdb,\n    prototypes,\n    overwritable,\n    hooks\n};\n"],"file":"attachments.js"}
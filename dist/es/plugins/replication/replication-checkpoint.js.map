{"version":3,"sources":["../../../../src/plugins/replication/replication-checkpoint.ts"],"names":["findLocalDocument","writeSingleLocal","flatClone","newRxError","wasRevisionfromPullReplication","pushSequenceId","replicationIdentifier","pullLastDocumentId","getLastPushSequence","collection","localDocumentsStore","doc","value","setLastPushSequence","sequence","_id","document","_attachments","res","newDoc","previous","getChangesSinceLastPushSequence","batchSize","lastPushSequence","retry","lastSequence","changedDocs","Map","storageInstance","getChangedDocuments","sinceSequence","limit","direction","changesResults","changedDocuments","length","findDocumentsById","map","row","id","docs","forEach","has","changedDoc","args","_rev","set","size","getLastPullDocument","localDoc","setLastPullDocument"],"mappings":"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","sourcesContent":["import type {\n    RxCollection,\n    RxLocalDocumentData,\n    RxDocumentData,\n    ReplicationCheckpointDocument\n} from '../../types';\nimport {\n    findLocalDocument,\n    writeSingleLocal\n} from '../../rx-storage-helper';\nimport { flatClone } from '../../util';\nimport { newRxError } from '../../rx-error';\nimport { wasRevisionfromPullReplication } from './revision-flag';\n\n//\n// things for the push-checkpoint\n//\n\nconst pushSequenceId = (replicationIdentifier: string) => 'replication-checkpoint-push-' + replicationIdentifier;\nconst pullLastDocumentId = (replicationIdentifier: string) => 'replication-checkpoint-pull-' + replicationIdentifier;\n\n\n/**\n * Get the last push checkpoint\n */\nexport async function getLastPushSequence(\n    collection: RxCollection,\n    replicationIdentifier: string\n): Promise<number> {\n    const doc = await findLocalDocument<ReplicationCheckpointDocument>(\n        collection.localDocumentsStore,\n        pushSequenceId(replicationIdentifier)\n    );\n    if (!doc) {\n        return 0;\n    } else {\n        return doc.value;\n    }\n}\n\nexport async function setLastPushSequence(\n    collection: RxCollection,\n    replicationIdentifier: string,\n    sequence: number\n): Promise<ReplicationCheckpointDocument> {\n    const _id = pushSequenceId(replicationIdentifier);\n\n    const doc = await findLocalDocument<ReplicationCheckpointDocument>(\n        collection.localDocumentsStore,\n        _id\n    );\n    if (!doc) {\n        const res = await writeSingleLocal<ReplicationCheckpointDocument>(\n            collection.localDocumentsStore,\n            {\n                document: {\n                    _id,\n                    value: sequence,\n                    _attachments: {}\n                }\n            }\n        );\n        return res as any;\n    } else {\n        const newDoc = flatClone(doc);\n        newDoc.value = sequence;\n        const res = await writeSingleLocal<ReplicationCheckpointDocument>(\n            collection.localDocumentsStore,\n            {\n                previous: doc,\n                document: {\n                    _id,\n                    value: sequence,\n                    _attachments: {}\n                }\n            }\n        );\n        return res as any;\n    }\n}\n\n\n\nexport async function getChangesSinceLastPushSequence<RxDocType>(\n    collection: RxCollection<RxDocType, any>,\n    replicationIdentifier: string,\n    batchSize = 10\n): Promise<{\n    changedDocs: Map<string, {\n        id: string;\n        doc: RxDocumentData<RxDocType>;\n        sequence: number;\n    }>;\n    lastSequence: number;\n}> {\n    let lastPushSequence = await getLastPushSequence(\n        collection,\n        replicationIdentifier\n    );\n\n    let retry = true;\n    let lastSequence: number = lastPushSequence;\n    const changedDocs: Map<string, {\n        id: string;\n        doc: RxDocumentData<RxDocType>;\n        sequence: number;\n    }> = new Map();\n\n    /**\n     * it can happen that all docs in the batch\n     * do not have to be replicated.\n     * Then we have to continue grapping the feed\n     * until we reach the end of it\n     */\n    while (retry) {\n\n        const changesResults = await collection.storageInstance.getChangedDocuments({\n            sinceSequence: lastPushSequence,\n            limit: batchSize,\n            direction: 'after'\n        });\n        lastSequence = changesResults.lastSequence;\n\n        // optimisation shortcut, do not proceed if there are no changed documents\n        if (changesResults.changedDocuments.length === 0) {\n            retry = false;\n            continue;\n        }\n\n        const docs = await collection.storageInstance.findDocumentsById(\n            changesResults.changedDocuments.map(row => row.id),\n            true\n        );\n\n        changesResults.changedDocuments.forEach((row) => {\n            const id = row.id;\n            if (changedDocs.has(id)) {\n                return;\n            }\n            const changedDoc = docs[id];\n            if (!changedDoc) {\n                throw newRxError('SNH', { args: { docs } });\n            }\n\n            /**\n             * filter out changes with revisions resulting from the pull-stream\n             * so that they will not be upstreamed again\n             */\n            if (\n                wasRevisionfromPullReplication(\n                    replicationIdentifier,\n                    changedDoc._rev\n                )\n            ) {\n                return false;\n            }\n\n            changedDocs.set(id, {\n                id,\n                doc: changedDoc,\n                sequence: row.sequence\n            });\n        });\n\n\n        if (changedDocs.size < batchSize && changesResults.changedDocuments.length === batchSize) {\n            // no pushable docs found but also not reached the end -> re-run\n            lastPushSequence = lastSequence;\n            retry = true;\n        } else {\n            retry = false;\n        }\n    }\n\n    return {\n        changedDocs,\n        lastSequence\n    };\n}\n\n\n\n//\n// things for pull-checkpoint\n//\n\nexport async function getLastPullDocument<RxDocType>(\n    collection: RxCollection<RxDocType>,\n    replicationIdentifier: string,\n): Promise<RxDocumentData<RxDocType> | null> {\n    const localDoc = await findLocalDocument<any>(\n        collection.localDocumentsStore,\n        pullLastDocumentId(replicationIdentifier)\n    );\n    if (!localDoc) {\n        return null;\n    } else {\n        return localDoc.doc;\n    }\n}\n\nexport async function setLastPullDocument(\n    collection: RxCollection,\n    replicationIdentifier: string,\n    doc: any\n): Promise<{ _id: string }> {\n    const _id = pullLastDocumentId(replicationIdentifier);\n\n    const localDoc: RxLocalDocumentData = await findLocalDocument<any>(\n        collection.localDocumentsStore,\n        _id\n    );\n\n    if (!localDoc) {\n        return writeSingleLocal(\n            collection.localDocumentsStore,\n            {\n                document: {\n                    _id,\n                    doc,\n                    _attachments: {}\n                }\n            }\n        );\n    } else {\n        const newDoc = flatClone(localDoc);\n        newDoc.doc = doc;\n        return writeSingleLocal(\n            collection.localDocumentsStore,\n            {\n                previous: localDoc,\n                document: newDoc\n            }\n        );\n    }\n}\n"],"file":"replication-checkpoint.js"}
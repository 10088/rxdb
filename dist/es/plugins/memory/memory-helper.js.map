{"version":3,"file":"memory-helper.js","names":["pushAtSortPosition","newRxError","boundEQ","getMemoryCollectionKey","databaseName","collectionName","ensureNotRemoved","instance","internals","removed","Error","attachmentMapKey","documentId","attachmentId","SORT_BY_INDEX_STRING","a","b","indexString","putWriteRowToState","docId","state","stateByIndex","row","docInState","documents","set","document","forEach","byIndex","docsWithIndex","newIndexString","getIndexableString","id","doc","insertPosition","previousIndexString","prev","splice","next","args","indexBefore","compareDocsWithIndex","removeDocFromState","primaryPath","schema","Object","values","positionInIndex"],"sources":["../../../../src/plugins/memory/memory-helper.ts"],"sourcesContent":["import type {\n    BulkWriteRow,\n    RxDocumentData,\n    RxJsonSchema\n} from '../../types';\nimport type {\n    DocWithIndexString,\n    MemoryStorageInternals,\n    MemoryStorageInternalsByIndex\n} from './memory-types';\nimport type { RxStorageInstanceMemory } from './rx-storage-instance-memory';\nimport {\n    pushAtSortPosition\n} from 'array-push-at-sort-position';\nimport { newRxError } from '../../rx-error';\nimport { boundEQ } from './binary-search-bounds';\n\n\nexport function getMemoryCollectionKey(\n    databaseName: string,\n    collectionName: string\n): string {\n    return databaseName + '--memory--' + collectionName;\n}\n\n\nexport function ensureNotRemoved(\n    instance: RxStorageInstanceMemory<any>\n) {\n    if (instance.internals.removed) {\n        throw new Error('removed');\n    }\n}\n\nexport function attachmentMapKey(documentId: string, attachmentId: string): string {\n    return documentId + '||' + attachmentId;\n}\n\nconst SORT_BY_INDEX_STRING = (a: DocWithIndexString<any>, b: DocWithIndexString<any>) => {\n    if (a.indexString < b.indexString) {\n        return -1;\n    } else {\n        return 1;\n    }\n};\n\n\n\nexport function putWriteRowToState<RxDocType>(\n    docId: string,\n    state: MemoryStorageInternals<RxDocType>,\n    stateByIndex: MemoryStorageInternalsByIndex<RxDocType>[],\n    row: BulkWriteRow<RxDocType>,\n    docInState?: RxDocumentData<RxDocType>\n) {\n    state.documents.set(docId, row.document);\n    stateByIndex.forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const newIndexString = byIndex.getIndexableString(row.document);\n        const [, insertPosition] = pushAtSortPosition(\n            docsWithIndex,\n            {\n                id: docId,\n                doc: row.document,\n                indexString: newIndexString\n            },\n            SORT_BY_INDEX_STRING,\n            true\n        );\n\n        /**\n         * Remove previous if it was in the state\n         */\n        if (docInState) {\n            const previousIndexString = byIndex.getIndexableString(docInState);\n            if (previousIndexString === newIndexString) {\n                /**\n                 * Index not changed -> The old doc must be before or after the new one.\n                 */\n                const prev = docsWithIndex[insertPosition - 1];\n                if (prev && prev.id === docId) {\n                    docsWithIndex.splice(insertPosition - 1, 1)\n                } else {\n                    const next = docsWithIndex[insertPosition + 1];\n                    if (next.id === docId) {\n                        docsWithIndex.splice(insertPosition + 1, 1)\n                    } else {\n                        throw newRxError('SNH', {\n                            args: {\n                                row,\n                                byIndex\n                            }\n                        });\n                    }\n                }\n            } else {\n                /**\n                 * Index changed, we must search for the old one and remove it.\n                 */\n                const indexBefore = boundEQ(\n                    docsWithIndex,\n                    {\n                        indexString: previousIndexString\n                    } as any,\n                    compareDocsWithIndex\n                );\n                docsWithIndex.splice(indexBefore, 1)\n            }\n        }\n    });\n}\n\n\nexport function removeDocFromState<RxDocType>(\n    primaryPath: string,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    state: MemoryStorageInternals<RxDocType>,\n    doc: RxDocumentData<RxDocType>\n) {\n    const docId: string = (doc as any)[primaryPath];\n    state.documents.delete(docId);\n\n    Object.values(state.byIndex).forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const indexString = byIndex.getIndexableString(doc);\n\n        const positionInIndex = boundEQ(\n            docsWithIndex,\n            {\n                indexString\n            } as any,\n            compareDocsWithIndex\n        );\n        docsWithIndex.splice(positionInIndex, 1);\n    });\n}\n\n\nexport function compareDocsWithIndex<RxDocType>(\n    a: DocWithIndexString<RxDocType>,\n    b: DocWithIndexString<RxDocType>\n): 1 | 0 | -1 {\n    if (a.indexString < b.indexString) {\n        return -1;\n    } else if (a.indexString === b.indexString) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n"],"mappings":"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"}
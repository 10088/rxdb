{"version":3,"file":"memory-helper.js","names":["getIndexableString","pushAtSortPosition","newRxError","boundEQ","getMemoryCollectionKey","databaseName","collectionName","ensureNotRemoved","instance","internals","removed","Error","putWriteRowToState","primaryPath","schema","state","row","docInState","docId","document","documents","set","Object","values","byIndex","forEach","docsWithIndex","newIndexString","index","id","doc","indexString","a","b","insertPosition","previousIndexString","prev","splice","next","args","indexBefore","compareDocsWithIndex","removeDocFromState","positionInIndex"],"sources":["../../../../src/plugins/memory/memory-helper.ts"],"sourcesContent":["import { getIndexableString } from '../../custom-index';\nimport type { BulkWriteRow, RxDocumentData, RxJsonSchema } from '../../types';\nimport type { DocWithIndexString, MemoryStorageInternals } from './memory-types';\nimport type { RxStorageInstanceMemory } from './rx-storage-instance-memory';\nimport {\n    pushAtSortPosition\n} from 'array-push-at-sort-position';\nimport { newRxError } from '../../rx-error';\nimport { boundEQ } from './binary-search-bounds';\n\n\nexport function getMemoryCollectionKey(\n    databaseName: string,\n    collectionName: string\n): string {\n    return databaseName + '--memory--' + collectionName;\n}\n\n\nexport function ensureNotRemoved(\n    instance: RxStorageInstanceMemory<any>\n) {\n    if (instance.internals.removed) {\n        throw new Error('removed');\n    }\n}\n\nexport function putWriteRowToState<RxDocType>(\n    primaryPath: string,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    state: MemoryStorageInternals<RxDocType>,\n    row: BulkWriteRow<RxDocType>,\n    docInState?: RxDocumentData<RxDocType>\n) {\n    const docId: string = (row.document as any)[primaryPath];\n    state.documents.set(docId, row.document);\n\n\n    Object.values(state.byIndex).forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const newIndexString = getIndexableString(schema, byIndex.index, row.document);\n\n        const [, insertPosition] = pushAtSortPosition(\n            docsWithIndex,\n            {\n                id: docId,\n                doc: row.document,\n                indexString: newIndexString\n            },\n            (a: DocWithIndexString<RxDocType>, b: DocWithIndexString<RxDocType>) => {\n                if (a.indexString < b.indexString) {\n                    return -1;\n                } else {\n                    return 1;\n                }\n            },\n            true\n        );\n\n\n        /**\n         * Remove previous if it was in the state\n         */\n        if (docInState) {\n            const previousIndexString = getIndexableString(schema, byIndex.index, docInState);\n            if (previousIndexString === newIndexString) {\n                /**\n                 * Index not changed -> The old doc must be before or after the new one.\n                 */\n                const prev = docsWithIndex[insertPosition - 1];\n                if (prev && prev.id === docId) {\n                    docsWithIndex.splice(insertPosition - 1, 1)\n                } else {\n                    const next = docsWithIndex[insertPosition + 1];\n                    if (next.id === docId) {\n                        docsWithIndex.splice(insertPosition + 1, 1)\n                    } else {\n                        throw newRxError('SNH', {\n                            args: {\n                                row,\n                                byIndex\n                            }\n                        });\n                    }\n                }\n            } else {\n                /**\n                 * Index changed, we must search for the old one and remove it.\n                 */\n                const indexBefore = boundEQ(\n                    docsWithIndex,\n                    {\n                        indexString: previousIndexString\n                    } as any,\n                    compareDocsWithIndex\n                );\n                docsWithIndex.splice(indexBefore, 1)\n            }\n        }\n    });\n}\n\n\nexport function removeDocFromState<RxDocType>(\n    primaryPath: string,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    state: MemoryStorageInternals<RxDocType>,\n    doc: RxDocumentData<RxDocType>\n) {\n    const docId: string = (doc as any)[primaryPath];\n    state.documents.delete(docId);\n\n    Object.values(state.byIndex).forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const indexString = getIndexableString(schema, byIndex.index, doc);\n\n        const positionInIndex = boundEQ(\n            docsWithIndex,\n            {\n                indexString\n            } as any,\n            compareDocsWithIndex\n        );\n        docsWithIndex.splice(positionInIndex, 1);\n    });\n}\n\n\nexport function compareDocsWithIndex<RxDocType>(\n    a: DocWithIndexString<RxDocType>,\n    b: DocWithIndexString<RxDocType>\n): 1 | 0 | -1 {\n    if (a.indexString < b.indexString) {\n        return -1;\n    } else if (a.indexString === b.indexString) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n"],"mappings":"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"}
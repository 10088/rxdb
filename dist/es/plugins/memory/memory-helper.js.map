{"version":3,"sources":["../../../../src/plugins/memory/memory-helper.ts"],"names":["getIndexableString","pushAtSortPosition","newRxError","boundEQ","getMemoryCollectionKey","databaseName","collectionName","ensureNotRemoved","instance","internals","removed","Error","putWriteRowToState","primaryPath","schema","state","row","docInState","docId","document","documents","set","Object","values","byIndex","forEach","docsWithIndex","newIndexString","index","id","doc","indexString","a","b","insertPosition","previousIndexString","prev","splice","next","args","indexBefore","compareDocsWithIndex","removeDocFromState","positionInIndex"],"mappings":"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","sourcesContent":["import { getIndexableString } from '../../custom-index';\nimport type { BulkWriteRow, RxDocumentData, RxJsonSchema } from '../../types';\nimport type { DocWithIndexString, MemoryStorageInternals } from './memory-types';\nimport type { RxStorageInstanceMemory } from './rx-storage-instance-memory';\nimport {\n    pushAtSortPosition\n} from 'array-push-at-sort-position';\nimport { newRxError } from '../../rx-error';\nimport { boundEQ } from './binary-search-bounds';\n\n\nexport function getMemoryCollectionKey(\n    databaseName: string,\n    collectionName: string\n): string {\n    return databaseName + '--memory--' + collectionName;\n}\n\n\nexport function ensureNotRemoved(\n    instance: RxStorageInstanceMemory<any>\n) {\n    if (instance.internals.removed) {\n        throw new Error('removed');\n    }\n}\n\nexport function putWriteRowToState<RxDocType>(\n    primaryPath: string,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    state: MemoryStorageInternals<RxDocType>,\n    row: BulkWriteRow<RxDocType>,\n    docInState?: RxDocumentData<RxDocType>\n) {\n    const docId: string = (row.document as any)[primaryPath];\n    state.documents.set(docId, row.document);\n\n\n    Object.values(state.byIndex).forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const newIndexString = getIndexableString(schema, byIndex.index, row.document);\n\n        const [, insertPosition] = pushAtSortPosition(\n            docsWithIndex,\n            {\n                id: docId,\n                doc: row.document,\n                indexString: newIndexString\n            },\n            (a: DocWithIndexString<RxDocType>, b: DocWithIndexString<RxDocType>) => {\n                if (a.indexString < b.indexString) {\n                    return -1;\n                } else {\n                    return 1;\n                }\n            },\n            true\n        );\n\n\n        /**\n         * Remove previous if it was in the state\n         */\n        if (docInState) {\n            const previousIndexString = getIndexableString(schema, byIndex.index, docInState);\n            if (previousIndexString === newIndexString) {\n                /**\n                 * Index not changed -> The old doc must be before or after the new one.\n                 */\n                const prev = docsWithIndex[insertPosition - 1];\n                if (prev && prev.id === docId) {\n                    docsWithIndex.splice(insertPosition - 1, 1)\n                } else {\n                    const next = docsWithIndex[insertPosition + 1];\n                    if (next.id === docId) {\n                        docsWithIndex.splice(insertPosition + 1, 1)\n                    } else {\n                        throw newRxError('SNH', {\n                            args: {\n                                row,\n                                byIndex\n                            }\n                        });\n                    }\n                }\n            } else {\n                /**\n                 * Index changed, we must search for the old one and remove it.\n                 */\n                const indexBefore = boundEQ(\n                    docsWithIndex,\n                    {\n                        indexString: previousIndexString\n                    } as any,\n                    compareDocsWithIndex\n                );\n                docsWithIndex.splice(indexBefore, 1)\n            }\n        }\n    });\n}\n\n\nexport function removeDocFromState<RxDocType>(\n    primaryPath: string,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    state: MemoryStorageInternals<RxDocType>,\n    doc: RxDocumentData<RxDocType>\n) {\n    const docId: string = (doc as any)[primaryPath];\n    state.documents.delete(docId);\n\n    Object.values(state.byIndex).forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const indexString = getIndexableString(schema, byIndex.index, doc);\n\n        const positionInIndex = boundEQ(\n            docsWithIndex,\n            {\n                indexString\n            } as any,\n            compareDocsWithIndex\n        );\n        docsWithIndex.splice(positionInIndex, 1);\n    });\n}\n\n\nexport function compareDocsWithIndex<RxDocType>(\n    a: DocWithIndexString<RxDocType>,\n    b: DocWithIndexString<RxDocType>\n): 1 | 0 | -1 {\n    if (a.indexString < b.indexString) {\n        return -1;\n    } else if (a.indexString === b.indexString) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n"],"file":"memory-helper.js"}
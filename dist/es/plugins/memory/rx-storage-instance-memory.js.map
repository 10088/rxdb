{"version":3,"file":"rx-storage-instance-memory.js","names":["Subject","getStartIndexStringFromLowerBound","getStartIndexStringFromUpperBound","newRxError","getPrimaryFieldOfPrimaryKey","categorizeBulkWriteRows","getNewestOfDocumentStates","getFromMapOrThrow","lastOfArray","now","PROMISE_RESOLVE_TRUE","PROMISE_RESOLVE_VOID","RX_META_LWT_MINIMUM","RxStorageDexieStatics","boundGE","boundGT","attachmentMapKey","compareDocsWithIndex","ensureNotRemoved","getMemoryCollectionKey","putWriteRowToState","removeDocFromState","addIndexesToInternalsState","getMemoryIndexName","RxStorageInstanceMemory","storage","databaseName","collectionName","schema","internals","options","settings","closed","changes$","primaryPath","primaryKey","bulkWrite","documentWrites","context","ret","success","error","categorized","documents","errors","forEach","err","documentId","stateByIndex","Object","values","byIndex","bulkInsertDocs","writeRow","docId","document","undefined","bulkUpdateDocs","get","attachmentsMap","attachments","attachmentsAdd","attachment","set","attachmentId","attachmentData","attachmentsUpdate","attachmentsRemove","eventBulk","events","length","lastState","checkpoint","id","lwt","_meta","next","Promise","resolve","findDocumentsById","docIds","withDeleted","docInDb","_deleted","query","preparedQuery","queryPlan","skip","limit","Infinity","skipPlusLimit","queryMatcher","getQueryMatcher","sortComparator","getSortComparator","queryPlanFields","index","mustManuallyResort","sortFieldsSameAsIndexFields","concat","lowerBound","startKeys","lowerBoundString","upperBound","endKeys","upperBoundString","indexName","docsWithIndex","indexOfLower","indexString","rows","done","currentDoc","doc","push","sort","slice","getChangedDocumentsSince","sinceLwt","sinceId","lastDoc","cleanup","minimumDeletedTime","maxDeletionTime","getAttachmentData","data","changeStream","asObservable","remove","removed","collectionStates","close","reject","database","collection","complete","refCount","conflictResultionTasks","conflictResultionTasks$","resolveConflictResultionTask","_taskSolution","createMemoryStorageInstance","params","collectionKey","Map","instance"],"sources":["../../../../src/plugins/memory/rx-storage-instance-memory.ts"],"sourcesContent":["import {\n    Observable,\n    Subject\n} from 'rxjs';\nimport {\n    getStartIndexStringFromLowerBound,\n    getStartIndexStringFromUpperBound\n} from '../../custom-index';\nimport { newRxError } from '../../rx-error';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport { categorizeBulkWriteRows, getNewestOfDocumentStates } from '../../rx-storage-helper';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxDocumentData,\n    RxDocumentDataById,\n    RxJsonSchema,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageDefaultCheckpoint,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult,\n    StringKeys\n} from '../../types';\nimport {\n    getFromMapOrThrow,\n    lastOfArray,\n    now,\n    PROMISE_RESOLVE_TRUE,\n    PROMISE_RESOLVE_VOID,\n    RX_META_LWT_MINIMUM\n} from '../../util';\nimport { RxStorageDexieStatics } from '../dexie/rx-storage-dexie';\nimport {\n    boundGE,\n    boundGT\n} from './binary-search-bounds';\nimport {\n    attachmentMapKey,\n    compareDocsWithIndex,\n    ensureNotRemoved,\n    getMemoryCollectionKey,\n    putWriteRowToState,\n    removeDocFromState\n} from './memory-helper';\nimport {\n    addIndexesToInternalsState,\n    getMemoryIndexName\n} from './memory-indexes';\nimport type {\n    MemoryPreparedQuery,\n    MemoryStorageInternals,\n    RxStorageMemory,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageMemorySettings\n} from './memory-types';\n\nexport class RxStorageInstanceMemory<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    MemoryStorageInternals<RxDocType>,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageDefaultCheckpoint\n> {\n\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    public closed = false;\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = new Subject();\n\n    constructor(\n        public readonly storage: RxStorageMemory,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: MemoryStorageInternals<RxDocType>,\n        public readonly options: Readonly<RxStorageMemoryInstanceCreationOptions>,\n        public readonly settings: RxStorageMemorySettings\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n    }\n\n    bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        ensureNotRemoved(this);\n\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            success: {},\n            error: {}\n        };\n\n        const categorized = categorizeBulkWriteRows<RxDocType>(\n            this,\n            this.primaryPath as any,\n            this.internals.documents,\n            documentWrites,\n            context\n        );\n        categorized.errors.forEach(err => {\n            ret.error[err.documentId] = err;\n        });\n\n        /**\n         * Do inserts/updates\n         */\n        const stateByIndex = Object.values(this.internals.byIndex);\n\n        categorized.bulkInsertDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                docId as any,\n                this.internals,\n                stateByIndex,\n                writeRow,\n                undefined\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        categorized.bulkUpdateDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                docId as any,\n                this.internals,\n                stateByIndex,\n                writeRow,\n                this.internals.documents.get(docId as any)\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        /**\n         * Handle attachments\n         */\n        const attachmentsMap = this.internals.attachments;\n        categorized.attachmentsAdd.forEach(attachment => {\n            attachmentsMap.set(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                attachment.attachmentData\n            );\n        });\n        categorized.attachmentsUpdate.forEach(attachment => {\n            attachmentsMap.set(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                attachment.attachmentData\n            );\n        });\n        categorized.attachmentsRemove.forEach(attachment => {\n            attachmentsMap.delete(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId)\n            );\n        });\n\n        if (categorized.eventBulk.events.length > 0) {\n            const lastState = getNewestOfDocumentStates(\n                this.primaryPath as any,\n                Object.values(ret.success)\n            );\n            categorized.eventBulk.checkpoint = {\n                id: lastState[this.primaryPath],\n                lwt: lastState._meta.lwt\n            };\n            this.changes$.next(categorized.eventBulk);\n        }\n        return Promise.resolve(ret);\n    }\n\n    findDocumentsById(\n        docIds: string[],\n        withDeleted: boolean\n    ): Promise<RxDocumentDataById<RxDocType>> {\n        const ret: RxDocumentDataById<RxDocType> = {};\n        docIds.forEach(docId => {\n            const docInDb = this.internals.documents.get(docId);\n            if (\n                docInDb &&\n                (\n                    !docInDb._deleted ||\n                    withDeleted\n                )\n            ) {\n                ret[docId] = docInDb;\n            }\n        });\n        return Promise.resolve(ret);\n    }\n\n    query(preparedQuery: MemoryPreparedQuery<RxDocType>): Promise<RxStorageQueryResult<RxDocType>> {\n        const queryPlan = preparedQuery.queryPlan;\n        const query = preparedQuery.query;\n        const skip = query.skip ? query.skip : 0;\n        const limit = query.limit ? query.limit : Infinity;\n        const skipPlusLimit = skip + limit;\n\n        const queryMatcher = RxStorageDexieStatics.getQueryMatcher(\n            this.schema,\n            preparedQuery\n        );\n        const sortComparator = RxStorageDexieStatics.getSortComparator(this.schema, preparedQuery);\n\n        const queryPlanFields: string[] = queryPlan.index;\n        const mustManuallyResort = !queryPlan.sortFieldsSameAsIndexFields;\n        const index: string[] | undefined = ['_deleted'].concat(queryPlanFields);\n        let lowerBound: any[] = queryPlan.startKeys;\n        lowerBound = [false].concat(lowerBound);\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            lowerBound\n        );\n\n        let upperBound: any[] = queryPlan.endKeys;\n        upperBound = [false].concat(upperBound);\n        const upperBoundString = getStartIndexStringFromUpperBound(\n            this.schema,\n            index,\n            upperBound\n        );\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n        let indexOfLower = boundGE(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let rows: RxDocumentData<RxDocType>[] = [];\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n\n            if (\n                !currentDoc ||\n                currentDoc.indexString > upperBoundString\n            ) {\n                break;\n            }\n\n            if (queryMatcher(currentDoc.doc)) {\n                rows.push(currentDoc.doc);\n            }\n\n            if (\n                (rows.length >= skipPlusLimit && !mustManuallyResort) ||\n                indexOfLower >= docsWithIndex.length\n            ) {\n                done = true;\n            }\n\n            indexOfLower++;\n        }\n\n        if (mustManuallyResort) {\n            rows = rows.sort(sortComparator);\n        }\n\n        // apply skip and limit boundaries.\n        rows = rows.slice(skip, skipPlusLimit);\n\n        return Promise.resolve({\n            documents: rows\n        });\n    }\n\n    getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: RxStorageDefaultCheckpoint\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        checkpoint: RxStorageDefaultCheckpoint;\n    }> {\n        const sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n        const sinceId = checkpoint ? checkpoint.id : '';\n\n        const index = ['_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            ['_meta.lwt', this.primaryPath as any],\n            [\n                sinceLwt,\n                sinceId\n            ]\n        );\n\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        // TODO use array.slice() so we do not have to iterate here\n        const rows: RxDocumentData<RxDocType>[] = [];\n        while (rows.length < limit && indexOfLower < docsWithIndex.length) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            rows.push(currentDoc.doc);\n            indexOfLower++;\n        }\n\n        const lastDoc = lastOfArray(rows);\n        return Promise.resolve({\n            documents: rows,\n            checkpoint: lastDoc ? {\n                id: lastDoc[this.primaryPath] as any,\n                lwt: lastDoc._meta.lwt\n            } : checkpoint ? checkpoint : {\n                id: '',\n                lwt: 0\n            }\n        });\n    }\n\n    cleanup(minimumDeletedTime: number): Promise<boolean> {\n        const maxDeletionTime = now() - minimumDeletedTime;\n        const index = ['_deleted', '_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            [\n                true,\n                0,\n                ''\n            ]\n        );\n\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            if (!currentDoc || currentDoc.doc._meta.lwt > maxDeletionTime) {\n                done = true;\n            } else {\n                removeDocFromState(\n                    this.primaryPath as any,\n                    this.schema,\n                    this.internals,\n                    currentDoc.doc\n                );\n                indexOfLower++;\n            }\n        }\n        return PROMISE_RESOLVE_TRUE;\n    }\n\n    getAttachmentData(documentId: string, attachmentId: string): Promise<string> {\n        ensureNotRemoved(this);\n        const data = getFromMapOrThrow(\n            this.internals.attachments,\n            attachmentMapKey(documentId, attachmentId)\n        );\n        return Promise.resolve(data.data);\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\n        ensureNotRemoved(this);\n        return this.changes$.asObservable();\n    }\n\n    async remove(): Promise<void> {\n        ensureNotRemoved(this);\n\n        this.internals.removed = true;\n        this.storage.collectionStates.delete(\n            getMemoryCollectionKey(this.databaseName, this.collectionName)\n        );\n        await this.close();\n    }\n\n    close(): Promise<void> {\n        if (this.closed) {\n            return Promise.reject(newRxError('SNH', {\n                database: this.databaseName,\n                collection: this.collectionName\n            }));\n        }\n        this.closed = true;\n        this.changes$.complete();\n\n        this.internals.refCount = this.internals.refCount - 1;\n        if (this.internals.refCount === 0) {\n            this.storage.collectionStates.delete(\n                getMemoryCollectionKey(this.databaseName, this.collectionName)\n            );\n        }\n\n        return PROMISE_RESOLVE_VOID;\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return this.internals.conflictResultionTasks$.asObservable();\n    }\n    resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> {\n        return PROMISE_RESOLVE_VOID;\n    }\n}\n\nexport function createMemoryStorageInstance<RxDocType>(\n    storage: RxStorageMemory,\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMemoryInstanceCreationOptions>,\n    settings: RxStorageMemorySettings\n): Promise<RxStorageInstanceMemory<RxDocType>> {\n    const collectionKey = getMemoryCollectionKey(params.databaseName, params.collectionName);\n\n    let internals = storage.collectionStates.get(collectionKey);\n    if (!internals) {\n        internals = {\n            removed: false,\n            refCount: 1,\n            documents: new Map(),\n            attachments: params.schema.attachments ? new Map() : undefined as any,\n            byIndex: {},\n            conflictResultionTasks$: new Subject()\n        };\n        addIndexesToInternalsState(internals, params.schema);\n        storage.collectionStates.set(collectionKey, internals);\n    } else {\n        internals.refCount = internals.refCount + 1;\n    }\n\n    const instance = new RxStorageInstanceMemory(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n    return Promise.resolve(instance);\n}\n"],"mappings":"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"}
{"version":3,"sources":["../../../../src/plugins/memory/rx-storage-instance-memory.ts"],"names":["Subject","getStartIndexStringFromLowerBound","getStartIndexStringFromUpperBound","MAX_CHAR","newRxError","getPrimaryFieldOfPrimaryKey","categorizeBulkWriteRows","ensureNotFalsy","now","RX_META_LWT_MINIMUM","getDexieKeyRange","RxStorageDexieStatics","pouchSwapIdToPrimaryString","boundGE","boundGT","compareDocsWithIndex","ensureNotRemoved","getMemoryCollectionKey","putWriteRowToState","removeDocFromState","addIndexesToInternalsState","getMemoryIndexName","createMemoryStorageInstance","storage","params","settings","collectionKey","databaseName","collectionName","internals","collectionStates","get","removed","refCount","documents","Map","byIndex","schema","set","instance","RxStorageInstanceMemory","options","IDBKeyRange","require","changes$","closed","primaryPath","primaryKey","bulkWrite","documentWrites","ret","success","error","docsInDb","forEach","writeRow","docId","document","docInDb","categorized","errors","err","documentId","bulkInsertDocs","undefined","bulkUpdateDocs","next","eventBulk","Promise","resolve","findDocumentsById","docIds","withDeleted","_deleted","query","preparedQuery","skip","limit","Infinity","skipPlusLimit","queryPlan","pouchQueryPlan","queryMatcher","getQueryMatcher","sortComparator","getSortComparator","keyRange","Number","NEGATIVE_INFINITY","queryPlanFields","index","def","fields","map","fieldObj","Object","keys","field","sortFields","sort","sortPart","sortFieldsSameAsIndexFields","join","isOneSortDescending","find","values","mustManuallyResort","concat","lowerBound","Array","isArray","lower","lowerBoundString","upperBound","upper","upperBoundString","indexName","docsWithIndex","indexOfLower","indexString","rows","done","currentDoc","doc","push","length","slice","getChangedDocumentsSince","checkpoint","sinceLwt","lwt","sinceId","id","docData","_meta","cleanup","minimumDeletedTime","maxDeletionTime","getAttachmentData","_documentId","_attachmentId","Error","changeStream","asObservable","remove","close","database","collection","complete"],"mappings":"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","sourcesContent":["import { Observable, Subject } from 'rxjs';\nimport { getStartIndexStringFromLowerBound, getStartIndexStringFromUpperBound, MAX_CHAR } from '../../custom-index';\nimport { newRxError } from '../../rx-error';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport { categorizeBulkWriteRows } from '../../rx-storage-helper';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    MangoQuery,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult\n} from '../../types';\nimport { ensureNotFalsy, now, RX_META_LWT_MINIMUM } from '../../util';\nimport { getDexieKeyRange } from '../dexie/query/dexie-query';\nimport { RxStorageDexieStatics } from '../dexie/rx-storage-dexie';\nimport { pouchSwapIdToPrimaryString } from '../pouchdb';\nimport { boundGE, boundGT } from './binary-search-bounds';\nimport {\n    compareDocsWithIndex,\n    ensureNotRemoved,\n    getMemoryCollectionKey,\n    putWriteRowToState,\n    removeDocFromState\n} from './memory-helper';\nimport { addIndexesToInternalsState, getMemoryIndexName } from './memory-indexes';\nimport type {\n    MemoryChangesCheckpoint,\n    MemoryPreparedQuery,\n    MemoryStorageInternals,\n    RxStorageMemory,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageMemorySettings\n} from './memory-types';\n\nconst IDBKeyRange = require('fake-indexeddb/lib/FDBKeyRange');\n\nexport class RxStorageInstanceMemory<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    MemoryStorageInternals<RxDocType>,\n    RxStorageMemoryInstanceCreationOptions\n> {\n\n    public readonly primaryPath: keyof RxDocType;\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>>> = new Subject();\n    public closed = false;\n\n    constructor(\n        public readonly storage: RxStorageMemory,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: MemoryStorageInternals<RxDocType>,\n        public readonly options: Readonly<RxStorageMemoryInstanceCreationOptions>,\n        public readonly settings: RxStorageMemorySettings\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey) as any;\n    }\n\n    bulkWrite(documentWrites: BulkWriteRow<RxDocType>[]): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        ensureNotRemoved(this);\n\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            success: {},\n            error: {}\n        };\n\n        const docsInDb: Map<RxDocumentData<RxDocType>[keyof RxDocType], RxDocumentData<RxDocType>> = new Map();\n        documentWrites.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            const docInDb = this.internals.documents.get(docId as any);\n            if (docInDb) {\n                docsInDb.set(docId, docInDb);\n            }\n        });\n\n\n        const categorized = categorizeBulkWriteRows<RxDocType>(\n            this,\n            this.primaryPath,\n            docsInDb,\n            documentWrites\n        );\n        categorized.errors.forEach(err => {\n            ret.error[err.documentId] = err;\n        });\n\n        /**\n         * Do inserts/updates\n         */\n        categorized.bulkInsertDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                this.primaryPath as any,\n                this.schema,\n                this.internals,\n                writeRow,\n                undefined\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        categorized.bulkUpdateDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                this.primaryPath as any,\n                this.schema,\n                this.internals,\n                writeRow,\n                docsInDb.get(docId)\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        this.changes$.next(categorized.eventBulk);\n\n        return Promise.resolve(ret);\n    }\n\n    async findDocumentsById(\n        docIds: string[],\n        withDeleted: boolean\n    ): Promise<{ [documentId: string]: RxDocumentData<RxDocType>; }> {\n        const ret: { [documentId: string]: RxDocumentData<RxDocType>; } = {};\n        docIds.forEach(docId => {\n            const docInDb = this.internals.documents.get(docId);\n            if (\n                docInDb &&\n                (\n                    !docInDb._deleted ||\n                    withDeleted\n                )\n            ) {\n                ret[docId] = docInDb;\n            }\n        });\n        return Promise.resolve(ret);\n    }\n\n    async query(preparedQuery: MemoryPreparedQuery<RxDocType>): Promise<RxStorageQueryResult<RxDocType>> {\n        const skip = preparedQuery.skip ? preparedQuery.skip : 0;\n        const limit = preparedQuery.limit ? preparedQuery.limit : Infinity;\n        const skipPlusLimit = skip + limit;\n        const queryPlan = (preparedQuery as any).pouchQueryPlan;\n\n        const queryMatcher = RxStorageDexieStatics.getQueryMatcher(\n            this.schema,\n            preparedQuery\n        );\n        const sortComparator = RxStorageDexieStatics.getSortComparator(this.schema, preparedQuery);\n\n\n        const keyRange = getDexieKeyRange(\n            queryPlan,\n            Number.NEGATIVE_INFINITY,\n            MAX_CHAR,\n            IDBKeyRange\n        );\n\n        const queryPlanFields: string[] = queryPlan.index.def.fields\n            .map((fieldObj: any) => Object.keys(fieldObj)[0])\n            .map((field: any) => pouchSwapIdToPrimaryString(this.primaryPath, field));\n\n        const sortFields = ensureNotFalsy((preparedQuery as MangoQuery<RxDocType>).sort)\n            .map(sortPart => Object.keys(sortPart)[0]);\n\n        /**\n         * If the cursor iterated over the same index that\n         * would be used for sorting, we do not have to sort the results.\n         */\n        const sortFieldsSameAsIndexFields = queryPlanFields.join(',') === sortFields.join(',');\n        /**\n         * Also manually sort if one part of the sort is in descending order\n         * because all our indexes are ascending.\n         * TODO should we be able to define descending indexes?\n         */\n        const isOneSortDescending = preparedQuery.sort.find((sortPart: any) => Object.values(sortPart)[0] === 'desc');\n        const mustManuallyResort = isOneSortDescending || !sortFieldsSameAsIndexFields;\n\n\n        const index: string[] | undefined = ['_deleted'].concat(queryPlanFields);\n        let lowerBound = Array.isArray(keyRange.lower) ? keyRange.lower : [keyRange.lower];\n        lowerBound = [false].concat(lowerBound);\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            lowerBound\n        );\n\n        let upperBound = Array.isArray(keyRange.upper) ? keyRange.upper : [keyRange.upper];\n        upperBound = [false].concat(upperBound);\n        const upperBoundString = getStartIndexStringFromUpperBound(\n            this.schema,\n            index,\n            upperBound\n        );\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n        let indexOfLower = boundGE(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let rows: RxDocumentData<RxDocType>[] = [];\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n\n            if (\n                !currentDoc ||\n                currentDoc.indexString > upperBoundString\n            ) {\n                break;\n            }\n\n            if (queryMatcher(currentDoc.doc)) {\n                rows.push(currentDoc.doc);\n            }\n\n            if (\n                (rows.length >= skipPlusLimit && !isOneSortDescending) ||\n                indexOfLower >= docsWithIndex.length\n            ) {\n                done = true;\n            }\n\n            indexOfLower++;\n        }\n\n        if (mustManuallyResort) {\n            rows = rows.sort(sortComparator);\n        }\n\n        // apply skip and limit boundaries.\n        rows = rows.slice(skip, skipPlusLimit);\n\n\n        return {\n            documents: rows\n        };\n    }\n\n    async getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: MemoryChangesCheckpoint\n    ): Promise<{\n        document: RxDocumentData<RxDocType>;\n        checkpoint: MemoryChangesCheckpoint;\n    }[]> {\n        const sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n        const sinceId = checkpoint ? checkpoint.id : '';\n\n        const index = ['_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            ['_meta.lwt', this.primaryPath as any],\n            [\n                sinceLwt,\n                sinceId\n            ]\n        );\n\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n\n\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        // TODO use array.slice() so we do not have to iterate here\n        const rows: RxDocumentData<RxDocType>[] = [];\n        while (rows.length < limit && indexOfLower < docsWithIndex.length) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            rows.push(currentDoc.doc);\n            indexOfLower++;\n        }\n\n        return rows.map(docData => ({\n            document: docData,\n            checkpoint: {\n                id: docData[this.primaryPath] as any,\n                lwt: docData._meta.lwt\n            }\n        }));\n    }\n\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        const maxDeletionTime = now() - minimumDeletedTime;\n        const index = ['_deleted', '_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            [\n                true,\n                0,\n                ''\n            ]\n        );\n\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            if (!currentDoc || currentDoc.doc._meta.lwt > maxDeletionTime) {\n                done = true;\n            } else {\n                removeDocFromState(\n                    this.primaryPath as any,\n                    this.schema,\n                    this.internals,\n                    currentDoc.doc\n                );\n                indexOfLower++;\n            }\n        }\n\n        return true;\n    }\n\n\n    getAttachmentData(_documentId: string, _attachmentId: string): Promise<string> {\n        ensureNotRemoved(this);\n        throw new Error('Attachments are not implemented in the memory RxStorage. Make a pull request.');\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>>> {\n        ensureNotRemoved(this);\n        return this.changes$.asObservable();\n    }\n\n    async remove(): Promise<void> {\n        ensureNotRemoved(this);\n\n        this.internals.removed = true;\n        this.storage.collectionStates.delete(\n            getMemoryCollectionKey(this.databaseName, this.collectionName)\n        );\n        await this.close();\n    }\n\n    async close(): Promise<void> {\n        if (this.closed) {\n            throw newRxError('SNH', {\n                database: this.databaseName,\n                collection: this.collectionName\n            });\n        }\n        this.closed = true;\n        this.changes$.complete();\n\n        this.internals.refCount = this.internals.refCount - 1;\n        if (this.internals.refCount === 0) {\n            this.storage.collectionStates.delete(\n                getMemoryCollectionKey(this.databaseName, this.collectionName)\n            );\n        }\n    }\n}\n\n\n\nexport async function createMemoryStorageInstance<RxDocType>(\n    storage: RxStorageMemory,\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMemoryInstanceCreationOptions>,\n    settings: RxStorageMemorySettings\n): Promise<RxStorageInstanceMemory<RxDocType>> {\n\n    const collectionKey = getMemoryCollectionKey(params.databaseName, params.collectionName);\n\n\n    let internals = storage.collectionStates.get(collectionKey);\n    if (!internals) {\n        internals = {\n            removed: false,\n            refCount: 1,\n            documents: new Map(),\n            byIndex: {}\n        };\n        addIndexesToInternalsState(internals, params.schema);\n        storage.collectionStates.set(collectionKey, internals);\n    } else {\n        internals.refCount = internals.refCount + 1;\n    }\n\n    const instance = new RxStorageInstanceMemory(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n    return instance;\n}\n"],"file":"rx-storage-instance-memory.js"}
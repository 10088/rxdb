{"version":3,"sources":["../../../../src/plugins/memory/memory-indexes.ts"],"names":["getPrimaryFieldOfPrimaryKey","addIndexesToInternalsState","state","schema","primaryPath","primaryKey","useIndexes","indexes","map","row","Array","isArray","slice","push","forEach","indexAr","unshift","indexName","getMemoryIndexName","byIndex","index","docsWithIndex","changesIndex","join"],"mappings":"AAAA,SAASA,2BAAT,QAA4C,wBAA5C;AAIA,OAAO,SAASC,0BAAT,CACHC,KADG,EAEHC,MAFG,EAGL;AACE,MAAMC,WAAW,GAAGJ,2BAA2B,CAACG,MAAM,CAACE,UAAR,CAA/C;AACA,MAAMC,UAAsB,GAAG,CAACH,MAAM,CAACI,OAAR,GAAkB,EAAlB,GAAuBJ,MAAM,CAACI,OAAP,CAAeC,GAAf,CAAmB,UAAAC,GAAG;AAAA,WAAIC,KAAK,CAACC,OAAN,CAAcF,GAAd,IAAqBA,GAAG,CAACG,KAAJ,CAAU,CAAV,CAArB,GAAoC,CAACH,GAAD,CAAxC;AAAA,GAAtB,CAAtD,CAFF,CAIE;;AACAH,EAAAA,UAAU,CAACO,IAAX,CAAgB,CACZT,WADY,CAAhB,EALF,CASE;;AACAE,EAAAA,UAAU,CAACO,IAAX,CAAgB,CACZ,WADY,EAEZT,WAFY,CAAhB;AAMAE,EAAAA,UAAU,CAACQ,OAAX,CAAmB,UAAAC,OAAO,EAAI;AAC1B;AACR;AACA;AACA;AACQA,IAAAA,OAAO,CAACC,OAAR,CAAgB,UAAhB;AAEA,QAAMC,SAAS,GAAGC,kBAAkB,CAACH,OAAD,CAApC;AACAb,IAAAA,KAAK,CAACiB,OAAN,CAAcF,SAAd,IAA2B;AACvBG,MAAAA,KAAK,EAAEL,OADgB;AAEvBM,MAAAA,aAAa,EAAE;AAFQ,KAA3B;AAIH,GAZD,EAhBF,CA8BE;;AACA,MAAMC,YAAY,GAAG,CACjB,WADiB,EAEjBlB,WAFiB,CAArB;AAIA,MAAMa,SAAS,GAAGC,kBAAkB,CAACI,YAAD,CAApC;AACApB,EAAAA,KAAK,CAACiB,OAAN,CAAcF,SAAd,IAA2B;AACvBG,IAAAA,KAAK,EAAEE,YADgB;AAEvBD,IAAAA,aAAa,EAAE;AAFQ,GAA3B;AAKH;AAGD,OAAO,SAASH,kBAAT,CAA4BE,KAA5B,EAAqD;AACxD,SAAOA,KAAK,CAACG,IAAN,CAAW,GAAX,CAAP;AACH","sourcesContent":["import { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport type { RxDocumentData, RxJsonSchema } from '../../types';\nimport type { MemoryStorageInternals } from './memory-types';\n\nexport function addIndexesToInternalsState<RxDocType>(\n    state: MemoryStorageInternals<RxDocType>,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>\n) {\n    const primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey) as any;\n    const useIndexes: string[][] = !schema.indexes ? [] : schema.indexes.map(row => Array.isArray(row) ? row.slice(0) : [row]) as any;\n\n    // we need this as default index\n    useIndexes.push([\n        primaryPath\n    ]);\n\n    // we need this index for running cleanup()\n    useIndexes.push([\n        '_meta.lwt',\n        primaryPath\n    ]);\n\n\n    useIndexes.forEach(indexAr => {\n        /**\n         * Running a query will only return non-deleted documents\n         * so all indexes must have the the deleted field as first index field.\n         */\n        indexAr.unshift('_deleted');\n\n        const indexName = getMemoryIndexName(indexAr);\n        state.byIndex[indexName] = {\n            index: indexAr,\n            docsWithIndex: []\n        };\n    });\n\n    // we need this index for the changes()\n    const changesIndex = [\n        '_meta.lwt',\n        primaryPath\n    ];\n    const indexName = getMemoryIndexName(changesIndex);\n    state.byIndex[indexName] = {\n        index: changesIndex,\n        docsWithIndex: []\n    };\n\n}\n\n\nexport function getMemoryIndexName(index: string[]): string {\n    return index.join(',');\n}\n"],"file":"memory-indexes.js"}
{"version":3,"file":"memory-indexes.js","names":["getIndexableStringMonad","getPrimaryFieldOfPrimaryKey","addIndexesToInternalsState","state","schema","primaryPath","primaryKey","useIndexes","indexes","map","row","Array","isArray","slice","push","forEach","indexAr","unshift","byIndex","getMemoryIndexName","index","docsWithIndex","getIndexableString","changesIndex","indexName","join"],"sources":["../../../../src/plugins/memory/memory-indexes.ts"],"sourcesContent":["import { getIndexableStringMonad } from '../../custom-index';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport type { RxDocumentData, RxJsonSchema } from '../../types';\nimport type { MemoryStorageInternals } from './memory-types';\n\nexport function addIndexesToInternalsState<RxDocType>(\n    state: MemoryStorageInternals<RxDocType>,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>\n) {\n    const primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    const useIndexes: string[][] = !schema.indexes ? [] : schema.indexes.map(row => Array.isArray(row) ? row.slice(0) : [row]) as any;\n\n    // we need this as default index\n    useIndexes.push([\n        primaryPath\n    ]);\n\n    // we need this index for running cleanup()\n    useIndexes.push([\n        '_meta.lwt',\n        primaryPath\n    ]);\n\n\n    useIndexes.forEach(indexAr => {\n        /**\n         * Running a query will only return non-deleted documents\n         * so all indexes must have the the deleted field as first index field.\n         */\n        indexAr.unshift('_deleted');\n\n        state.byIndex[getMemoryIndexName(indexAr)] = {\n            index: indexAr,\n            docsWithIndex: [],\n            getIndexableString: getIndexableStringMonad(schema, indexAr)\n        };\n    });\n\n    // we need this index for the changes()\n    const changesIndex = [\n        '_meta.lwt',\n        primaryPath\n    ];\n    const indexName = getMemoryIndexName(changesIndex);\n    state.byIndex[indexName] = {\n        index: changesIndex,\n        docsWithIndex: [],\n        getIndexableString: getIndexableStringMonad(schema, changesIndex)\n    };\n\n}\n\n\nexport function getMemoryIndexName(index: string[]): string {\n    return index.join(',');\n}\n"],"mappings":"AAAA,SAASA,uBAAuB,QAAQ,oBAAoB;AAC5D,SAASC,2BAA2B,QAAQ,wBAAwB;AAIpE,OAAO,SAASC,0BAA0B,CACtCC,KAAwC,EACxCC,MAA+C,EACjD;EACE,IAAMC,WAAW,GAAGJ,2BAA2B,CAACG,MAAM,CAACE,UAAU,CAAC;EAClE,IAAMC,UAAsB,GAAG,CAACH,MAAM,CAACI,OAAO,GAAG,EAAE,GAAGJ,MAAM,CAACI,OAAO,CAACC,GAAG,CAAC,UAAAC,GAAG;IAAA,OAAIC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,GAAGA,GAAG,CAACG,KAAK,CAAC,CAAC,CAAC,GAAG,CAACH,GAAG,CAAC;EAAA,EAAQ;;EAEjI;EACAH,UAAU,CAACO,IAAI,CAAC,CACZT,WAAW,CACd,CAAC;;EAEF;EACAE,UAAU,CAACO,IAAI,CAAC,CACZ,WAAW,EACXT,WAAW,CACd,CAAC;EAGFE,UAAU,CAACQ,OAAO,CAAC,UAAAC,OAAO,EAAI;IAC1B;AACR;AACA;AACA;IACQA,OAAO,CAACC,OAAO,CAAC,UAAU,CAAC;IAE3Bd,KAAK,CAACe,OAAO,CAACC,kBAAkB,CAACH,OAAO,CAAC,CAAC,GAAG;MACzCI,KAAK,EAAEJ,OAAO;MACdK,aAAa,EAAE,EAAE;MACjBC,kBAAkB,EAAEtB,uBAAuB,CAACI,MAAM,EAAEY,OAAO;IAC/D,CAAC;EACL,CAAC,CAAC;;EAEF;EACA,IAAMO,YAAY,GAAG,CACjB,WAAW,EACXlB,WAAW,CACd;EACD,IAAMmB,SAAS,GAAGL,kBAAkB,CAACI,YAAY,CAAC;EAClDpB,KAAK,CAACe,OAAO,CAACM,SAAS,CAAC,GAAG;IACvBJ,KAAK,EAAEG,YAAY;IACnBF,aAAa,EAAE,EAAE;IACjBC,kBAAkB,EAAEtB,uBAAuB,CAACI,MAAM,EAAEmB,YAAY;EACpE,CAAC;AAEL;AAGA,OAAO,SAASJ,kBAAkB,CAACC,KAAe,EAAU;EACxD,OAAOA,KAAK,CAACK,IAAI,CAAC,GAAG,CAAC;AAC1B"}
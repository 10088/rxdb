{"version":3,"sources":["../../../../src/plugins/backup/index.ts"],"names":["path","BehaviorSubject","firstValueFrom","Subject","filter","map","newRxError","getFromMapOrThrow","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_TRUE","PROMISE_RESOLVE_VOID","clearFolder","deleteFolder","documentFolder","ensureFolderExists","getMeta","prepareFolders","setMeta","writeJsonToFile","writeToFile","backupSingleDocument","rxDocument","options","data","toJSON","writtenFiles","docFolder","primary","fileLocation","join","push","attachments","attachmentsFolder","allAttachments","Promise","all","attachment","getData","content","attachmentFileLocation","id","BACKUP_STATES_BY_DB","WeakMap","addToBackupStates","db","state","has","set","ar","RxBackupState","database","isStopped","subs","persistRunning","initialReplicationDone$","internalWriteEvents$","writeEvents$","asObservable","batchSize","persistOnce","then","_persistOnce","meta","Object","keys","collections","collectionName","processedDocuments","Set","collection","requestIdlePromise","collectionStates","lastSequence","hasMore","storageInstance","getChangedDocuments","sinceSequence","limit","direction","changesResult","docIds","changedDocuments","changedDocument","add","r","elem","pos","arr","indexOf","findByIds","docs","size","Array","from","values","doc","next","name","documentId","files","deleted","docId","getValue","watchForChanges","forEach","changes$","changeStream","sub","subscribe","awaitInitialBackup","pipe","v","cancel","unsubscribe","backup","backupState","live","RxDBBackupPlugin","rxdb","prototypes","RxDatabase","proto","hooks","preDestroyRxDatabase","states","get"],"mappings":"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","sourcesContent":["import * as path from 'path';\nimport {\n    BehaviorSubject,\n    firstValueFrom,\n    Observable,\n    Subject,\n    Subscription\n} from 'rxjs';\nimport {\n    filter,\n    map\n} from 'rxjs/operators';\nimport { newRxError } from '../../rx-error';\nimport type {\n    BackupOptions,\n    RxBackupWriteEvent,\n    RxCollection,\n    RxDatabase,\n    RxDocument,\n    RxPlugin\n} from '../../types';\nimport { getFromMapOrThrow, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_TRUE, PROMISE_RESOLVE_VOID } from '../../util';\nimport {\n    clearFolder,\n    deleteFolder,\n    documentFolder,\n    ensureFolderExists,\n    getMeta,\n    prepareFolders,\n    setMeta,\n    writeJsonToFile,\n    writeToFile\n} from './file-util';\n\n\n/**\n * Backups a single documents,\n * returns the paths to all written files\n */\nexport async function backupSingleDocument(\n    rxDocument: RxDocument<any, any>,\n    options: BackupOptions\n): Promise<string[]> {\n    const data = rxDocument.toJSON(true);\n    const writtenFiles: string[] = [];\n\n    const docFolder = documentFolder(options, rxDocument.primary);\n    await clearFolder(docFolder);\n\n    const fileLocation = path.join(\n        docFolder,\n        'document.json'\n    );\n    await writeJsonToFile(fileLocation, data);\n    writtenFiles.push(fileLocation);\n\n    if (options.attachments) {\n        const attachmentsFolder = path.join(\n            docFolder,\n            'attachments'\n        );\n        ensureFolderExists(attachmentsFolder);\n        const attachments = (rxDocument as RxDocument).allAttachments();\n        await Promise.all(\n            attachments\n                .map(async (attachment) => {\n                    const content = await attachment.getData();\n                    const attachmentFileLocation = path.join(\n                        attachmentsFolder,\n                        attachment.id\n                    );\n                    await writeToFile(attachmentFileLocation, content as Buffer);\n                    writtenFiles.push(attachmentFileLocation);\n                })\n        );\n    }\n\n    return writtenFiles;\n}\n\nconst BACKUP_STATES_BY_DB: WeakMap<RxDatabase, RxBackupState[]> = new WeakMap();\nfunction addToBackupStates(db: RxDatabase, state: RxBackupState) {\n    if (!BACKUP_STATES_BY_DB.has(db)) {\n        BACKUP_STATES_BY_DB.set(db, []);\n    }\n    const ar = getFromMapOrThrow(BACKUP_STATES_BY_DB, db);\n    if (!ar) {\n        throw newRxError('SNH');\n    }\n    ar.push(state);\n}\n\nexport class RxBackupState {\n    public isStopped: boolean = false;\n    private subs: Subscription[] = [];\n    private persistRunning: Promise<void> = PROMISE_RESOLVE_VOID;\n    private initialReplicationDone$: BehaviorSubject<boolean> = new BehaviorSubject(false as any);\n\n    private readonly internalWriteEvents$: Subject<RxBackupWriteEvent> = new Subject();\n    public readonly writeEvents$: Observable<RxBackupWriteEvent> = this.internalWriteEvents$.asObservable();\n\n    constructor(\n        public readonly database: RxDatabase,\n        public readonly options: BackupOptions\n    ) {\n        if (!this.options.batchSize) {\n            this.options.batchSize = 10;\n        }\n        addToBackupStates(database, this);\n        prepareFolders(database, options);\n    }\n\n    /**\n     * Persists all data from all collections,\n     * beginning from the oldest sequence checkpoint\n     * to the newest one.\n     * Do not call this while it is already running.\n     * Returns true if there are more documents to process\n     */\n    public async persistOnce() {\n        return this.persistRunning = this.persistRunning.then(() => this._persistOnce());\n    }\n\n    public async _persistOnce() {\n        const meta = await getMeta(this.options);\n\n        await Promise.all(\n            Object\n                .keys(this.database.collections)\n                .map(async (collectionName) => {\n                    const processedDocuments: Set<string> = new Set();\n                    const collection: RxCollection = this.database.collections[collectionName];\n\n                    await this.database.requestIdlePromise();\n\n                    if (!meta.collectionStates[collectionName]) {\n                        meta.collectionStates[collectionName] = {\n                            lastSequence: 0\n                        };\n                    }\n                    let lastSequence = meta.collectionStates[collectionName].lastSequence;\n\n                    let hasMore = true;\n                    while (hasMore && !this.isStopped) {\n                        await this.database.requestIdlePromise();\n\n                        const changesResult = await collection.storageInstance.getChangedDocuments({\n                            sinceSequence: lastSequence,\n                            limit: this.options.batchSize,\n                            direction: 'after'\n                        });\n                        lastSequence = changesResult.lastSequence;\n\n                        meta.collectionStates[collectionName].lastSequence = lastSequence;\n\n                        const docIds: string[] = changesResult.changedDocuments\n                            .filter(changedDocument => {\n                                if (\n                                    processedDocuments.has(changedDocument.id)\n                                ) {\n                                    return false;\n                                } else {\n                                    processedDocuments.add(changedDocument.id);\n                                    return true;\n                                }\n                            })\n                            .map(r => r.id)\n                            // unique\n                            .filter((elem, pos, arr) => arr.indexOf(elem) === pos);\n                        await this.database.requestIdlePromise();\n\n                        const docs: Map<string, RxDocument> = await collection.findByIds(docIds);\n                        if (docs.size === 0) {\n                            hasMore = false;\n                            continue;\n                        }\n                        await Promise.all(\n                            Array\n                                .from(docs.values())\n                                .map(async (doc) => {\n                                    const writtenFiles = await backupSingleDocument(doc, this.options);\n                                    this.internalWriteEvents$.next({\n                                        collectionName: collection.name,\n                                        documentId: doc.primary,\n                                        files: writtenFiles,\n                                        deleted: false\n                                    });\n                                })\n                        );\n                        // handle deleted documents\n                        await Promise.all(\n                            docIds\n                                .filter(docId => !docs.has(docId))\n                                .map(async (docId) => {\n                                    await deleteFolder(documentFolder(this.options, docId));\n                                    this.internalWriteEvents$.next({\n                                        collectionName: collection.name,\n                                        documentId: docId,\n                                        files: [],\n                                        deleted: true\n                                    });\n                                })\n                        );\n\n                    }\n\n                    meta.collectionStates[collectionName].lastSequence = lastSequence;\n                    await setMeta(this.options, meta);\n                })\n        );\n\n        if (!this.initialReplicationDone$.getValue()) {\n            this.initialReplicationDone$.next(true);\n        }\n    }\n\n    public watchForChanges() {\n        const collections: RxCollection[] = Object.values(this.database.collections);\n        collections.forEach(collection => {\n            const changes$ = collection.storageInstance.changeStream();\n            const sub = changes$.subscribe(() => {\n                this.persistOnce();\n            });\n            this.subs.push(sub);\n        });\n    }\n\n    /**\n     * Returns a promise that resolves when the initial backup is done\n     * and the filesystem is in sync with the database state\n     */\n    public awaitInitialBackup(): Promise<boolean> {\n        return firstValueFrom(\n            this.initialReplicationDone$.pipe(\n                filter(v => !!v),\n                map(() => true)\n            )\n        );\n    }\n\n    cancel(): Promise<boolean> {\n        if (this.isStopped) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n        this.isStopped = true;\n        this.subs.forEach(sub => sub.unsubscribe());\n        return PROMISE_RESOLVE_TRUE;\n    }\n}\n\n\nexport function backup(\n    this: RxDatabase,\n    options: BackupOptions\n): RxBackupState {\n    const backupState = new RxBackupState(this, options);\n    backupState.persistOnce();\n\n    if (options.live) {\n        backupState.watchForChanges();\n    }\n\n    return backupState;\n}\n\nexport * from './file-util';\nexport const RxDBBackupPlugin: RxPlugin = {\n    name: 'backup',\n    rxdb: true,\n    prototypes: {\n        RxDatabase(proto: any) {\n            proto.backup = backup;\n        }\n    },\n    hooks: {\n        preDestroyRxDatabase(db: RxDatabase) {\n            const states = BACKUP_STATES_BY_DB.get(db);\n            if (states) {\n                states.forEach(state => state.cancel());\n            }\n        }\n    }\n};\n"],"file":"index.js"}
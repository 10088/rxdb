{"version":3,"file":"check-schema.js","names":["objectPath","newRxError","getPrimaryFieldOfPrimaryKey","getSchemaByObjectPath","flattenObject","isMaybeReadonlyArray","trimDots","rxDocumentProperties","checkFieldNameRegex","fieldName","includes","regexStr","regex","RegExp","match","validateFieldsDeep","rxJsonSchema","primaryPath","primaryKey","checkField","schemaObj","path","Array","isArray","hasOwnProperty","type","required","length","items","isNested","split","primary","default","charAt","traverse","currentObj","currentPath","Object","keys","forEach","attributeName","properties","nextPath","checkPrimaryKey","jsonSchema","schema","validatePrimarySchemaPart","schemaPart","args","key","compositePrimaryKey","keySchemaPart","fields","field","primaryPathSchemaPart","maxLength","getSchemaPropertyRealPath","shortPath","pathParts","realPath","i","concat","checkSchema","_rev","version","value","indexes","unique","encrypted","index","indexAsArray","multipleOf","maximum","minimum","parentPath","lastPathPart","partParts","pop","join","parentSchemaPart","map","filter","elem","pos","arr","indexOf","get","replace","reduce","indexPaths","currentIndex","push","indexPath","propPath"],"sources":["../../../../src/plugins/dev-mode/check-schema.ts"],"sourcesContent":["/**\n * does additional checks over the schema-json\n * to ensure nothing is broken or not supported\n */\n\nimport objectPath from 'object-path';\nimport {\n    newRxError\n} from '../../rx-error';\nimport { getPrimaryFieldOfPrimaryKey, getSchemaByObjectPath } from '../../rx-schema-helper';\nimport type {\n    CompositePrimaryKey,\n    JsonSchema,\n    JsonSchemaTypes,\n    RxJsonSchema,\n    TopLevelProperty\n} from '../../types';\nimport {\n    flattenObject, isMaybeReadonlyArray,\n    trimDots\n} from '../../plugins/utils';\nimport { rxDocumentProperties } from './entity-properties';\n\n/**\n * checks if the fieldname is allowed\n * this makes sure that the fieldnames can be transformed into javascript-vars\n * and does not conquer the observe$ and populate_ fields\n * @throws {Error}\n */\nexport function checkFieldNameRegex(fieldName: string) {\n    if (fieldName === '_deleted') {\n        return;\n    }\n\n    if (['properties', 'language'].includes(fieldName)) {\n        throw newRxError('SC23', {\n            fieldName\n        });\n    }\n\n    const regexStr = '^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$';\n    const regex = new RegExp(regexStr);\n    if (\n        /**\n         * It must be allowed to set _id as primaryKey.\n         * This makes it sometimes easier to work with RxDB+CouchDB\n         * @link https://github.com/pubkey/rxdb/issues/681\n         */\n        fieldName !== '_id' &&\n        !fieldName.match(regex)\n    ) {\n        throw newRxError('SC1', {\n            regex: regexStr,\n            fieldName\n        });\n    }\n}\n\n/**\n * validate that all schema-related things are ok\n */\nexport function validateFieldsDeep(rxJsonSchema: RxJsonSchema<any>): true {\n\n    const primaryPath = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);\n\n    function checkField(\n        fieldName: string,\n        schemaObj: any,\n        path: string\n    ) {\n        if (\n            typeof fieldName === 'string' &&\n            typeof schemaObj === 'object' &&\n            !Array.isArray(schemaObj)\n        ) checkFieldNameRegex(fieldName);\n\n        // 'item' only allowed it type=='array'\n        if (schemaObj.hasOwnProperty('item') && schemaObj.type !== 'array') {\n            throw newRxError('SC2', {\n                fieldName\n            });\n        }\n\n        /**\n         * required fields cannot be set via 'required: true',\n         * but must be set via required: []\n         */\n        if (schemaObj.hasOwnProperty('required') && typeof schemaObj.required === 'boolean') {\n            throw newRxError('SC24', {\n                fieldName\n            });\n        }\n\n\n        // if ref given, must be type=='string', type=='array' with string-items or type==['string','null']\n        if (schemaObj.hasOwnProperty('ref')) {\n            if (Array.isArray(schemaObj.type)) {\n                if (schemaObj.type.length > 2 || !schemaObj.type.includes('string') || !schemaObj.type.includes('null')) {\n                    throw newRxError('SC4', {\n                        fieldName\n                    });\n                }\n            } else {\n                switch (schemaObj.type) {\n                    case 'string':\n                        break;\n                    case 'array':\n                        if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== 'string') {\n                            throw newRxError('SC3', {\n                                fieldName\n                            });\n                        }\n                        break;\n                    default:\n                        throw newRxError('SC4', {\n                            fieldName\n                        });\n                }\n            }\n        }\n\n        const isNested = path.split('.').length >= 2;\n\n        // nested only\n        if (isNested) {\n            if (schemaObj.primary) {\n                throw newRxError('SC6', {\n                    path,\n                    primary: schemaObj.primary\n                });\n            }\n\n            if (schemaObj.default) {\n                throw newRxError('SC7', {\n                    path\n                });\n            }\n        }\n\n        // first level\n        if (!isNested) {\n\n            // if _id is used, it must be primaryKey\n            if (\n                fieldName === '_id' &&\n                primaryPath !== '_id'\n            ) {\n                throw newRxError('COL2', {\n                    fieldName\n                });\n            }\n\n            // check underscore fields\n            if (fieldName.charAt(0) === '_') {\n                if (\n                    // exceptional allow underscore on these fields.\n                    fieldName === '_id' ||\n                    fieldName === '_deleted'\n                ) {\n                    return;\n                }\n                throw newRxError('SC8', {\n                    fieldName\n                });\n            }\n        }\n    }\n\n    function traverse(currentObj: any, currentPath: any) {\n        if (!currentObj || typeof currentObj !== 'object') return;\n        Object.keys(currentObj).forEach(attributeName => {\n            const schemaObj = currentObj[attributeName];\n            if (!currentObj.properties && schemaObj && typeof schemaObj === 'object') {\n                checkField(\n                    attributeName,\n                    schemaObj,\n                    currentPath\n                );\n            }\n            let nextPath = currentPath;\n            if (attributeName !== 'properties') nextPath = nextPath + '.' + attributeName;\n            traverse(schemaObj, nextPath);\n        });\n    }\n    traverse(rxJsonSchema, '');\n    return true;\n}\n\nexport function checkPrimaryKey(\n    jsonSchema: RxJsonSchema<any>\n) {\n    if (!jsonSchema.primaryKey) {\n        throw newRxError('SC30', { schema: jsonSchema });\n    }\n\n\n\n    function validatePrimarySchemaPart(\n        schemaPart: JsonSchema | TopLevelProperty\n    ) {\n        if (!schemaPart) {\n            throw newRxError('SC33', { schema: jsonSchema });\n        }\n\n        const type: string = schemaPart.type as any;\n        if (\n            !type ||\n            !['string', 'number', 'integer'].includes(type)\n        ) {\n            throw newRxError('SC32', { schema: jsonSchema, args: { schemaPart } });\n        }\n    }\n\n    if (typeof jsonSchema.primaryKey === 'string') {\n        const key = jsonSchema.primaryKey;\n        const schemaPart = jsonSchema.properties[key];\n        validatePrimarySchemaPart(schemaPart);\n    } else {\n        const compositePrimaryKey: CompositePrimaryKey<any> = jsonSchema.primaryKey as any;\n\n        const keySchemaPart = getSchemaByObjectPath(jsonSchema, compositePrimaryKey.key);\n        validatePrimarySchemaPart(keySchemaPart);\n\n        compositePrimaryKey.fields.forEach(field => {\n            const schemaPart = getSchemaByObjectPath(jsonSchema, field);\n            validatePrimarySchemaPart(schemaPart);\n        });\n    }\n\n\n    /**\n     * The primary key must have a maxLength set\n     * which is required by some RxStorage implementations\n     * to ensure we can craft custom index strings.\n     */\n    const primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);\n    const primaryPathSchemaPart = jsonSchema.properties[primaryPath];\n    if (!primaryPathSchemaPart.maxLength) {\n        throw newRxError('SC39', { schema: jsonSchema, args: { primaryPathSchemaPart } });\n    }\n}\n\n/**\n * computes real path of the object path in the collection schema\n */\nfunction getSchemaPropertyRealPath(shortPath: string) {\n    const pathParts = shortPath.split('.');\n    let realPath = '';\n    for (let i = 0; i < pathParts.length; i += 1) {\n        if (pathParts[i] !== '[]') {\n            realPath = realPath.concat('.properties.'.concat(pathParts[i]));\n        } else {\n            realPath = realPath.concat('.items');\n        }\n    }\n    return trimDots(realPath);\n}\n\n/**\n * does the checking\n * @throws {Error} if something is not ok\n */\nexport function checkSchema(jsonSchema: RxJsonSchema<any>) {\n\n    if (!jsonSchema.primaryKey) {\n        throw newRxError('SC30', {\n            schema: jsonSchema\n        });\n    }\n\n    if (!jsonSchema.hasOwnProperty('properties')) {\n        throw newRxError('SC29', {\n            schema: jsonSchema\n        });\n    }\n\n    // _rev MUST NOT exist, it is added by RxDB\n    if (jsonSchema.properties._rev) {\n        throw newRxError('SC10', {\n            schema: jsonSchema\n        });\n    }\n\n    // check version\n    if (!jsonSchema.hasOwnProperty('version') ||\n        typeof jsonSchema.version !== 'number' ||\n        jsonSchema.version < 0\n    ) {\n        throw newRxError('SC11', {\n            version: jsonSchema.version\n        });\n    }\n\n    validateFieldsDeep(jsonSchema);\n    checkPrimaryKey(jsonSchema);\n\n    Object.keys(jsonSchema.properties).forEach(key => {\n        const value: any = jsonSchema.properties[key];\n        // check primary\n        if (key === jsonSchema.primaryKey) {\n            if (jsonSchema.indexes && jsonSchema.indexes.includes(key)) {\n                throw newRxError('SC13', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n            if (value.unique) {\n                throw newRxError('SC14', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n            if (jsonSchema.encrypted && jsonSchema.encrypted.includes(key)) {\n                throw newRxError('SC15', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n            if (value.type !== 'string') {\n                throw newRxError('SC16', {\n                    value,\n                    schema: jsonSchema\n                });\n            }\n        }\n\n        // check if RxDocument-property\n        if (rxDocumentProperties().includes(key)) {\n            throw newRxError('SC17', {\n                key,\n                schema: jsonSchema\n            });\n        }\n    });\n\n    // check format of jsonSchema.indexes\n    if (jsonSchema.indexes) {\n        // should be an array\n        if (!isMaybeReadonlyArray(jsonSchema.indexes)) {\n            throw newRxError('SC18', {\n                indexes: jsonSchema.indexes,\n                schema: jsonSchema\n            });\n        }\n\n        jsonSchema.indexes.forEach(index => {\n            // should contain strings or array of strings\n            if (!(typeof index === 'string' || Array.isArray(index))) {\n                throw newRxError('SC19', { index, schema: jsonSchema });\n            }\n            // if is a compound index it must contain strings\n            if (Array.isArray(index)) {\n                for (let i = 0; i < index.length; i += 1) {\n                    if (typeof index[i] !== 'string') {\n                        throw newRxError('SC20', { index, schema: jsonSchema });\n                    }\n                }\n            }\n\n            /**\n             * To be able to craft custom indexable string with compound fields,\n             * we need to know the maximum fieldlength of the fields values\n             * when they are transformed to strings.\n             * Therefore we need to enforce some properties inside of the schema.\n             */\n            const indexAsArray = isMaybeReadonlyArray(index) ? index : [index];\n            indexAsArray.forEach(fieldName => {\n                const schemaPart = getSchemaByObjectPath(\n                    jsonSchema,\n                    fieldName\n                );\n\n\n                const type: JsonSchemaTypes = schemaPart.type as any;\n                switch (type) {\n                    case 'string':\n                        const maxLength = schemaPart.maxLength;\n                        if (!maxLength) {\n                            throw newRxError('SC34', {\n                                index,\n                                field: fieldName,\n                                schema: jsonSchema\n                            });\n                        }\n                        break;\n                    case 'number':\n                    case 'integer':\n                        const multipleOf = schemaPart.multipleOf;\n                        if (!multipleOf) {\n                            throw newRxError('SC35', {\n                                index,\n                                field: fieldName,\n                                schema: jsonSchema\n                            });\n                        }\n                        const maximum = schemaPart.maximum;\n                        const minimum = schemaPart.minimum;\n                        if (\n                            typeof maximum === 'undefined' ||\n                            typeof minimum === 'undefined'\n                        ) {\n                            throw newRxError('SC37', {\n                                index,\n                                field: fieldName,\n                                schema: jsonSchema\n                            });\n                        }\n                        break;\n                    case 'boolean':\n                        /**\n                         * If a boolean field is used as an index,\n                         * it must be required.\n                         */\n                        let parentPath = '';\n                        let lastPathPart = fieldName;\n                        if (fieldName.includes('.')) {\n                            const partParts = fieldName.split('.');\n                            lastPathPart = partParts.pop();\n                            parentPath = partParts.join('.');\n                        }\n                        const parentSchemaPart = parentPath === '' ? jsonSchema : getSchemaByObjectPath(\n                            jsonSchema,\n                            parentPath\n                        );\n\n                        if (\n                            !parentSchemaPart.required ||\n                            !parentSchemaPart.required.includes(lastPathPart)\n                        ) {\n                            throw newRxError('SC38', {\n                                index,\n                                field: fieldName,\n                                schema: jsonSchema\n                            });\n                        }\n                        break;\n\n                    default:\n                        throw newRxError('SC36', {\n                            fieldName,\n                            type: schemaPart.type as any,\n                            schema: jsonSchema,\n                        });\n                }\n            });\n\n        });\n    }\n\n    // remove backward-compatibility for index: true\n    Object.keys(flattenObject(jsonSchema))\n        .map(key => {\n            // flattenObject returns only ending paths, we need all paths pointing to an object\n            const split = key.split('.');\n            split.pop(); // all but last\n            return split.join('.');\n        })\n        .filter(key => key !== '')\n        .filter((elem, pos, arr) => arr.indexOf(elem) === pos) // unique\n        .filter(key => { // check if this path defines an index\n            const value = objectPath.get(jsonSchema, key);\n            return !!value.index;\n        })\n        .forEach(key => { // replace inner properties\n            key = key.replace('properties.', ''); // first\n            key = key.replace(/\\.properties\\./g, '.'); // middle\n            throw newRxError('SC26', {\n                index: trimDots(key),\n                schema: jsonSchema\n            });\n        });\n\n    /* check types of the indexes */\n    (jsonSchema.indexes || [])\n        .reduce((indexPaths: string[], currentIndex) => {\n            if (isMaybeReadonlyArray(currentIndex)) {\n                indexPaths.concat(currentIndex);\n            } else {\n                indexPaths.push(currentIndex);\n            }\n            return indexPaths;\n        }, [])\n        .filter((elem, pos, arr) => arr.indexOf(elem) === pos) // from now on working only with unique indexes\n        .map(indexPath => {\n            const realPath = getSchemaPropertyRealPath(indexPath); // real path in the collection schema\n            const schemaObj = objectPath.get(jsonSchema, realPath); // get the schema of the indexed property\n            if (!schemaObj || typeof schemaObj !== 'object') {\n                throw newRxError('SC21', {\n                    index: indexPath,\n                    schema: jsonSchema\n                });\n            }\n            return { indexPath, schemaObj };\n        })\n        .filter(index =>\n            index.schemaObj.type !== 'string' &&\n            index.schemaObj.type !== 'integer' &&\n            index.schemaObj.type !== 'number' &&\n            index.schemaObj.type !== 'boolean'\n        )\n        .forEach(index => {\n            throw newRxError('SC22', {\n                key: index.indexPath,\n                type: index.schemaObj.type,\n                schema: jsonSchema\n            });\n        });\n\n\n    /**\n     * TODO\n     * in 9.0.0 we changed the way encrypted fields are defined\n     * This check ensures people do not oversee the breaking change\n     * Remove this check in the future\n     */\n    Object.keys(flattenObject(jsonSchema))\n        .map(key => {\n            // flattenObject returns only ending paths, we need all paths pointing to an object\n            const split = key.split('.');\n            split.pop(); // all but last\n            return split.join('.');\n        })\n        .filter(key => key !== '' && key !== 'attachments')\n        .filter((elem, pos, arr) => arr.indexOf(elem) === pos) // unique\n        .filter(key => {\n            // check if this path defines an encrypted field\n            const value = objectPath.get(jsonSchema, key);\n            return !!value.encrypted;\n        })\n        .forEach(key => { // replace inner properties\n            key = key.replace('properties.', ''); // first\n            key = key.replace(/\\.properties\\./g, '.'); // middle\n            throw newRxError('SC27', {\n                index: trimDots(key),\n                schema: jsonSchema\n            });\n        });\n\n    /* ensure encrypted fields exist in the schema */\n    if (jsonSchema.encrypted) {\n        jsonSchema.encrypted\n            .forEach(propPath => {\n                // real path in the collection schema\n                const realPath = getSchemaPropertyRealPath(propPath);\n                // get the schema of the indexed property\n                const schemaObj = objectPath.get(jsonSchema, realPath);\n                if (!schemaObj || typeof schemaObj !== 'object') {\n                    throw newRxError('SC28', {\n                        field: propPath,\n                        schema: jsonSchema\n                    });\n                }\n            });\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,OAAOA,UAAU,MAAM,aAAa;AACpC,SACIC,UAAU,QACP,gBAAgB;AACvB,SAASC,2BAA2B,EAAEC,qBAAqB,QAAQ,wBAAwB;AAQ3F,SACIC,aAAa,EAAEC,oBAAoB,EACnCC,QAAQ,QACL,qBAAqB;AAC5B,SAASC,oBAAoB,QAAQ,qBAAqB;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,mBAAmB,CAACC,SAAiB,EAAE;EACnD,IAAIA,SAAS,KAAK,UAAU,EAAE;IAC1B;EACJ;EAEA,IAAI,CAAC,YAAY,EAAE,UAAU,CAAC,CAACC,QAAQ,CAACD,SAAS,CAAC,EAAE;IAChD,MAAMR,UAAU,CAAC,MAAM,EAAE;MACrBQ;IACJ,CAAC,CAAC;EACN;EAEA,IAAME,QAAQ,GAAG,4CAA4C;EAC7D,IAAMC,KAAK,GAAG,IAAIC,MAAM,CAACF,QAAQ,CAAC;EAClC;EACI;AACR;AACA;AACA;AACA;EACQF,SAAS,KAAK,KAAK,IACnB,CAACA,SAAS,CAACK,KAAK,CAACF,KAAK,CAAC,EACzB;IACE,MAAMX,UAAU,CAAC,KAAK,EAAE;MACpBW,KAAK,EAAED,QAAQ;MACfF;IACJ,CAAC,CAAC;EACN;AACJ;;AAEA;AACA;AACA;AACA,OAAO,SAASM,kBAAkB,CAACC,YAA+B,EAAQ;EAEtE,IAAMC,WAAW,GAAGf,2BAA2B,CAACc,YAAY,CAACE,UAAU,CAAC;EAExE,SAASC,UAAU,CACfV,SAAiB,EACjBW,SAAc,EACdC,IAAY,EACd;IACE,IACI,OAAOZ,SAAS,KAAK,QAAQ,IAC7B,OAAOW,SAAS,KAAK,QAAQ,IAC7B,CAACE,KAAK,CAACC,OAAO,CAACH,SAAS,CAAC,EAC3BZ,mBAAmB,CAACC,SAAS,CAAC;;IAEhC;IACA,IAAIW,SAAS,CAACI,cAAc,CAAC,MAAM,CAAC,IAAIJ,SAAS,CAACK,IAAI,KAAK,OAAO,EAAE;MAChE,MAAMxB,UAAU,CAAC,KAAK,EAAE;QACpBQ;MACJ,CAAC,CAAC;IACN;;IAEA;AACR;AACA;AACA;IACQ,IAAIW,SAAS,CAACI,cAAc,CAAC,UAAU,CAAC,IAAI,OAAOJ,SAAS,CAACM,QAAQ,KAAK,SAAS,EAAE;MACjF,MAAMzB,UAAU,CAAC,MAAM,EAAE;QACrBQ;MACJ,CAAC,CAAC;IACN;;IAGA;IACA,IAAIW,SAAS,CAACI,cAAc,CAAC,KAAK,CAAC,EAAE;MACjC,IAAIF,KAAK,CAACC,OAAO,CAACH,SAAS,CAACK,IAAI,CAAC,EAAE;QAC/B,IAAIL,SAAS,CAACK,IAAI,CAACE,MAAM,GAAG,CAAC,IAAI,CAACP,SAAS,CAACK,IAAI,CAACf,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAACU,SAAS,CAACK,IAAI,CAACf,QAAQ,CAAC,MAAM,CAAC,EAAE;UACrG,MAAMT,UAAU,CAAC,KAAK,EAAE;YACpBQ;UACJ,CAAC,CAAC;QACN;MACJ,CAAC,MAAM;QACH,QAAQW,SAAS,CAACK,IAAI;UAClB,KAAK,QAAQ;YACT;UACJ,KAAK,OAAO;YACR,IAAI,CAACL,SAAS,CAACQ,KAAK,IAAI,CAACR,SAAS,CAACQ,KAAK,CAACH,IAAI,IAAIL,SAAS,CAACQ,KAAK,CAACH,IAAI,KAAK,QAAQ,EAAE;cAChF,MAAMxB,UAAU,CAAC,KAAK,EAAE;gBACpBQ;cACJ,CAAC,CAAC;YACN;YACA;UACJ;YACI,MAAMR,UAAU,CAAC,KAAK,EAAE;cACpBQ;YACJ,CAAC,CAAC;QAAC;MAEf;IACJ;IAEA,IAAMoB,QAAQ,GAAGR,IAAI,CAACS,KAAK,CAAC,GAAG,CAAC,CAACH,MAAM,IAAI,CAAC;;IAE5C;IACA,IAAIE,QAAQ,EAAE;MACV,IAAIT,SAAS,CAACW,OAAO,EAAE;QACnB,MAAM9B,UAAU,CAAC,KAAK,EAAE;UACpBoB,IAAI;UACJU,OAAO,EAAEX,SAAS,CAACW;QACvB,CAAC,CAAC;MACN;MAEA,IAAIX,SAAS,CAACY,OAAO,EAAE;QACnB,MAAM/B,UAAU,CAAC,KAAK,EAAE;UACpBoB;QACJ,CAAC,CAAC;MACN;IACJ;;IAEA;IACA,IAAI,CAACQ,QAAQ,EAAE;MAEX;MACA,IACIpB,SAAS,KAAK,KAAK,IACnBQ,WAAW,KAAK,KAAK,EACvB;QACE,MAAMhB,UAAU,CAAC,MAAM,EAAE;UACrBQ;QACJ,CAAC,CAAC;MACN;;MAEA;MACA,IAAIA,SAAS,CAACwB,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC7B;QACI;QACAxB,SAAS,KAAK,KAAK,IACnBA,SAAS,KAAK,UAAU,EAC1B;UACE;QACJ;QACA,MAAMR,UAAU,CAAC,KAAK,EAAE;UACpBQ;QACJ,CAAC,CAAC;MACN;IACJ;EACJ;EAEA,SAASyB,QAAQ,CAACC,UAAe,EAAEC,WAAgB,EAAE;IACjD,IAAI,CAACD,UAAU,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;IACnDE,MAAM,CAACC,IAAI,CAACH,UAAU,CAAC,CAACI,OAAO,CAACC,aAAa,IAAI;MAC7C,IAAMpB,SAAS,GAAGe,UAAU,CAACK,aAAa,CAAC;MAC3C,IAAI,CAACL,UAAU,CAACM,UAAU,IAAIrB,SAAS,IAAI,OAAOA,SAAS,KAAK,QAAQ,EAAE;QACtED,UAAU,CACNqB,aAAa,EACbpB,SAAS,EACTgB,WAAW,CACd;MACL;MACA,IAAIM,QAAQ,GAAGN,WAAW;MAC1B,IAAII,aAAa,KAAK,YAAY,EAAEE,QAAQ,GAAGA,QAAQ,GAAG,GAAG,GAAGF,aAAa;MAC7EN,QAAQ,CAACd,SAAS,EAAEsB,QAAQ,CAAC;IACjC,CAAC,CAAC;EACN;EACAR,QAAQ,CAAClB,YAAY,EAAE,EAAE,CAAC;EAC1B,OAAO,IAAI;AACf;AAEA,OAAO,SAAS2B,eAAe,CAC3BC,UAA6B,EAC/B;EACE,IAAI,CAACA,UAAU,CAAC1B,UAAU,EAAE;IACxB,MAAMjB,UAAU,CAAC,MAAM,EAAE;MAAE4C,MAAM,EAAED;IAAW,CAAC,CAAC;EACpD;EAIA,SAASE,yBAAyB,CAC9BC,UAAyC,EAC3C;IACE,IAAI,CAACA,UAAU,EAAE;MACb,MAAM9C,UAAU,CAAC,MAAM,EAAE;QAAE4C,MAAM,EAAED;MAAW,CAAC,CAAC;IACpD;IAEA,IAAMnB,IAAY,GAAGsB,UAAU,CAACtB,IAAW;IAC3C,IACI,CAACA,IAAI,IACL,CAAC,CAAC,QAAQ,EAAE,QAAQ,EAAE,SAAS,CAAC,CAACf,QAAQ,CAACe,IAAI,CAAC,EACjD;MACE,MAAMxB,UAAU,CAAC,MAAM,EAAE;QAAE4C,MAAM,EAAED,UAAU;QAAEI,IAAI,EAAE;UAAED;QAAW;MAAE,CAAC,CAAC;IAC1E;EACJ;EAEA,IAAI,OAAOH,UAAU,CAAC1B,UAAU,KAAK,QAAQ,EAAE;IAC3C,IAAM+B,GAAG,GAAGL,UAAU,CAAC1B,UAAU;IACjC,IAAM6B,UAAU,GAAGH,UAAU,CAACH,UAAU,CAACQ,GAAG,CAAC;IAC7CH,yBAAyB,CAACC,UAAU,CAAC;EACzC,CAAC,MAAM;IACH,IAAMG,mBAA6C,GAAGN,UAAU,CAAC1B,UAAiB;IAElF,IAAMiC,aAAa,GAAGhD,qBAAqB,CAACyC,UAAU,EAAEM,mBAAmB,CAACD,GAAG,CAAC;IAChFH,yBAAyB,CAACK,aAAa,CAAC;IAExCD,mBAAmB,CAACE,MAAM,CAACb,OAAO,CAACc,KAAK,IAAI;MACxC,IAAMN,UAAU,GAAG5C,qBAAqB,CAACyC,UAAU,EAAES,KAAK,CAAC;MAC3DP,yBAAyB,CAACC,UAAU,CAAC;IACzC,CAAC,CAAC;EACN;;EAGA;AACJ;AACA;AACA;AACA;EACI,IAAM9B,WAAW,GAAGf,2BAA2B,CAAC0C,UAAU,CAAC1B,UAAU,CAAC;EACtE,IAAMoC,qBAAqB,GAAGV,UAAU,CAACH,UAAU,CAACxB,WAAW,CAAC;EAChE,IAAI,CAACqC,qBAAqB,CAACC,SAAS,EAAE;IAClC,MAAMtD,UAAU,CAAC,MAAM,EAAE;MAAE4C,MAAM,EAAED,UAAU;MAAEI,IAAI,EAAE;QAAEM;MAAsB;IAAE,CAAC,CAAC;EACrF;AACJ;;AAEA;AACA;AACA;AACA,SAASE,yBAAyB,CAACC,SAAiB,EAAE;EAClD,IAAMC,SAAS,GAAGD,SAAS,CAAC3B,KAAK,CAAC,GAAG,CAAC;EACtC,IAAI6B,QAAQ,GAAG,EAAE;EACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAAC/B,MAAM,EAAEiC,CAAC,IAAI,CAAC,EAAE;IAC1C,IAAIF,SAAS,CAACE,CAAC,CAAC,KAAK,IAAI,EAAE;MACvBD,QAAQ,GAAGA,QAAQ,CAACE,MAAM,CAAC,cAAc,CAACA,MAAM,CAACH,SAAS,CAACE,CAAC,CAAC,CAAC,CAAC;IACnE,CAAC,MAAM;MACHD,QAAQ,GAAGA,QAAQ,CAACE,MAAM,CAAC,QAAQ,CAAC;IACxC;EACJ;EACA,OAAOvD,QAAQ,CAACqD,QAAQ,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASG,WAAW,CAAClB,UAA6B,EAAE;EAEvD,IAAI,CAACA,UAAU,CAAC1B,UAAU,EAAE;IACxB,MAAMjB,UAAU,CAAC,MAAM,EAAE;MACrB4C,MAAM,EAAED;IACZ,CAAC,CAAC;EACN;EAEA,IAAI,CAACA,UAAU,CAACpB,cAAc,CAAC,YAAY,CAAC,EAAE;IAC1C,MAAMvB,UAAU,CAAC,MAAM,EAAE;MACrB4C,MAAM,EAAED;IACZ,CAAC,CAAC;EACN;;EAEA;EACA,IAAIA,UAAU,CAACH,UAAU,CAACsB,IAAI,EAAE;IAC5B,MAAM9D,UAAU,CAAC,MAAM,EAAE;MACrB4C,MAAM,EAAED;IACZ,CAAC,CAAC;EACN;;EAEA;EACA,IAAI,CAACA,UAAU,CAACpB,cAAc,CAAC,SAAS,CAAC,IACrC,OAAOoB,UAAU,CAACoB,OAAO,KAAK,QAAQ,IACtCpB,UAAU,CAACoB,OAAO,GAAG,CAAC,EACxB;IACE,MAAM/D,UAAU,CAAC,MAAM,EAAE;MACrB+D,OAAO,EAAEpB,UAAU,CAACoB;IACxB,CAAC,CAAC;EACN;EAEAjD,kBAAkB,CAAC6B,UAAU,CAAC;EAC9BD,eAAe,CAACC,UAAU,CAAC;EAE3BP,MAAM,CAACC,IAAI,CAACM,UAAU,CAACH,UAAU,CAAC,CAACF,OAAO,CAACU,GAAG,IAAI;IAC9C,IAAMgB,KAAU,GAAGrB,UAAU,CAACH,UAAU,CAACQ,GAAG,CAAC;IAC7C;IACA,IAAIA,GAAG,KAAKL,UAAU,CAAC1B,UAAU,EAAE;MAC/B,IAAI0B,UAAU,CAACsB,OAAO,IAAItB,UAAU,CAACsB,OAAO,CAACxD,QAAQ,CAACuC,GAAG,CAAC,EAAE;QACxD,MAAMhD,UAAU,CAAC,MAAM,EAAE;UACrBgE,KAAK;UACLpB,MAAM,EAAED;QACZ,CAAC,CAAC;MACN;MACA,IAAIqB,KAAK,CAACE,MAAM,EAAE;QACd,MAAMlE,UAAU,CAAC,MAAM,EAAE;UACrBgE,KAAK;UACLpB,MAAM,EAAED;QACZ,CAAC,CAAC;MACN;MACA,IAAIA,UAAU,CAACwB,SAAS,IAAIxB,UAAU,CAACwB,SAAS,CAAC1D,QAAQ,CAACuC,GAAG,CAAC,EAAE;QAC5D,MAAMhD,UAAU,CAAC,MAAM,EAAE;UACrBgE,KAAK;UACLpB,MAAM,EAAED;QACZ,CAAC,CAAC;MACN;MACA,IAAIqB,KAAK,CAACxC,IAAI,KAAK,QAAQ,EAAE;QACzB,MAAMxB,UAAU,CAAC,MAAM,EAAE;UACrBgE,KAAK;UACLpB,MAAM,EAAED;QACZ,CAAC,CAAC;MACN;IACJ;;IAEA;IACA,IAAIrC,oBAAoB,EAAE,CAACG,QAAQ,CAACuC,GAAG,CAAC,EAAE;MACtC,MAAMhD,UAAU,CAAC,MAAM,EAAE;QACrBgD,GAAG;QACHJ,MAAM,EAAED;MACZ,CAAC,CAAC;IACN;EACJ,CAAC,CAAC;;EAEF;EACA,IAAIA,UAAU,CAACsB,OAAO,EAAE;IACpB;IACA,IAAI,CAAC7D,oBAAoB,CAACuC,UAAU,CAACsB,OAAO,CAAC,EAAE;MAC3C,MAAMjE,UAAU,CAAC,MAAM,EAAE;QACrBiE,OAAO,EAAEtB,UAAU,CAACsB,OAAO;QAC3BrB,MAAM,EAAED;MACZ,CAAC,CAAC;IACN;IAEAA,UAAU,CAACsB,OAAO,CAAC3B,OAAO,CAAC8B,KAAK,IAAI;MAChC;MACA,IAAI,EAAE,OAAOA,KAAK,KAAK,QAAQ,IAAI/C,KAAK,CAACC,OAAO,CAAC8C,KAAK,CAAC,CAAC,EAAE;QACtD,MAAMpE,UAAU,CAAC,MAAM,EAAE;UAAEoE,KAAK;UAAExB,MAAM,EAAED;QAAW,CAAC,CAAC;MAC3D;MACA;MACA,IAAItB,KAAK,CAACC,OAAO,CAAC8C,KAAK,CAAC,EAAE;QACtB,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,KAAK,CAAC1C,MAAM,EAAEiC,CAAC,IAAI,CAAC,EAAE;UACtC,IAAI,OAAOS,KAAK,CAACT,CAAC,CAAC,KAAK,QAAQ,EAAE;YAC9B,MAAM3D,UAAU,CAAC,MAAM,EAAE;cAAEoE,KAAK;cAAExB,MAAM,EAAED;YAAW,CAAC,CAAC;UAC3D;QACJ;MACJ;;MAEA;AACZ;AACA;AACA;AACA;AACA;MACY,IAAM0B,YAAY,GAAGjE,oBAAoB,CAACgE,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC;MAClEC,YAAY,CAAC/B,OAAO,CAAC9B,SAAS,IAAI;QAC9B,IAAMsC,UAAU,GAAG5C,qBAAqB,CACpCyC,UAAU,EACVnC,SAAS,CACZ;QAGD,IAAMgB,IAAqB,GAAGsB,UAAU,CAACtB,IAAW;QACpD,QAAQA,IAAI;UACR,KAAK,QAAQ;YACT,IAAM8B,SAAS,GAAGR,UAAU,CAACQ,SAAS;YACtC,IAAI,CAACA,SAAS,EAAE;cACZ,MAAMtD,UAAU,CAAC,MAAM,EAAE;gBACrBoE,KAAK;gBACLhB,KAAK,EAAE5C,SAAS;gBAChBoC,MAAM,EAAED;cACZ,CAAC,CAAC;YACN;YACA;UACJ,KAAK,QAAQ;UACb,KAAK,SAAS;YACV,IAAM2B,UAAU,GAAGxB,UAAU,CAACwB,UAAU;YACxC,IAAI,CAACA,UAAU,EAAE;cACb,MAAMtE,UAAU,CAAC,MAAM,EAAE;gBACrBoE,KAAK;gBACLhB,KAAK,EAAE5C,SAAS;gBAChBoC,MAAM,EAAED;cACZ,CAAC,CAAC;YACN;YACA,IAAM4B,OAAO,GAAGzB,UAAU,CAACyB,OAAO;YAClC,IAAMC,OAAO,GAAG1B,UAAU,CAAC0B,OAAO;YAClC,IACI,OAAOD,OAAO,KAAK,WAAW,IAC9B,OAAOC,OAAO,KAAK,WAAW,EAChC;cACE,MAAMxE,UAAU,CAAC,MAAM,EAAE;gBACrBoE,KAAK;gBACLhB,KAAK,EAAE5C,SAAS;gBAChBoC,MAAM,EAAED;cACZ,CAAC,CAAC;YACN;YACA;UACJ,KAAK,SAAS;YACV;AACxB;AACA;AACA;YACwB,IAAI8B,UAAU,GAAG,EAAE;YACnB,IAAIC,YAAY,GAAGlE,SAAS;YAC5B,IAAIA,SAAS,CAACC,QAAQ,CAAC,GAAG,CAAC,EAAE;cACzB,IAAMkE,SAAS,GAAGnE,SAAS,CAACqB,KAAK,CAAC,GAAG,CAAC;cACtC6C,YAAY,GAAGC,SAAS,CAACC,GAAG,EAAE;cAC9BH,UAAU,GAAGE,SAAS,CAACE,IAAI,CAAC,GAAG,CAAC;YACpC;YACA,IAAMC,gBAAgB,GAAGL,UAAU,KAAK,EAAE,GAAG9B,UAAU,GAAGzC,qBAAqB,CAC3EyC,UAAU,EACV8B,UAAU,CACb;YAED,IACI,CAACK,gBAAgB,CAACrD,QAAQ,IAC1B,CAACqD,gBAAgB,CAACrD,QAAQ,CAAChB,QAAQ,CAACiE,YAAY,CAAC,EACnD;cACE,MAAM1E,UAAU,CAAC,MAAM,EAAE;gBACrBoE,KAAK;gBACLhB,KAAK,EAAE5C,SAAS;gBAChBoC,MAAM,EAAED;cACZ,CAAC,CAAC;YACN;YACA;UAEJ;YACI,MAAM3C,UAAU,CAAC,MAAM,EAAE;cACrBQ,SAAS;cACTgB,IAAI,EAAEsB,UAAU,CAACtB,IAAW;cAC5BoB,MAAM,EAAED;YACZ,CAAC,CAAC;QAAC;MAEf,CAAC,CAAC;IAEN,CAAC,CAAC;EACN;;EAEA;EACAP,MAAM,CAACC,IAAI,CAAClC,aAAa,CAACwC,UAAU,CAAC,CAAC,CACjCoC,GAAG,CAAC/B,GAAG,IAAI;IACR;IACA,IAAMnB,KAAK,GAAGmB,GAAG,CAACnB,KAAK,CAAC,GAAG,CAAC;IAC5BA,KAAK,CAAC+C,GAAG,EAAE,CAAC,CAAC;IACb,OAAO/C,KAAK,CAACgD,IAAI,CAAC,GAAG,CAAC;EAC1B,CAAC,CAAC,CACDG,MAAM,CAAChC,GAAG,IAAIA,GAAG,KAAK,EAAE,CAAC,CACzBgC,MAAM,CAAC,CAACC,IAAI,EAAEC,GAAG,EAAEC,GAAG,KAAKA,GAAG,CAACC,OAAO,CAACH,IAAI,CAAC,KAAKC,GAAG,CAAC,CAAC;EAAA,CACtDF,MAAM,CAAChC,GAAG,IAAI;IAAE;IACb,IAAMgB,KAAK,GAAGjE,UAAU,CAACsF,GAAG,CAAC1C,UAAU,EAAEK,GAAG,CAAC;IAC7C,OAAO,CAAC,CAACgB,KAAK,CAACI,KAAK;EACxB,CAAC,CAAC,CACD9B,OAAO,CAACU,GAAG,IAAI;IAAE;IACdA,GAAG,GAAGA,GAAG,CAACsC,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC,CAAC;IACtCtC,GAAG,GAAGA,GAAG,CAACsC,OAAO,CAAC,iBAAiB,EAAE,GAAG,CAAC,CAAC,CAAC;IAC3C,MAAMtF,UAAU,CAAC,MAAM,EAAE;MACrBoE,KAAK,EAAE/D,QAAQ,CAAC2C,GAAG,CAAC;MACpBJ,MAAM,EAAED;IACZ,CAAC,CAAC;EACN,CAAC,CAAC;;EAEN;EACA,CAACA,UAAU,CAACsB,OAAO,IAAI,EAAE,EACpBsB,MAAM,CAAC,CAACC,UAAoB,EAAEC,YAAY,KAAK;IAC5C,IAAIrF,oBAAoB,CAACqF,YAAY,CAAC,EAAE;MACpCD,UAAU,CAAC5B,MAAM,CAAC6B,YAAY,CAAC;IACnC,CAAC,MAAM;MACHD,UAAU,CAACE,IAAI,CAACD,YAAY,CAAC;IACjC;IACA,OAAOD,UAAU;EACrB,CAAC,EAAE,EAAE,CAAC,CACLR,MAAM,CAAC,CAACC,IAAI,EAAEC,GAAG,EAAEC,GAAG,KAAKA,GAAG,CAACC,OAAO,CAACH,IAAI,CAAC,KAAKC,GAAG,CAAC,CAAC;EAAA,CACtDH,GAAG,CAACY,SAAS,IAAI;IACd,IAAMjC,QAAQ,GAAGH,yBAAyB,CAACoC,SAAS,CAAC,CAAC,CAAC;IACvD,IAAMxE,SAAS,GAAGpB,UAAU,CAACsF,GAAG,CAAC1C,UAAU,EAAEe,QAAQ,CAAC,CAAC,CAAC;IACxD,IAAI,CAACvC,SAAS,IAAI,OAAOA,SAAS,KAAK,QAAQ,EAAE;MAC7C,MAAMnB,UAAU,CAAC,MAAM,EAAE;QACrBoE,KAAK,EAAEuB,SAAS;QAChB/C,MAAM,EAAED;MACZ,CAAC,CAAC;IACN;IACA,OAAO;MAAEgD,SAAS;MAAExE;IAAU,CAAC;EACnC,CAAC,CAAC,CACD6D,MAAM,CAACZ,KAAK,IACTA,KAAK,CAACjD,SAAS,CAACK,IAAI,KAAK,QAAQ,IACjC4C,KAAK,CAACjD,SAAS,CAACK,IAAI,KAAK,SAAS,IAClC4C,KAAK,CAACjD,SAAS,CAACK,IAAI,KAAK,QAAQ,IACjC4C,KAAK,CAACjD,SAAS,CAACK,IAAI,KAAK,SAAS,CACrC,CACAc,OAAO,CAAC8B,KAAK,IAAI;IACd,MAAMpE,UAAU,CAAC,MAAM,EAAE;MACrBgD,GAAG,EAAEoB,KAAK,CAACuB,SAAS;MACpBnE,IAAI,EAAE4C,KAAK,CAACjD,SAAS,CAACK,IAAI;MAC1BoB,MAAM,EAAED;IACZ,CAAC,CAAC;EACN,CAAC,CAAC;;EAGN;AACJ;AACA;AACA;AACA;AACA;EACIP,MAAM,CAACC,IAAI,CAAClC,aAAa,CAACwC,UAAU,CAAC,CAAC,CACjCoC,GAAG,CAAC/B,GAAG,IAAI;IACR;IACA,IAAMnB,KAAK,GAAGmB,GAAG,CAACnB,KAAK,CAAC,GAAG,CAAC;IAC5BA,KAAK,CAAC+C,GAAG,EAAE,CAAC,CAAC;IACb,OAAO/C,KAAK,CAACgD,IAAI,CAAC,GAAG,CAAC;EAC1B,CAAC,CAAC,CACDG,MAAM,CAAChC,GAAG,IAAIA,GAAG,KAAK,EAAE,IAAIA,GAAG,KAAK,aAAa,CAAC,CAClDgC,MAAM,CAAC,CAACC,IAAI,EAAEC,GAAG,EAAEC,GAAG,KAAKA,GAAG,CAACC,OAAO,CAACH,IAAI,CAAC,KAAKC,GAAG,CAAC,CAAC;EAAA,CACtDF,MAAM,CAAChC,GAAG,IAAI;IACX;IACA,IAAMgB,KAAK,GAAGjE,UAAU,CAACsF,GAAG,CAAC1C,UAAU,EAAEK,GAAG,CAAC;IAC7C,OAAO,CAAC,CAACgB,KAAK,CAACG,SAAS;EAC5B,CAAC,CAAC,CACD7B,OAAO,CAACU,GAAG,IAAI;IAAE;IACdA,GAAG,GAAGA,GAAG,CAACsC,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC,CAAC;IACtCtC,GAAG,GAAGA,GAAG,CAACsC,OAAO,CAAC,iBAAiB,EAAE,GAAG,CAAC,CAAC,CAAC;IAC3C,MAAMtF,UAAU,CAAC,MAAM,EAAE;MACrBoE,KAAK,EAAE/D,QAAQ,CAAC2C,GAAG,CAAC;MACpBJ,MAAM,EAAED;IACZ,CAAC,CAAC;EACN,CAAC,CAAC;;EAEN;EACA,IAAIA,UAAU,CAACwB,SAAS,EAAE;IACtBxB,UAAU,CAACwB,SAAS,CACf7B,OAAO,CAACsD,QAAQ,IAAI;MACjB;MACA,IAAMlC,QAAQ,GAAGH,yBAAyB,CAACqC,QAAQ,CAAC;MACpD;MACA,IAAMzE,SAAS,GAAGpB,UAAU,CAACsF,GAAG,CAAC1C,UAAU,EAAEe,QAAQ,CAAC;MACtD,IAAI,CAACvC,SAAS,IAAI,OAAOA,SAAS,KAAK,QAAQ,EAAE;QAC7C,MAAMnB,UAAU,CAAC,MAAM,EAAE;UACrBoD,KAAK,EAAEwC,QAAQ;UACfhD,MAAM,EAAED;QACZ,CAAC,CAAC;MACN;IACJ,CAAC,CAAC;EACV;AACJ"}
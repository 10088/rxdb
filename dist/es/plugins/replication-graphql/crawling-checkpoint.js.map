{"version":3,"sources":["../../../../src/plugins/replication-graphql/crawling-checkpoint.ts"],"names":["wasRevisionfromPullReplication","GRAPHQL_REPLICATION_PLUGIN_IDENT","findLocalDocument","writeSingleLocal","flatClone","newRxError","runPluginHooks","pushSequenceId","endpointHash","getLastPushSequence","collection","localDocumentsStore","doc","value","setLastPushSequence","sequence","_id","document","_attachments","res","newDoc","previous","getChangesSinceLastPushSequence","batchSize","lastPushSequence","retry","lastSequence","changedDocs","Map","storageInstance","getChangedDocuments","sinceSequence","limit","direction","changesResults","changedDocuments","length","findDocumentsById","map","row","id","plainDocs","docs","Array","from","entries","docId","docData","hookParams","set","forEach","has","changedDoc","get","args","_rev","size","pullLastDocumentId","getLastPullDocument","localDoc","setLastPullDocument"],"mappings":"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","sourcesContent":["import {\n    wasRevisionfromPullReplication,\n    GRAPHQL_REPLICATION_PLUGIN_IDENT\n} from './helper';\nimport type {\n    RxCollection,\n    RxLocalDocumentData,\n    RxDocumentData\n} from '../../types';\nimport {\n    findLocalDocument,\n    writeSingleLocal\n} from '../../rx-storage-helper';\nimport { flatClone } from '../../util';\nimport { newRxError } from '../../rx-error';\nimport { runPluginHooks } from '../../hooks';\n\n/**\n * when the replication starts,\n * we need a way to find out where it ended the last time.\n *\n * For push-replication, we use the storageInstance-sequence:\n * We get the documents newer then the last sequence-id\n * and push them to the server.\n *\n * For pull-replication, we use the last document we got from the server:\n * We send the last document to the queryBuilder()\n * and recieve newer documents sorted in a batch\n */\n\n\n\n//\n// things for the push-checkpoint\n//\n\nconst pushSequenceId = (endpointHash: string) => GRAPHQL_REPLICATION_PLUGIN_IDENT + '-push-checkpoint-' + endpointHash;\n\n/**\n * @return last sequence checkpoint\n */\nexport async function getLastPushSequence(\n    collection: RxCollection,\n    endpointHash: string\n): Promise<number> {\n    const doc = await findLocalDocument<CheckpointDoc>(\n        collection.localDocumentsStore,\n        pushSequenceId(endpointHash)\n    );\n    if (!doc) {\n        return 0;\n    } else {\n        return doc.value;\n    }\n}\n\ndeclare type CheckpointDoc = { _id: string; value: number; };\n\nexport async function setLastPushSequence(\n    collection: RxCollection,\n    endpointHash: string,\n    sequence: number\n): Promise<CheckpointDoc> {\n    const _id = pushSequenceId(endpointHash);\n\n    const doc = await findLocalDocument<CheckpointDoc>(\n        collection.localDocumentsStore,\n        _id\n    );\n    if (!doc) {\n        const res = await writeSingleLocal<CheckpointDoc>(\n            collection.localDocumentsStore,\n            {\n                document: {\n                    _id,\n                    value: sequence,\n                    _attachments: {}\n                }\n            }\n        );\n        return res as any;\n    } else {\n        const newDoc = flatClone(doc);\n        newDoc.value = sequence;\n        const res = await writeSingleLocal<CheckpointDoc>(\n            collection.localDocumentsStore,\n            {\n                previous: doc,\n                document: {\n                    _id,\n                    value: sequence,\n                    _attachments: {}\n                }\n            }\n        );\n        return res as any;\n    }\n}\n\n\nexport async function getChangesSinceLastPushSequence<RxDocType>(\n    collection: RxCollection<RxDocType, any>,\n    endpointHash: string,\n    batchSize = 10\n): Promise<{\n    changedDocs: Map<string, {\n        id: string;\n        doc: RxDocumentData<RxDocType>;\n        sequence: number;\n    }>;\n    lastSequence: number;\n}> {\n    let lastPushSequence = await getLastPushSequence(\n        collection,\n        endpointHash\n    );\n\n    let retry = true;\n    let lastSequence: number = lastPushSequence;\n    const changedDocs: Map<string, {\n        id: string;\n        doc: RxDocumentData<RxDocType>;\n        sequence: number;\n    }> = new Map();\n\n    /**\n     * it can happen that all docs in the batch\n     * do not have to be replicated.\n     * Then we have to continue grapping the feed\n     * until we reach the end of it\n     */\n    while (retry) {\n\n        const changesResults = await collection.storageInstance.getChangedDocuments({\n            sinceSequence: lastPushSequence,\n            limit: batchSize,\n            direction: 'after'\n        });\n        lastSequence = changesResults.lastSequence;\n\n        // optimisation shortcut, do not proceed if there are no changed documents\n        if (changesResults.changedDocuments.length === 0) {\n            retry = false;\n            continue;\n        }\n\n        const plainDocs = await collection.storageInstance.findDocumentsById(\n            changesResults.changedDocuments.map(row => row.id),\n            true\n        );\n        const docs: Map<string, RxDocumentData<RxDocType>> = new Map();\n        Array.from(plainDocs.entries()).map(([docId, docData]) => {\n            const hookParams = {\n                collection,\n                doc: docData\n            };\n            runPluginHooks('postReadFromInstance', hookParams);\n            docs.set(docId, hookParams.doc);\n        });\n\n\n        changesResults.changedDocuments.forEach((row) => {\n            const id = row.id;\n            if (changedDocs.has(id)) {\n                return;\n            }\n            const changedDoc = docs.get(id);\n            if (!changedDoc) {\n                throw newRxError('SNH', { args: { docs } });\n            }\n\n            /**\n             * filter out changes with revisions resulting from the pull-stream\n             * so that they will not be upstreamed again\n             */\n            if (wasRevisionfromPullReplication(\n                endpointHash,\n                changedDoc._rev\n            )) {\n                return false;\n            }\n\n            changedDocs.set(id, {\n                id,\n                doc: changedDoc,\n                sequence: row.sequence\n            });\n        });\n\n\n        if (changedDocs.size < batchSize && changesResults.changedDocuments.length === batchSize) {\n            // no pushable docs found but also not reached the end -> re-run\n            lastPushSequence = lastSequence;\n            retry = true;\n        } else {\n            retry = false;\n        }\n    }\n\n    return {\n        changedDocs,\n        lastSequence\n    };\n}\n\n\n//\n// things for pull-checkpoint\n//\n\n\nconst pullLastDocumentId = (endpointHash: string) => GRAPHQL_REPLICATION_PLUGIN_IDENT + '-pull-checkpoint-' + endpointHash;\n\nexport async function getLastPullDocument<RxDocType>(\n    collection: RxCollection<RxDocType>,\n    endpointHash: string\n): Promise<RxDocType | null> {\n    const localDoc = await findLocalDocument<any>(\n        collection.localDocumentsStore,\n        pullLastDocumentId(endpointHash)\n    );\n    if (!localDoc) {\n        return null;\n    } else {\n        return localDoc.doc;\n    }\n}\n\nexport async function setLastPullDocument(\n    collection: RxCollection,\n    endpointHash: string,\n    doc: any\n): Promise<{ _id: string }> {\n    const _id = pullLastDocumentId(endpointHash);\n\n    const localDoc: RxLocalDocumentData = await findLocalDocument<any>(\n        collection.localDocumentsStore,\n        _id\n    );\n\n    if (!localDoc) {\n        return writeSingleLocal(\n            collection.localDocumentsStore,\n            {\n                document: {\n                    _id,\n                    doc,\n                    _attachments: {}\n                }\n            }\n        );\n    } else {\n        const newDoc = flatClone(localDoc);\n        newDoc.doc = doc;\n        return writeSingleLocal(\n            collection.localDocumentsStore,\n            {\n                previous: localDoc,\n                document: newDoc\n            }\n        );\n    }\n}\n"],"file":"crawling-checkpoint.js"}
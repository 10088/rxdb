{"version":3,"sources":["../../../../src/plugins/pouchdb/custom-events-plugin.ts"],"names":["PouchDBCore","Subject","flatClone","now","newRxError","ObliviousSet","addedToPouch","EVENT_EMITTER_BY_POUCH_INSTANCE","Map","getCustomEventEmitterByPouch","pouch","key","name","adapter","join","emitter","get","subject","obliviousSet","set","i","addCustomEventsPluginToPouch","oldBulkDocs","prototype","bulkDocs","newBulkDocs","body","options","callback","startTime","t","Array","isArray","docs","undefined","hasOwnProperty","new_edits","length","args","previousDocs","ids","map","doc","_id","changes","live","since","doc_ids","style","viaChanges","Promise","all","results","result","id","rev","deleted","revs","set_new_edit_as_latest_revision","firstDoc","previousDocsResult","forEach","previous","splittedRev","_rev","split","revHeight","parseInt","revLabel","_revisions","start","unshift","deeperOptions","isDeeper","call","err","endTime","emitData","emitId","writeDocs","writeOptions","writeResult","next","plugin"],"mappings":"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","sourcesContent":["/*\n * Instead of listening to pouch.changes,\n * we overwrite pouchdbs bulkDocs()\n * and create our own event stream, this will work more reliable\n * and has less strange behaviors.\n * Also we can better define what data we need for our events.\n * @link http://jsbin.com/pagebi/1/edit?js,output\n * @link https://github.com/pubkey/rxdb/blob/1f4115b69bdacbb853af9c637d70f5f184d4e474/src/rx-storage-pouchdb.ts#L273\n */\n\nimport type {\n    PouchBulkDocOptions,\n    PouchBulkDocResultRow,\n    PouchDBInstance,\n    PouchWriteError\n} from '../../types';\nimport PouchDBCore from 'pouchdb-core';\nimport { Subject } from 'rxjs';\nimport {\n    flatClone,\n    now\n} from '../../util';\nimport { newRxError } from '../../rx-error';\nimport { ObliviousSet } from 'oblivious-set';\n\n// ensure only added once\nlet addedToPouch = false;\n\ndeclare type EmitData = {\n    emitId: number;\n    writeOptions: PouchBulkDocOptions;\n    writeDocs: any[];\n    writeResult: (PouchBulkDocResultRow | PouchWriteError)[];\n    // used on new_edits=false to check if the last revision has changed\n    previousDocs: Map<string, any>;\n    startTime: number;\n    endTime: number;\n};\n\n\ndeclare type Emitter = {\n    subject: Subject<EmitData>;\n    /**\n     * Contains all eventIds that of emitted events,\n     * used because multi-instance pouchdbs often will reemit the same\n     * event on the other browser tab.\n     */\n    obliviousSet: ObliviousSet<string>;\n};\nexport const EVENT_EMITTER_BY_POUCH_INSTANCE: Map<string, Emitter> = new Map();\n\nexport function getCustomEventEmitterByPouch(\n    pouch: PouchDBInstance\n): Emitter {\n    const key = [\n        pouch.name,\n        pouch.adapter\n    ].join('|');\n    let emitter = EVENT_EMITTER_BY_POUCH_INSTANCE.get(key);\n    if (!emitter) {\n        emitter = {\n            subject: new Subject(),\n            obliviousSet: new ObliviousSet(60 * 1000)\n        };\n        EVENT_EMITTER_BY_POUCH_INSTANCE.set(key, emitter);\n    }\n    return emitter;\n}\n\n\nlet i = 0;\n\nexport function addCustomEventsPluginToPouch() {\n    if (addedToPouch) {\n        return;\n    }\n    addedToPouch = true;\n\n    const oldBulkDocs: any = PouchDBCore.prototype.bulkDocs;\n    const newBulkDocs = async function (\n        this: PouchDBInstance,\n        body: any[] | { docs: any[], new_edits?: boolean },\n        options: PouchBulkDocOptions,\n        callback: Function\n    ) {\n        const startTime = now();\n        const t = i++;\n\n        // normalize input\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        if (!options) {\n            options = {};\n        }\n\n        let docs: any[];\n        if (Array.isArray(body)) {\n            docs = body;\n        } else if (body === undefined) {\n            docs = [];\n        } else {\n            docs = body.docs;\n            if (body.hasOwnProperty('new_edits')) {\n                options.new_edits = body.new_edits;\n            }\n        }\n\n        if (docs.length === 0) {\n            throw newRxError('SNH', {\n                args: {\n                    body,\n                    options\n                }\n            });\n        }\n\n\n        /**\n         * If new_edits=false we have to first find the current state\n         * of the document and can later check if the state was changed\n         * because a new revision was written and we have to emit an event.\n         */\n        const previousDocs: Map<string, any> = new Map();\n        if (\n            options.hasOwnProperty('new_edits') &&\n            options.new_edits === false\n        ) {\n            const ids = docs.map(doc => doc._id);\n\n            /**\n             * Pouchdb does not return deleted documents via allDocs()\n             * So have to do use our hack with getting the newest revisions from the\n             * changes.\n             */\n            const viaChanges = await this.changes({\n                live: false,\n                since: 0,\n                doc_ids: ids,\n                style: 'all_docs'\n            });\n\n            const previousDocsResult = await Promise.all(\n                viaChanges.results.map(async (result) => {\n                    const firstDoc = await this.get(\n                        result.id,\n                        {\n                            rev: result.changes[0].rev,\n                            deleted: 'ok',\n                            revs: options.set_new_edit_as_latest_revision ? true : false,\n                            style: 'all_docs'\n                        }\n                    );\n                    return firstDoc;\n                })\n            );\n            previousDocsResult.forEach(doc => previousDocs.set(doc._id, doc));\n\n            if (options.set_new_edit_as_latest_revision) {\n                docs.forEach(doc => {\n                    const id = doc._id;\n                    const previous = previousDocs.get(id);\n                    if (previous) {\n                        const splittedRev = doc._rev.split('-');\n                        const revHeight = parseInt(splittedRev[0], 10);\n                        const revLabel = splittedRev[1];\n                        doc._revisions = {\n                            start: revHeight,\n                            ids: previous._revisions.ids\n                        };\n                        doc._revisions.ids.unshift(revLabel);\n\n                        delete previous._revisions;\n                    }\n                });\n            }\n        }\n\n\n        /**\n         * pouchdb calls this function again with transformed input.\n         * This would lead to duplicate events. So we marks the deeper calls via the options\n         * parameter and do not emit events if it is set.\n         */\n        const deeperOptions = flatClone(options);\n        deeperOptions.isDeeper = true;\n\n        return oldBulkDocs.call(this, docs, deeperOptions, (err: any, result: any) => {\n            if (err) {\n                if (callback) {\n                    callback(err);\n                } else {\n                    throw err;\n                }\n            } else {\n                if (!options.isDeeper) {\n                    const endTime = now();\n                    const emitData = {\n                        emitId: t,\n                        writeDocs: docs,\n                        writeOptions: options,\n                        writeResult: result,\n                        previousDocs,\n                        startTime,\n                        endTime\n                    };\n\n                    const emitter = getCustomEventEmitterByPouch(this);\n                    emitter.subject.next(emitData);\n                }\n\n                if (callback) {\n                    callback(null, result);\n                } else {\n                    return result;\n                }\n            }\n        });\n    };\n\n    PouchDBCore.plugin({\n        bulkDocs: newBulkDocs\n    } as any);\n\n}\n\n"],"file":"custom-events-plugin.js"}
{"version":3,"file":"rx-storage-ipc-main.js","names":["ensureNotFalsy","getFromMapOrThrow","IPC_RENDERER_KEY_PREFIX","IPC_RENDERER_TO_MAIN","body","recover","result","e","then","exposeIpcMainRxStorage","args","instanceById","Map","portStateByChannelId","ipcMain","on","key","join","event","params","subs","set","channelId","port","state","push","storageInstance","changeStream","subscribe","changes","message","answerTo","method","postMessage","conflictResultionTasks","conflicts","instanceId","ports","databaseName","collectionName","schema","version","get","storage","createStorageInstance","error","_event","length","closeBreakResponse","requestId","forEach","sub","unsubscribe","filter","p","response","err","errorResponse","toString"],"sources":["../../../../src/plugins/electron/rx-storage-ipc-main.ts"],"sourcesContent":["/**\n * This file contains everything\n * that is supposed to run inside of the electron main process\n */\nimport type {\n    RxStorage,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams\n} from '../../types';\nimport { ensureNotFalsy, getFromMapOrThrow } from '../../util';\nimport { Subscription } from 'rxjs';\nimport {\n    IpcMessageFromMain,\n    IpcMessageFromRenderer,\n    IPC_RENDERER_KEY_PREFIX,\n    IPC_RENDERER_TO_MAIN\n} from './electron-helper';\n\nexport function exposeIpcMainRxStorage<T, D>(\n    args: {\n        key: string;\n        storage: RxStorage<T, D>;\n        ipcMain: any;\n    }\n) {\n    type InstanceState = {\n        storageInstance: RxStorageInstance<any, any, any>;\n        ports: MessagePort[];\n        params: RxStorageInstanceCreationParams<any, any>;\n    };\n    const instanceById: Map<string, InstanceState> = new Map();\n    const portStateByChannelId = new Map<string, {\n        port: MessagePort;\n        state: InstanceState;\n        subs: Subscription[];\n    }>();\n\n    args.ipcMain.on(\n        [\n            IPC_RENDERER_KEY_PREFIX,\n            'postMessage',\n            args.key,\n            'createStorageInstance'\n        ].join('|'),\n        async (event: any, params: RxStorageInstanceCreationParams<any, any>) => {\n            const [port] = event.ports;\n            const instanceId = [\n                params.databaseName,\n                params.collectionName,\n                params.schema.version\n            ].join('|');\n\n            const channelId: string = (params as any).channelId;\n\n            let state = instanceById.get(instanceId);\n            let storageInstance: RxStorageInstance<any, any, any>;\n            if (!state) {\n                try {\n                    storageInstance = await args.storage.createStorageInstance(params);\n                } catch (err) {\n                    port.postMessage({\n                        key: 'error',\n                        error: 'could not call createStorageInstance'\n                    });\n                    return;\n                }\n                state = {\n                    storageInstance,\n                    ports: [port],\n                    params\n                };\n                instanceById.set(instanceId, state);\n            }\n\n            const subs: Subscription[] = [];\n            portStateByChannelId.set(channelId, { port, state, subs });\n\n            subs.push(\n                state.storageInstance.changeStream().subscribe(changes => {\n                    const message: IpcMessageFromMain = {\n                        answerTo: 'changestream',\n                        method: 'changeStream',\n                        return: changes\n                    };\n                    port.postMessage(message);\n                })\n            );\n            subs.push(\n                state.storageInstance.conflictResultionTasks().subscribe(conflicts => {\n                    const message: IpcMessageFromMain = {\n                        answerTo: 'conflictResultionTasks',\n                        method: 'conflictResultionTasks',\n                        return: conflicts\n                    };\n                    port.postMessage(message);\n                })\n            );\n            port.postMessage({\n                key: 'instanceId',\n                instanceId\n            });\n        });\n\n\n    args.ipcMain.on(IPC_RENDERER_TO_MAIN, async (_event: any, message: IpcMessageFromRenderer) => {\n        const { port, state, subs } = getFromMapOrThrow(portStateByChannelId, message.channelId);\n        let result;\n        try {\n            /**\n             * On calls to 'close()',\n             * we only close the main instance if there are no other\n             * ports connected.\n             */\n            if (\n                message.method === 'close' &&\n                ensureNotFalsy(state).ports.length > 1\n            ) {\n                const closeBreakResponse: IpcMessageFromMain = {\n                    answerTo: message.requestId,\n                    method: message.method,\n                    return: null\n                };\n                port.postMessage(closeBreakResponse);\n                return;\n            }\n\n            result = await (ensureNotFalsy(state).storageInstance as any)[message.method](...message.params);\n            if (\n                message.method === 'close' ||\n                message.method === 'remove'\n            ) {\n                subs.forEach(sub => sub.unsubscribe());\n                ensureNotFalsy(state).ports = ensureNotFalsy(state).ports.filter(p => p !== port);\n                portStateByChannelId.delete(message.channelId);\n                /**\n                 * TODO how to notify the other ports on remove() ?\n                 */\n            }\n            const response: IpcMessageFromMain = {\n                answerTo: message.requestId,\n                method: message.method,\n                return: result\n            };\n            port.postMessage(response);\n        } catch (err) {\n            const errorResponse: IpcMessageFromMain = {\n                answerTo: message.requestId,\n                method: message.method,\n                error: (err as any).toString()\n            };\n            port.postMessage(errorResponse);\n        }\n\n    });\n}\n"],"mappings":"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"}
{"version":3,"file":"replication.d.js","names":[],"sources":["../../../../src/types/plugins/replication.d.ts"],"sourcesContent":["import type { Observable } from 'rxjs';\nimport type { RxReplicationStateBase } from '../../plugins/replication';\nimport { RxReplicationError } from '../../plugins/replication/rx-replication-error';\nimport { InternalStoreDocType } from '../../rx-database-internal-store';\nimport type {\n    DeepReadonlyObject,\n    RxCollection,\n    RxDocumentData\n} from '../../types';\n\n\nexport type InternalStoreReplicationPushDocType = InternalStoreDocType<{\n    checkpoint: any;\n}>;\nexport type InternalStoreReplicationPullDocType<RxDocType> = InternalStoreDocType<{\n    lastPulledDoc: RxDocumentData<RxDocType>;\n}>;\n\nexport type PullRunResult =\n    'ok' |      // pull was sucessfull \n    'error' |   // pull errored and must be retried\n    'drop';     // pulled document where dropped because a local write happened in between -> re-run the whole run() cycle\n\nexport type ReplicationPullHandlerResult<RxDocType> = {\n    /**\n     * The documents that got pulled from the remote actor.\n     */\n    documents: (RxDocumentData<RxDocType> | DeepReadonlyObject<RxDocumentData<RxDocType>>)[];\n    /**\n     * True if there can be more changes on the remote,\n     * so the pulling will run again.\n     */\n    hasMoreDocuments: boolean;\n};\n\nexport type ReplicationPullHandler<RxDocType> = (latestPulledDocument: RxDocumentData<RxDocType> | null) => Promise<ReplicationPullHandlerResult<RxDocType>>;\nexport type ReplicationPullOptions<RxDocType> = {\n    /**\n     * A handler that pulls the new remote changes\n     * from the remote actor.\n     */\n    handler: ReplicationPullHandler<RxDocType>;\n};\n\nexport type ReplicationPushHandler<RxDocType> = (docs: RxDocumentData<RxDocType>[]) => Promise<void>;\nexport type ReplicationPushOptions<RxDocType> = {\n    /**\n     * A handler that sends the new local changes\n     * to the remote actor.\n     * On error, all documents are send again at later time.\n     */\n    handler: ReplicationPushHandler<RxDocType>;\n    /**\n     * How many local changes to process at once.\n     */\n    batchSize?: number;\n}\n\nexport type RxReplicationState<RxDocType> = RxReplicationStateBase<RxDocType> & {\n    readonly received$: Observable<RxDocumentData<RxDocType>>;\n    readonly send$: Observable<any>;\n    readonly error$: Observable<RxReplicationError<RxDocType>>;\n    readonly canceled$: Observable<any>;\n    readonly active$: Observable<boolean>;\n}\n\nexport type ReplicationOptions<RxDocType> = {\n    /**\n     * An id for the replication to identify it\n     * and so that RxDB is able to resume the replication on app reload.\n     * If you replicate with a remote server, it is recommended to put the\n     * server url into the replicationIdentifier.\n     * Like 'my-rest-replication-to-https://example.com/rest'\n     */\n    replicationIdentifier: string;\n    collection: RxCollection<RxDocType>;\n    /**\n     * Define a custom property that is used\n     * to flag a document as being deleted.\n     * [default='_deleted']\n     */\n    deletedFlag?: '_deleted' | string;\n    pull?: ReplicationPullOptions<RxDocType>;\n    push?: ReplicationPushOptions<RxDocType>;\n    /**\n     * default=false\n     */\n    live?: boolean;\n    /**\n     * Interval in milliseconds on when to run() again,\n     * Set this to 0 when you have a back-channel from your server\n     * that like a websocket that tells the client when to pull.\n     */\n    liveInterval?: number;\n    /**\n     * Time in milliseconds\n     */\n    retryTime?: number;\n    /**\n     * If set to false,\n     * it will not wait until the current instance becomes leader.\n     * This means it can happen that multiple browser tabs\n     * run the replication at the same time which is dangerous.\n     * \n     */\n    waitForLeadership?: boolean; // default=true\n    /**\n     * Calling `replicateRxCollection()` implies to run a replication.\n     * If set to false, it will not run replication on `replicateRxCollection()`.\n     * This means you need to call replicationState.run() to trigger the first replication.\n     */\n    autoStart?: boolean; // default=true\n}\n"],"mappings":""}
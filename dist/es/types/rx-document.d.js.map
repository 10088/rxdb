{"version":3,"file":"rx-document.d.js","names":[],"sources":["../../../src/types/rx-document.d.ts"],"sourcesContent":["import {\n    Observable,\n    BehaviorSubject\n} from 'rxjs';\n\nimport {\n    RxCollection,\n} from './rx-collection';\nimport {\n    RxAttachment,\n    RxAttachmentCreator\n} from './rx-attachment';\nimport { RxDocumentData } from './rx-storage';\nimport { RxChangeEvent } from './rx-change-event';\nimport { DeepReadonly, PlainJsonValue } from './util';\nimport { UpdateQuery } from './plugins/update';\nimport { CRDTEntry } from './plugins/crdt';\n\nexport type RxDocument<RxDocumentType = {}, OrmMethods = {}> = RxDocumentBase<RxDocumentType, OrmMethods> & RxDocumentType & OrmMethods;\n\ndeclare type AtomicUpdateFunction<RxDocumentType> = (\n    doc: RxDocumentData<RxDocumentType>,\n    rxDocument: RxDocument<RxDocumentType>\n) => RxDocumentType | Promise<RxDocumentType>;\n\n/**\n * Meta data that is attached to each document by RxDB.\n */\nexport type RxDocumentMeta = {\n    /**\n     * Last write time.\n     * Unix epoch in milliseconds.\n     */\n    lwt: number;\n\n    /**\n     * Any other value can be attached to the _meta data.\n     * Mostly done by plugins to mark documents.\n     */\n    [k: string]: PlainJsonValue;\n};\n\nexport declare interface RxDocumentBase<RxDocType, OrmMethods = {}> {\n    isInstanceOfRxDocument: true;\n    collection: RxCollection<RxDocType, OrmMethods>;\n    readonly deleted: boolean;\n\n    readonly $: Observable<DeepReadonly<any>>;\n    readonly deleted$: Observable<boolean>;\n\n    readonly primary: string;\n    readonly allAttachments$: Observable<RxAttachment<RxDocType, OrmMethods>[]>;\n\n    // internal things\n    _dataSync$: BehaviorSubject<DeepReadonly<RxDocType>>;\n    _data: RxDocumentData<RxDocType>;\n    primaryPath: string;\n    revision: string;\n    _atomicQueue: Promise<any>;\n    $emit(cE: RxChangeEvent<RxDocType>): void;\n    _saveData(newData: any, oldData: any): Promise<void>;\n    // /internal things\n\n    get$(path: string): Observable<any>;\n    get(objPath: string): DeepReadonly<any>;\n    populate(objPath: string): Promise<RxDocument<RxDocType, OrmMethods> | any | null>;\n\n    /**\n     * mutate the document with a function\n     */\n    atomicUpdate(mutationFunction: AtomicUpdateFunction<RxDocType>, context?: string): Promise<RxDocument<RxDocType, OrmMethods>>;\n    /**\n     * patches the given properties\n     */\n    atomicPatch(patch: Partial<RxDocType>): Promise<RxDocument<RxDocType, OrmMethods>>;\n\n    update(updateObj: UpdateQuery<RxDocType>): Promise<any>;\n    updateCRDT(updateObj: CRDTEntry<RxDocType> | CRDTEntry<RxDocType>[]): Promise<any>;\n    remove(): Promise<boolean>;\n    _handleChangeEvent(cE: any): void;\n\n    // only for temporary documents\n    set(objPath: string, value: any): RxDocument<RxDocType, OrmMethods>;\n    save(): Promise<boolean>;\n\n    // attachments\n    putAttachment(\n        creator: RxAttachmentCreator,\n        /**\n         * If set to true and data is equal,\n         * operation will be skipped.\n         * This prevents us from upgrading the revision\n         * and causing events in the change stream.\n         * (default = true)\n         */\n        skipIfSame?: boolean\n    ): Promise<RxAttachment<RxDocType, OrmMethods>>;\n    getAttachment(id: string): RxAttachment<RxDocType, OrmMethods> | null;\n    allAttachments(): RxAttachment<RxDocType, OrmMethods>[];\n\n    toJSON(): DeepReadonly<RxDocType>;\n    toJSON(withRevAndAttachments: true): DeepReadonly<RxDocumentData<RxDocType>>;\n    toJSON(withRevAndAttachments: false): DeepReadonly<RxDocType>;\n\n    toMutableJSON(): RxDocType;\n    toMutableJSON(withRevAndAttachments: true): RxDocumentData<RxDocType>;\n    toMutableJSON(withRevAndAttachments: false): RxDocType;\n\n    destroy(): void;\n}\n"],"mappings":""}
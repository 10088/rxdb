{"version":3,"file":"rx-storage-replication.d.js","names":[],"sources":["../../../src/types/rx-storage-replication.d.ts"],"sourcesContent":["import { BehaviorSubject } from 'rxjs';\nimport { RxDocumentData } from './rx-storage';\nimport type {\n    RxStorageInstance\n} from './rx-storage.interface';\n\nexport type RxStorageReplicationMeta = {\n\n    /**\n     * Combined primary key consisting\n     * of: [replicationId, itemId, isCheckpoint]\n     * so that the same RxStorageInstance\n     * can be used for multiple replication states.\n     */\n    id: string;\n\n    /**\n     * Either the document primaryKey\n     * or the id of the replication checkpoint.\n     */\n    itemId: string;\n\n    /**\n     * input.identifier of the replication state,\n     * used to not mix up different data\n     * when the instance is used in more then one replication.\n     */\n    replicationIdentifier: string;\n\n    /**\n     * True if the doc data is about a checkpoint,\n     * False if it is about a document state from the master.\n     * Stored as a string so it can be used\n     * in the combined primary key 'id'\n     */\n    isCheckpoint: '0' | '1';\n\n    /**\n     * Either the document state of the master\n     * or the checkpoint data.\n     */\n    data: RxDocumentData<any> | any;\n};\n\nexport type RxStorageInstanceReplicationInput<RxDocType> = {\n    /**\n     * A string that uniquely identifies\n     * the replication.\n     * Ensures that checkpoint are not\n     * mixed with other replications.\n     */\n    identifier: string;\n    bulkSize: number;\n    conflictHandler: RxConflictHandler<RxDocType>;\n\n    /**\n     * The RxStorage instance of the master branch that is\n     * replicated with the fork branch.\n     * The replication algorithm is made to make\n     * as less writes on the master as possible.\n     * The master instance is always 'the truth' which\n     * does never contain conflicting document states.\n     * All conflicts are handled on the fork branch\n     * before being replicated to the master.\n     */\n    masterInstance: RxStorageInstance<RxDocType, any, any>;\n\n    /**\n     * The fork is the one that contains the forked chain of document writes.\n     * All conflicts are solved on the fork and only resolved correct document data\n     * is written back to the parent.\n     */\n    forkInstance: RxStorageInstance<RxDocType, any, any>;\n\n    /**\n     * The replication needs to store some meta data\n     * for documents to know which state is at the master\n     * and how/if it diverges from the fork.\n     * In the past this was stored in the _meta field of\n     * the forkInstance documents but that was not a good design decision\n     * because it required additional writes on the forkInstance\n     * to know which documents have been upstream replicated\n     * to not cause conflicts.\n     * Using the metaInstance instead leads to better overall performance\n     * because RxDB will not re-emit query results or document state\n     * when replication meta data is written.\n     * \n     * In addition to per-document meta data,\n     * the replication checkpoints are also stored in this instance.\n     * \n     */\n    metaInstance: RxStorageInstance<RxStorageReplicationMeta, any, any>;\n\n    /**\n     * When a write happens to the fork,\n     * normally the replication will directly try to persist.\n     * \n     * For many use cases, it is better to await the next event loop tick\n     * or to wait until the RxDatabase is idle or requestIdleCallback() calls\n     * to ensure the CPU is idle.\n     * This can improve performance because the persistence will not affect UI\n     * renders.\n     * \n     * But: The longer you wait here, the higher is the risk of loosing fork\n     * writes when the replicatoin is destroyed unexpected.\n     */\n    waitBeforePersist?: () => Promise<any>;\n};\n\nexport type RxStorageInstanceReplicationState<RxDocType> = {\n    // store the primaryPath here for better reuse and performance.\n    primaryPath: string;\n    input: RxStorageInstanceReplicationInput<RxDocType>;\n\n    /**\n     * Used in checkpoints and ._meta fields\n     * to ensure we do not mix up meta data of\n     * different replications.\n     */\n     checkpointKey: string;\n\n    /**\n     * Tracks if the streams are in sync\n     * or not.\n     */\n    firstSyncDone: {\n        [direction in RxStorageReplicationDirection]: BehaviorSubject<boolean>;\n    };\n\n    /**\n     * Contains the cancel state.\n     * Emit true here to cancel the replication.\n     */\n    canceled: BehaviorSubject<boolean>;\n\n    lastCheckpoint: {\n        [direction in RxStorageReplicationDirection]?: any\n    };\n\n    /**\n     * Can be used to detect if the replication is doing something\n     * or if it is in an idle state.\n     */\n    streamQueue: {\n        [direction in RxStorageReplicationDirection]: Promise<any>;\n    }\n}\n\nexport type RxConflictHandlerInput<RxDocType> = {\n    assumedMasterState?: RxDocumentData<RxDocType>;\n    realMasterState: RxDocumentData<RxDocType>;\n    newDocumentState: RxDocumentData<RxDocType>;\n};\nexport type RxConflictHandler<RxDocType> = (\n    i: RxConflictHandlerInput<RxDocType>\n) => Promise<{\n    resolvedDocumentState: RxDocumentData<RxDocType>\n}>\n\n\nexport type RxStorageReplicationDirection = 'up' | 'down';\n"],"mappings":""}
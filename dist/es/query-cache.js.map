{"version":3,"file":"query-cache.js","names":["nextTick","now","requestIdlePromise","QueryCache","_map","Map","getByQuery","rxQuery","stringRep","toString","has","set","get","createQueryCache","uncacheRxQuery","queryCache","uncached","countRxQuerySubscribers","refCount$","observers","length","DEFAULT_TRY_TO_KEEP_MAX","DEFAULT_UNEXECUTED_LIFETME","defaultCacheReplacementPolicyMonad","tryToKeepMax","unExecutedLifetime","_collection","size","minUnExecutedLifetime","maybeUncash","queriesInCache","Array","from","values","_lastEnsureEqual","_creationTime","push","mustUncache","sortedByLastUsage","sort","a","b","toRemove","slice","forEach","defaultCacheReplacementPolicy","COLLECTIONS_WITH_RUNNING_CLEANUP","WeakSet","triggerCacheReplacement","rxCollection","add","then","destroyed","cacheReplacementPolicy","_queryCache"],"sources":["../../src/query-cache.ts"],"sourcesContent":["/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\nimport type {\n    RxQuery,\n    RxCacheReplacementPolicy,\n    RxCollection\n} from './types';\nimport {\n    nextTick,\n    now,\n    requestIdlePromise\n} from './util';\n\nexport class QueryCache {\n    public _map: Map<string, RxQuery> = new Map();\n\n    /**\n     * check if an equal query is in the cache,\n     * if true, return the cached one,\n     * if false, save the given one and return it\n     */\n    getByQuery(rxQuery: RxQuery): RxQuery {\n        const stringRep = rxQuery.toString();\n        if (!this._map.has(stringRep)) {\n            this._map.set(stringRep, rxQuery);\n        }\n        return this._map.get(stringRep) as RxQuery;\n    }\n}\n\nexport function createQueryCache() {\n    return new QueryCache();\n}\n\n\nexport function uncacheRxQuery(queryCache: QueryCache, rxQuery: RxQuery) {\n    rxQuery.uncached = true;\n    const stringRep = rxQuery.toString();\n    queryCache._map.delete(stringRep);\n\n}\n\n\nexport function countRxQuerySubscribers(rxQuery: RxQuery): number {\n    return rxQuery.refCount$.observers.length;\n}\n\n\nexport const DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport const DEFAULT_UNEXECUTED_LIFETME = 30 * 1000;\n\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\nexport const defaultCacheReplacementPolicyMonad: (\n    tryToKeepMax: number,\n    unExecutedLifetime: number\n) => RxCacheReplacementPolicy = (\n    tryToKeepMax,\n    unExecutedLifetime\n) => (\n    _collection: RxCollection,\n    queryCache: QueryCache\n) => {\n            if (queryCache._map.size < tryToKeepMax) {\n                return;\n            }\n\n            const minUnExecutedLifetime = now() - unExecutedLifetime;\n            const maybeUncash: RxQuery[] = [];\n\n            const queriesInCache = Array.from(queryCache._map.values());\n            for (const rxQuery of queriesInCache) {\n                // filter out queries with subscribers\n                if (countRxQuerySubscribers(rxQuery) > 0) {\n                    continue;\n                }\n                // directly uncache queries that never executed and are older then unExecutedLifetime\n                if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n                    uncacheRxQuery(queryCache, rxQuery);\n                    continue;\n                }\n                maybeUncash.push(rxQuery);\n            }\n\n            const mustUncache = maybeUncash.length - tryToKeepMax;\n            if (mustUncache <= 0) {\n                return;\n            }\n\n            const sortedByLastUsage = maybeUncash.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\n            const toRemove = sortedByLastUsage.slice(0, mustUncache);\n            toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\n        };\n\n\nexport const defaultCacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(\n    DEFAULT_TRY_TO_KEEP_MAX,\n    DEFAULT_UNEXECUTED_LIFETME\n);\n\nexport const COLLECTIONS_WITH_RUNNING_CLEANUP: WeakSet<RxCollection> = new WeakSet();\n\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\nexport function triggerCacheReplacement(\n    rxCollection: RxCollection\n) {\n    if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\n        // already started\n        return;\n    }\n\n    COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\n\n    /**\n     * Do not run directly to not reduce result latency of a new query\n     */\n    nextTick() // wait at least one tick\n        .then(() => requestIdlePromise(200)) // and then wait for the CPU to be idle\n        .then(() => {\n            if (!rxCollection.destroyed) {\n                rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n            }\n            COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\n        });\n}\n"],"mappings":"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"}
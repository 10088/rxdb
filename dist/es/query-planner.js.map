{"version":3,"file":"query-planner.js","names":["getPrimaryFieldOfPrimaryKey","INDEX_MAX","String","fromCharCode","INDEX_MIN","Infinity","getQueryPlan","schema","query","primaryPath","primaryKey","selector","indexes","slice","index","push","optimalSortIndex","sort","map","sortField","Object","keys","optimalSortIndexCompareString","join","hasDescSorting","find","values","currentBestQuality","currentBestQueryPlan","forEach","opts","indexField","matcher","operators","length","startKey","endKey","inclusiveStart","inclusiveEnd","matcherOpts","operator","isLogicalOperator","operatorValue","partialOpts","getMatcherQueryOpts","assign","queryPlan","startKeys","opt","endKeys","sortFieldsSameAsIndexFields","quality","rateQueryPlan","LOGICAL_OPERATORS","Set","has","Error","pointsPerMatchingKey","idxOfFirstMinStartKey","findIndex","keyValue","idxOfFirstMaxEndKey","pointsIfNoReSortMustBeDone"],"sources":["../../src/query-planner.ts"],"sourcesContent":["import { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport type {\n    FilledMangoQuery,\n    RxDocumentData,\n    RxJsonSchema,\n    RxQueryPlan,\n    RxQueryPlanerOpts\n} from './types';\n\n\nexport const INDEX_MAX = String.fromCharCode(65535);\nexport const INDEX_MIN = -Infinity;\n\n/**\n * Returns the query plan which contains\n * information about how to run the query\n * and which indexes to use.\n * \n * This is used in some storage like Memory, dexie.js and IndexedDB.\n */\nexport function getQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>\n): RxQueryPlan {\n    const primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    const selector = query.selector;\n\n    let indexes: string[][] = schema.indexes ? schema.indexes.slice(0) as any : [];\n    if (query.index) {\n        indexes = [query.index];\n    } else {\n        indexes.push([primaryPath]);\n    }\n\n    const optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);\n    const optimalSortIndexCompareString = optimalSortIndex.join(',');\n    /**\n     * Most storages do not support descending indexes\n     * so having a 'desc' in the sorting, means we always have to re-sort the results.\n     */\n    const hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc')\n\n    let currentBestQuality = -1;\n    let currentBestQueryPlan: RxQueryPlan | undefined;\n\n    indexes.forEach((index) => {\n        const opts: RxQueryPlanerOpts[] = index.map(indexField => {\n            const matcher = selector[indexField];\n            const operators = matcher ? Object.keys(matcher) : [];\n            if (\n                !matcher ||\n                !operators.length\n            ) {\n                return {\n                    startKey: INDEX_MIN,\n                    endKey: INDEX_MAX,\n                    inclusiveStart: true,\n                    inclusiveEnd: true\n                };\n            }\n\n            let matcherOpts: RxQueryPlanerOpts = {} as any;\n            operators.forEach(operator => {\n                if (isLogicalOperator(operator)) {\n                    const operatorValue = matcher[operator];\n                    const partialOpts = getMatcherQueryOpts(operator, operatorValue);\n                    matcherOpts = Object.assign(matcherOpts, partialOpts);\n                }\n            });\n\n            // fill missing attributes\n            if (typeof matcherOpts.startKey === 'undefined') {\n                matcherOpts.startKey = INDEX_MIN;\n            }\n            if (typeof matcherOpts.endKey === 'undefined') {\n                matcherOpts.endKey = INDEX_MAX;\n            }\n            if (typeof matcherOpts.inclusiveStart === 'undefined') {\n                matcherOpts.inclusiveStart = true;\n            }\n            if (typeof matcherOpts.inclusiveEnd === 'undefined') {\n                matcherOpts.inclusiveEnd = true;\n            }\n\n            return matcherOpts;\n        });\n\n        const queryPlan: RxQueryPlan = {\n            index,\n            startKeys: opts.map(opt => opt.startKey),\n            endKeys: opts.map(opt => opt.endKey),\n            inclusiveEnd: !opts.find(opt => !opt.inclusiveEnd),\n            inclusiveStart: !opts.find(opt => !opt.inclusiveStart),\n            sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === index.join(',')\n        };\n        const quality = rateQueryPlan(\n            schema,\n            query,\n            queryPlan\n        );\n        if (\n            (\n                quality > 0 &&\n                quality > currentBestQuality\n            ) ||\n            query.index\n        ) {\n            currentBestQuality = quality;\n            currentBestQueryPlan = queryPlan;\n        }\n    });\n\n    /**\n     * No index found, use the default index\n     */\n    if (!currentBestQueryPlan) {\n        return {\n            index: [primaryPath],\n            startKeys: [INDEX_MIN],\n            endKeys: [INDEX_MAX],\n            inclusiveEnd: true,\n            inclusiveStart: true,\n            sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === primaryPath\n        }\n    }\n\n    return currentBestQueryPlan;\n}\n\nconst LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);\nexport function isLogicalOperator(operator: string): boolean {\n    return LOGICAL_OPERATORS.has(operator);\n}\n\nexport function getMatcherQueryOpts(operator: string, operatorValue: any): Partial<RxQueryPlanerOpts> {\n    switch (operator) {\n        case '$eq':\n            return {\n                startKey: operatorValue,\n                endKey: operatorValue\n            };\n        case '$lte':\n            return {\n                endKey: operatorValue\n            };\n        case '$gte':\n            return {\n                startKey: operatorValue\n            };\n        case '$lt':\n            return {\n                endKey: operatorValue,\n                inclusiveEnd: false\n            };\n        case '$gt':\n            return {\n                startKey: operatorValue,\n                inclusiveStart: false\n            };\n        default:\n            throw new Error('SNH');\n    }\n}\n\n\n/**\n * Returns a number that determines the quality of the query plan.\n * Higher number means better query plan.\n */\nexport function rateQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>,\n    queryPlan: RxQueryPlan\n): number {\n    let quality: number = 0;\n\n    const pointsPerMatchingKey = 10;\n    const idxOfFirstMinStartKey = queryPlan.startKeys.findIndex(keyValue => keyValue === INDEX_MIN);\n    if (idxOfFirstMinStartKey > 0) {\n        quality = quality + (idxOfFirstMinStartKey * pointsPerMatchingKey)\n    }\n\n    const idxOfFirstMaxEndKey = queryPlan.endKeys.findIndex(keyValue => keyValue === INDEX_MAX);\n    if (idxOfFirstMaxEndKey > 0) {\n        quality = quality + (idxOfFirstMaxEndKey * pointsPerMatchingKey)\n    }\n\n    const pointsIfNoReSortMustBeDone = 5;\n    if (queryPlan.sortFieldsSameAsIndexFields) {\n        quality = quality + pointsIfNoReSortMustBeDone;\n    }\n\n    return quality;\n}\n"],"mappings":"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"}
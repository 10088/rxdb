{"version":3,"file":"query-planner.js","names":["getPrimaryFieldOfPrimaryKey","INDEX_MAX","String","fromCharCode","INDEX_MIN","Infinity","getQueryPlan","schema","query","primaryPath","primaryKey","selector","indexes","slice","index","push","optimalSortIndex","sort","map","sortField","Object","keys","optimalSortIndexCompareString","join","hasDescSorting","find","values","currentBestQuality","currentBestQueryPlan","forEach","inclusiveEnd","inclusiveStart","opts","indexField","matcher","operators","matcherOpts","length","startKey","endKey","operator","isLogicalOperator","operatorValue","partialOpts","getMatcherQueryOpts","assign","queryPlan","startKeys","opt","endKeys","sortFieldsSameAsIndexFields","selectorSatisfiedByIndex","isSelectorSatisfiedByIndex","quality","rateQueryPlan","LOGICAL_OPERATORS","Set","has","nonMatching","entries","field","operation","includes","hasNonLogicOperator","op","_value","Error","pointsPerMatchingKey","idxOfFirstMinStartKey","findIndex","keyValue","idxOfFirstMaxEndKey","pointsIfNoReSortMustBeDone"],"sources":["../../src/query-planner.ts"],"sourcesContent":["import { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport type {\n    FilledMangoQuery,\n    MangoQuerySelector,\n    RxDocumentData,\n    RxJsonSchema,\n    RxQueryPlan,\n    RxQueryPlanerOpts\n} from './types';\n\n\nexport const INDEX_MAX = String.fromCharCode(65535);\nexport const INDEX_MIN = -Infinity;\n\n/**\n * Returns the query plan which contains\n * information about how to run the query\n * and which indexes to use.\n * \n * This is used in some storage like Memory, dexie.js and IndexedDB.\n */\nexport function getQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>\n): RxQueryPlan {\n    const primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    const selector = query.selector;\n\n    let indexes: string[][] = schema.indexes ? schema.indexes.slice(0) as any : [];\n    if (query.index) {\n        indexes = [query.index];\n    } else {\n        indexes.push([primaryPath]);\n    }\n\n    const optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);\n    const optimalSortIndexCompareString = optimalSortIndex.join(',');\n    /**\n     * Most storages do not support descending indexes\n     * so having a 'desc' in the sorting, means we always have to re-sort the results.\n     */\n    const hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc')\n\n    let currentBestQuality = -1;\n    let currentBestQueryPlan: RxQueryPlan | undefined;\n\n    indexes.forEach((index) => {\n        let inclusiveEnd = true;\n        let inclusiveStart = true;\n        const opts: RxQueryPlanerOpts[] = index.map(indexField => {\n            const matcher = selector[indexField];\n            const operators = matcher ? Object.keys(matcher) : [];\n\n            let matcherOpts: RxQueryPlanerOpts = {} as any;\n\n            if (\n                !matcher ||\n                !operators.length\n            ) {\n                matcherOpts = {\n                    startKey: inclusiveStart ? INDEX_MIN : INDEX_MAX,\n                    endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,\n                    inclusiveStart: true,\n                    inclusiveEnd: true\n                };\n            } else {\n                operators.forEach(operator => {\n                    if (isLogicalOperator(operator)) {\n                        const operatorValue = matcher[operator];\n                        const partialOpts = getMatcherQueryOpts(operator, operatorValue);\n                        matcherOpts = Object.assign(matcherOpts, partialOpts);\n                    }\n                });\n            }\n\n            // fill missing attributes\n            if (typeof matcherOpts.startKey === 'undefined') {\n                matcherOpts.startKey = INDEX_MIN;\n            }\n            if (typeof matcherOpts.endKey === 'undefined') {\n                matcherOpts.endKey = INDEX_MAX;\n            }\n            if (typeof matcherOpts.inclusiveStart === 'undefined') {\n                matcherOpts.inclusiveStart = true;\n            }\n            if (typeof matcherOpts.inclusiveEnd === 'undefined') {\n                matcherOpts.inclusiveEnd = true;\n            }\n\n\n            if (inclusiveStart && !matcherOpts.inclusiveStart) {\n                inclusiveStart = false;\n            }\n            if (inclusiveEnd && !matcherOpts.inclusiveEnd) {\n                inclusiveEnd = false;\n            }\n\n            return matcherOpts;\n        });\n\n        const queryPlan: RxQueryPlan = {\n            index,\n            startKeys: opts.map(opt => opt.startKey),\n            endKeys: opts.map(opt => opt.endKey),\n            inclusiveEnd,\n            inclusiveStart,\n            sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === index.join(','),\n            selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query.selector)\n        };\n        const quality = rateQueryPlan(\n            schema,\n            query,\n            queryPlan\n        );\n        if (\n            (\n                quality > 0 &&\n                quality > currentBestQuality\n            ) ||\n            query.index\n        ) {\n            currentBestQuality = quality;\n            currentBestQueryPlan = queryPlan;\n        }\n    });\n\n    /**\n     * No index found, use the default index\n     */\n    if (!currentBestQueryPlan) {\n        currentBestQueryPlan = {\n            index: [primaryPath],\n            startKeys: [INDEX_MIN],\n            endKeys: [INDEX_MAX],\n            inclusiveEnd: true,\n            inclusiveStart: true,\n            sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === primaryPath,\n            selectorSatisfiedByIndex: isSelectorSatisfiedByIndex([primaryPath], query.selector)\n        }\n    }\n\n    return currentBestQueryPlan;\n}\n\nconst LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);\nexport function isLogicalOperator(operator: string): boolean {\n    return LOGICAL_OPERATORS.has(operator);\n}\n\nexport function isSelectorSatisfiedByIndex(\n    index: string[],\n    selector: MangoQuerySelector\n): boolean {\n    const nonMatching = Object.entries(selector)\n        .find(([field, operation]) => {\n            if (!index.includes(field)) {\n                return true;\n            }\n            const hasNonLogicOperator = Object.entries(operation)\n                .find(([op, _value]) => {\n                    if (!isLogicalOperator(op)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                });\n            return hasNonLogicOperator;\n        });\n    if (nonMatching) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nexport function getMatcherQueryOpts(\n    operator: string,\n    operatorValue: any\n): Partial<RxQueryPlanerOpts> {\n    switch (operator) {\n        case '$eq':\n            return {\n                startKey: operatorValue,\n                endKey: operatorValue\n            };\n        case '$lte':\n            return {\n                endKey: operatorValue\n            };\n        case '$gte':\n            return {\n                startKey: operatorValue\n            };\n        case '$lt':\n            return {\n                endKey: operatorValue,\n                inclusiveEnd: false\n            };\n        case '$gt':\n            return {\n                startKey: operatorValue,\n                inclusiveStart: false\n            };\n        default:\n            throw new Error('SNH');\n    }\n}\n\n\n/**\n * Returns a number that determines the quality of the query plan.\n * Higher number means better query plan.\n */\nexport function rateQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>,\n    queryPlan: RxQueryPlan\n): number {\n    let quality: number = 0;\n\n    const pointsPerMatchingKey = 10;\n    const idxOfFirstMinStartKey = queryPlan.startKeys.findIndex(keyValue => keyValue === INDEX_MIN);\n    if (idxOfFirstMinStartKey > 0) {\n        quality = quality + (idxOfFirstMinStartKey * pointsPerMatchingKey);\n    }\n\n    const idxOfFirstMaxEndKey = queryPlan.endKeys.findIndex(keyValue => keyValue === INDEX_MAX);\n    if (idxOfFirstMaxEndKey > 0) {\n        quality = quality + (idxOfFirstMaxEndKey * pointsPerMatchingKey);\n    }\n\n    const pointsIfNoReSortMustBeDone = 5;\n    if (queryPlan.sortFieldsSameAsIndexFields) {\n        quality = quality + pointsIfNoReSortMustBeDone;\n    }\n\n    return quality;\n}\n"],"mappings":"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"}
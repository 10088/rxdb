{"version":3,"file":"rx-collection.js","names":["filter","startWith","mergeMap","shareReplay","ucfirst","flatClone","promiseSeries","pluginMissing","ensureNotFalsy","getFromMapOrThrow","clone","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_VOID","RXJS_SHARE_REPLAY_DEFAULTS","getDefaultRxDocumentMeta","getDefaultRevision","nextTick","fillObjectDataBeforeInsert","createRxCollectionStorageInstance","removeCollectionStorages","createRxQuery","_getDefaultQuery","newRxError","newRxTypeError","DocCache","createQueryCache","defaultCacheReplacementPolicy","createChangeEventBuffer","runAsyncPluginHooks","runPluginHooks","createRxDocument","getWrappedStorageInstance","storageChangeEventToRxChangeEvent","throwIfIsStorageWriteError","defaultConflictHandler","HOOKS_WHEN","HOOKS_KEYS","hooksApplied","RxCollectionBase","database","name","schema","internalStorageInstance","instanceCreationOptions","migrationStrategies","methods","attachments","options","cacheReplacementPolicy","statics","conflictHandler","storageInstance","timeouts","Set","_atomicUpsertQueues","Map","synced","hooks","_subs","_docCache","_queryCache","$","_changeEventBuffer","onDestroy","destroyed","_applyHookFunctions","asRxCollection","prepare","jsonSchema","eventBulks$","pipe","changeEventBulk","collectionName","events","storageToken","databaseStorageToken","subDocs","changeStream","subscribe","eventBulk","id","internal","map","ev","databaseToken","token","checkpoint","context","$emit","push","cE","isLocal","doc","get","documentId","_handleChangeEvent","conflictResultionTasks","task","input","then","output","resolveConflictResultionTask","migrationNeeded","getDataMigrator","migrate","batchSize","migratePromise","insert","json","useJson","bulkInsert","writeResult","isError","error","primaryPath","insertResult","success","docsData","docs","docsMap","insertRows","set","docData","Object","assign","_attachments","_meta","_rev","_deleted","row","document","bulkWrite","results","rxDocuments","values","successDocData","writtenDocData","hasHooks","Promise","all","_runHooks","primary","length","useDocs","useDocData","bulkRemove","ids","findByIds","rxDocumentMap","Array","from","forEach","rxDocument","data","toJSON","removeDocs","writeDoc","previous","successIds","keys","bulkUpsert","insertData","useJsonByDocId","ret","slice","writeData","docDataInDb","documentInDb","atomicUpdate","updatedDocs","concat","upsert","result","atomicUpsert","queue","_atomicUpsertEnsureRxDocumentExists","wasInserted","inserted","_atomicUpsertUpdate","find","queryObj","query","findOne","selector","limit","isArray","mustBeQueried","findDocumentsById","findByIds$","currentValue","lastChangeEvent","initialPromise","counter","firstEmitDone","changeEvent","includes","missedChangeEvents","getFrom","newResult","resultHasChanged","rxChangeEvent","docId","op","operation","documentData","has","x","exportJSON","importJSON","_exportedJSON","syncCouchDB","_syncOptions","syncGraphQL","_options","addHook","when","key","fun","parallel","boundFun","bind","runName","series","getHooks","instance","tasks","hook","_runHooksSync","promiseWait","time","res","timeout","setTimeout","add","destroy","clearTimeout","requestIdlePromise","fn","close","sub","unsubscribe","collections","remove","storage","internalStore","hashFunction","collection","colProto","getPrototypeOf","fnName","_innerDoc","rxCollection","docFromCache","resolve","exec","newDoc","createRxCollection","autoMigrate","localDocuments","storageInstanceCreationParams","databaseInstanceToken","databaseName","multiInstance","password","entries","funName","defineProperty","version","creator","err","reject","isRxCollection","obj"],"sources":["../../src/rx-collection.ts"],"sourcesContent":["import {\n    filter,\n    startWith,\n    mergeMap,\n    shareReplay\n} from 'rxjs/operators';\n\nimport {\n    ucfirst,\n    flatClone,\n    promiseSeries,\n    pluginMissing,\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    clone,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_VOID,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    getDefaultRxDocumentMeta,\n    getDefaultRevision,\n    nextTick\n} from './util';\nimport {\n    fillObjectDataBeforeInsert,\n    createRxCollectionStorageInstance,\n    removeCollectionStorages\n} from './rx-collection-helper';\nimport {\n    createRxQuery,\n    _getDefaultQuery\n} from './rx-query';\nimport {\n    newRxError,\n    newRxTypeError\n} from './rx-error';\nimport type {\n    DataMigrator\n} from './plugins/migration';\nimport {\n    DocCache\n} from './doc-cache';\nimport {\n    QueryCache,\n    createQueryCache,\n    defaultCacheReplacementPolicy\n} from './query-cache';\nimport {\n    ChangeEventBuffer,\n    createChangeEventBuffer\n} from './change-event-buffer';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from './hooks';\n\nimport {\n    Subscription,\n    Observable\n} from 'rxjs';\n\nimport type {\n    KeyFunctionMap,\n    RxCouchDBReplicationState,\n    MigrationState,\n    SyncOptions,\n    RxCollection,\n    RxDatabase,\n    RxQuery,\n    RxDocument,\n    SyncOptionsGraphQL,\n    RxDumpCollection,\n    RxDumpCollectionAny,\n    MangoQuery,\n    MangoQueryNoLimit,\n    RxCacheReplacementPolicy,\n    RxStorageBulkWriteError,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxStorageInstanceCreationParams,\n    BulkWriteRow,\n    RxChangeEvent,\n    RxChangeEventInsert,\n    RxChangeEventUpdate,\n    RxChangeEventDelete,\n    RxStorageInstance,\n    CollectionsOfDatabase,\n    RxChangeEventBulk,\n    RxLocalDocumentData,\n    RxDocumentBase,\n    RxConflictHandler,\n    MaybePromise\n} from './types';\nimport type {\n    RxGraphQLReplicationState\n} from './plugins/replication-graphql';\n\nimport {\n    RxSchema\n} from './rx-schema';\n\nimport {\n    createRxDocument\n} from './rx-document-prototype-merge';\nimport {\n    getWrappedStorageInstance,\n    storageChangeEventToRxChangeEvent,\n    throwIfIsStorageWriteError\n} from './rx-storage-helper';\nimport { defaultConflictHandler } from './replication-protocol';\n\nconst HOOKS_WHEN = ['pre', 'post'] as const;\ntype HookWhenType = typeof HOOKS_WHEN[number];\nconst HOOKS_KEYS = ['insert', 'save', 'remove', 'create'] as const;\ntype HookKeyType = typeof HOOKS_KEYS[number];\nlet hooksApplied = false;\n\nexport class RxCollectionBase<\n    InstanceCreationOptions,\n    RxDocumentType = { [prop: string]: any },\n    OrmMethods = {},\n    StaticMethods = { [key: string]: any }\n    > {\n\n\n    /**\n     * Stores all 'normal' documents\n     */\n    public storageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions> = {} as any;\n    public readonly timeouts: Set<ReturnType<typeof setTimeout>> = new Set();\n\n    constructor(\n        public database: RxDatabase<CollectionsOfDatabase, any, InstanceCreationOptions>,\n        public name: string,\n        public schema: RxSchema<RxDocumentType>,\n        public internalStorageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions>,\n        public instanceCreationOptions: InstanceCreationOptions = {} as any,\n        public migrationStrategies: KeyFunctionMap = {},\n        public methods: KeyFunctionMap = {},\n        public attachments: KeyFunctionMap = {},\n        public options: any = {},\n        public cacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicy,\n        public statics: KeyFunctionMap = {},\n        public conflictHandler: RxConflictHandler<RxDocumentType> = defaultConflictHandler\n    ) {\n        _applyHookFunctions(this.asRxCollection);\n    }\n\n    get insert$(): Observable<RxChangeEventInsert<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'INSERT')\n        ) as any;\n    }\n    get update$(): Observable<RxChangeEventUpdate<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'UPDATE')\n        ) as any;\n    }\n    get remove$(): Observable<RxChangeEventDelete<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'DELETE')\n        ) as any;\n    }\n\n    public _atomicUpsertQueues: Map<string, Promise<any>> = new Map();\n    // defaults\n    public synced: boolean = false;\n    public hooks: {\n        [key in HookKeyType]: {\n            [when in HookWhenType]: {\n                series: Function[];\n                parallel: Function[];\n            };\n        }\n    } = {} as any;\n    public _subs: Subscription[] = [];\n\n    public _docCache: DocCache<\n        RxDocument<RxDocumentType, OrmMethods>\n    > = new DocCache();\n\n    public _queryCache: QueryCache = createQueryCache();\n    public $: Observable<RxChangeEvent<RxDocumentType>> = {} as any;\n    public _changeEventBuffer: ChangeEventBuffer = {} as ChangeEventBuffer;\n\n\n\n    /**\n     * When the collection is destroyed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n     */\n    public onDestroy: (() => MaybePromise<any>)[] = [];\n    public destroyed = false;\n\n    public async prepare(): Promise<void> {\n        this.storageInstance = getWrappedStorageInstance(\n            this.database,\n            this.internalStorageInstance,\n            this.schema.jsonSchema\n        );\n\n        this.$ = this.database.eventBulks$.pipe(\n            filter(changeEventBulk => changeEventBulk.collectionName === this.name),\n            mergeMap(changeEventBulk => changeEventBulk.events),\n        );\n        this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n\n        /**\n         * Instead of resolving the EventBulk array here and spit it into\n         * single events, we should fully work with event bulks internally\n         * to save performance.\n         */\n        const databaseStorageToken = await this.database.storageToken;\n        const subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n            const changeEventBulk: RxChangeEventBulk<RxDocumentType | RxLocalDocumentData> = {\n                id: eventBulk.id,\n                internal: false,\n                collectionName: this.name,\n                storageToken: databaseStorageToken,\n                events: eventBulk.events.map(ev => storageChangeEventToRxChangeEvent(\n                    false,\n                    ev,\n                    this as any\n                )),\n                databaseToken: this.database.token,\n                checkpoint: eventBulk.checkpoint,\n                context: eventBulk.context\n            };\n            this.database.$emit(changeEventBulk);\n        });\n        this._subs.push(subDocs);\n\n        /**\n         * When a write happens to the collection\n         * we find the changed document in the docCache\n         * and tell it that it has to change its data.\n         */\n        this._subs.push(\n            this.$\n                .pipe(\n                    filter((cE: RxChangeEvent<RxDocumentType>) => !cE.isLocal)\n                )\n                .subscribe(cE => {\n                    // when data changes, send it to RxDocument in docCache\n                    const doc = this._docCache.get(cE.documentId);\n                    if (doc) {\n                        doc._handleChangeEvent(cE);\n                    }\n                })\n        );\n\n        /**\n         * Resolve the conflict tasks\n         * of the RxStorageInstance\n         */\n        this._subs.push(\n            this.storageInstance\n                .conflictResultionTasks()\n                .subscribe(task => {\n                    this\n                        .conflictHandler(task.input, task.context)\n                        .then(output => {\n                            this.storageInstance.resolveConflictResultionTask({\n                                id: task.id,\n                                output\n                            });\n                        });\n                })\n        );\n\n        return PROMISE_RESOLVE_VOID;\n    }\n\n\n    // overwritte by migration-plugin\n    migrationNeeded(): Promise<boolean> {\n        throw pluginMissing('migration');\n    }\n    getDataMigrator(): DataMigrator {\n        throw pluginMissing('migration');\n    }\n    migrate(batchSize: number = 10): Observable<MigrationState> {\n        return this.getDataMigrator().migrate(batchSize);\n    }\n    migratePromise(batchSize: number = 10): Promise<any> {\n        return this.getDataMigrator().migratePromise(batchSize);\n    }\n\n    async insert(\n        json: RxDocumentType | RxDocument\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const useJson: RxDocumentWriteData<RxDocumentType> = fillObjectDataBeforeInsert(this.schema, json);\n        const writeResult = await this.bulkInsert([useJson]);\n\n        const isError = writeResult.error[0];\n        throwIfIsStorageWriteError(this as any, useJson[this.schema.primaryPath] as any, json, isError);\n        const insertResult = ensureNotFalsy(writeResult.success[0]);\n        return insertResult;\n    }\n\n    async bulkInsert(\n        docsData: RxDocumentType[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[],\n        error: RxStorageBulkWriteError<RxDocumentType>[]\n    }> {\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (docsData.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const useDocs = docsData.map(docData => {\n            const useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n            return useDocData;\n        });\n        const docs = this.hasHooks('pre', 'insert') ?\n            await Promise.all(\n                useDocs.map(doc => {\n                    return this._runHooks('pre', 'insert', doc)\n                        .then(() => {\n                            return doc;\n                        });\n                })\n            ) : useDocs;\n        const docsMap: Map<string, RxDocumentType> = new Map();\n        const insertRows: BulkWriteRow<RxDocumentType>[] = docs.map(doc => {\n            docsMap.set((doc as any)[this.schema.primaryPath] as any, doc);\n            const docData = Object.assign(doc, {\n                _attachments: {},\n                _meta: getDefaultRxDocumentMeta(),\n                _rev: getDefaultRevision(),\n                _deleted: false\n            });\n            const row: BulkWriteRow<RxDocumentType> = { document: docData };\n            return row;\n        });\n        const results = await this.storageInstance.bulkWrite(\n            insertRows,\n            'rx-collection-bulk-insert'\n        );\n\n        // create documents\n        const successDocData: RxDocumentData<RxDocumentType>[] = Object.values(results.success);\n        const rxDocuments: any[] = successDocData\n            .map((writtenDocData) => {\n                const doc = createRxDocument(this as any, writtenDocData);\n                return doc;\n            });\n\n        if (this.hasHooks('post', 'insert')) {\n            await Promise.all(\n                rxDocuments.map(doc => {\n                    return this._runHooks(\n                        'post', 'insert',\n                        docsMap.get(doc.primary),\n                        doc\n                    );\n                })\n            );\n        }\n\n        return {\n            success: rxDocuments,\n            error: Object.values(results.error)\n        };\n    }\n\n    async bulkRemove(\n        ids: string[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[],\n        error: RxStorageBulkWriteError<RxDocumentType>[]\n    }> {\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (ids.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const rxDocumentMap = await this.findByIds(ids);\n        const docsData: RxDocumentData<RxDocumentType>[] = [];\n        const docsMap: Map<string, RxDocumentData<RxDocumentType>> = new Map();\n        Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n            const data: RxDocumentData<RxDocumentType> = clone(rxDocument.toJSON(true)) as any;\n            docsData.push(data);\n            docsMap.set(rxDocument.primary, data);\n        });\n\n        await Promise.all(\n            docsData.map(doc => {\n                const primary = (doc as any)[this.schema.primaryPath];\n                return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n            })\n        );\n\n\n        const removeDocs: BulkWriteRow<RxDocumentType>[] = docsData.map(doc => {\n            const writeDoc = flatClone(doc);\n            writeDoc._deleted = true;\n            return {\n                previous: doc,\n                document: writeDoc\n            };\n        });\n        const results = await this.storageInstance.bulkWrite(\n            removeDocs,\n            'rx-collection-bulk-remove'\n        );\n\n        const successIds: string[] = Object.keys(results.success);\n\n        // run hooks\n        await Promise.all(\n            successIds.map(id => {\n                return this._runHooks(\n                    'post',\n                    'remove',\n                    docsMap.get(id),\n                    rxDocumentMap.get(id)\n                );\n            })\n        );\n\n        const rxDocuments: any[] = successIds.map(id => {\n            return rxDocumentMap.get(id);\n        });\n\n        return {\n            success: rxDocuments,\n            error: Object.values(results.error)\n        };\n    }\n\n    /**\n     * same as bulkInsert but overwrites existing document with same primary\n     */\n    async bulkUpsert(docsData: Partial<RxDocumentType>[]): Promise<RxDocument<RxDocumentType, OrmMethods>[]> {\n        const insertData: RxDocumentType[] = [];\n        const useJsonByDocId: Map<string, RxDocumentType> = new Map();\n        docsData.forEach(docData => {\n            const useJson = fillObjectDataBeforeInsert(this.schema, docData);\n            const primary: string = useJson[this.schema.primaryPath] as any;\n            if (!primary) {\n                throw newRxError('COL3', {\n                    primaryPath: this.schema.primaryPath as string,\n                    data: useJson,\n                    schema: this.schema.jsonSchema\n                });\n            }\n            useJsonByDocId.set(primary, useJson);\n            insertData.push(useJson);\n        });\n\n        const insertResult = await this.bulkInsert(insertData);\n        let ret = insertResult.success.slice(0);\n        const updatedDocs = await Promise.all(\n            insertResult.error.map(error => {\n                const id = error.documentId;\n                const writeData = getFromMapOrThrow(useJsonByDocId, id);\n                const docDataInDb = ensureNotFalsy(error.documentInDb);\n                const doc = createRxDocument(this.asRxCollection, docDataInDb);\n                return doc.atomicUpdate(() => writeData);\n            })\n        );\n        ret = ret.concat(updatedDocs);\n        return ret;\n    }\n\n    /**\n     * same as insert but overwrites existing document with same primary\n     */\n    upsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        return this.bulkUpsert([json]).then(result => result[0]);\n    }\n\n    /**\n     * upserts to a RxDocument, uses atomicUpdate if document already exists\n     */\n    atomicUpsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const useJson = fillObjectDataBeforeInsert(this.schema, json);\n        const primary: string = useJson[this.schema.primaryPath] as any;\n        if (!primary) {\n            throw newRxError('COL4', {\n                data: json\n            });\n        }\n\n        // ensure that it wont try 2 parallel runs\n        let queue = this._atomicUpsertQueues.get(primary);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue\n            .then(() => _atomicUpsertEnsureRxDocumentExists(this as any, primary as any, useJson))\n            .then((wasInserted) => {\n                if (!wasInserted.inserted) {\n                    return _atomicUpsertUpdate(wasInserted.doc, useJson)\n                        .then(() => wasInserted.doc);\n                } else {\n                    return wasInserted.doc;\n                }\n            });\n        this._atomicUpsertQueues.set(primary, queue);\n        return queue;\n    }\n\n    find(queryObj?: MangoQuery<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>[]\n    > {\n        if (typeof queryObj === 'string') {\n            throw newRxError('COL5', {\n                queryObj\n            });\n        }\n\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n\n        const query = createRxQuery('find', queryObj, this as any);\n        return query as any;\n    }\n\n    findOne(queryObj?: MangoQueryNoLimit<RxDocumentType> | string): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>\n        | null\n    > {\n        let query;\n\n        if (typeof queryObj === 'string') {\n            query = createRxQuery('findOne', {\n                selector: {\n                    [this.schema.primaryPath]: queryObj\n                },\n                limit: 1\n            }, this as any);\n        } else {\n            if (!queryObj) {\n                queryObj = _getDefaultQuery();\n            }\n\n            // cannot have limit on findOne queries because it will be overwritte\n            if ((queryObj as MangoQuery).limit) {\n                throw newRxError('QU6');\n            }\n\n            (queryObj as any).limit = 1;\n            query = createRxQuery('findOne', queryObj, this as any);\n        }\n\n        if (\n            typeof queryObj === 'number' ||\n            Array.isArray(queryObj)\n        ) {\n            throw newRxTypeError('COL6', {\n                queryObj\n            });\n        }\n\n        return query as any;\n    }\n\n    /**\n     * find a list documents by their primary key\n     * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n     */\n    async findByIds(\n        ids: string[]\n    ): Promise<Map<string, RxDocument<RxDocumentType, OrmMethods>>> {\n\n        const ret = new Map();\n        const mustBeQueried: string[] = [];\n\n        // first try to fill from docCache\n        ids.forEach(id => {\n            const doc = this._docCache.get(id);\n            if (doc) {\n                ret.set(id, doc);\n            } else {\n                mustBeQueried.push(id);\n            }\n        });\n\n        // find everything which was not in docCache\n        if (mustBeQueried.length > 0) {\n            const docs = await this.storageInstance.findDocumentsById(mustBeQueried, false);\n            Object.values(docs).forEach(docData => {\n                const doc = createRxDocument<RxDocumentType, OrmMethods>(this as any, docData);\n                ret.set(doc.primary, doc);\n            });\n        }\n        return ret;\n    }\n\n    /**\n     * like this.findByIds but returns an observable\n     * that always emits the current state\n     */\n    findByIds$(\n        ids: string[]\n    ): Observable<Map<string, RxDocument<RxDocumentType, OrmMethods>>> {\n        let currentValue: Map<string, RxDocument<RxDocumentType, OrmMethods>> | null = null;\n        let lastChangeEvent: number = -1;\n\n        /**\n         * Ensure we do not process events in parallel\n         */\n        let queue: Promise<any> = PROMISE_RESOLVE_VOID;\n\n        const initialPromise = this.findByIds(ids).then(docsMap => {\n            lastChangeEvent = this._changeEventBuffer.counter;\n            currentValue = docsMap;\n        });\n        let firstEmitDone = false;\n\n        return this.$.pipe(\n            startWith(null),\n            /**\n             * Optimization shortcut.\n             * Do not proceed if the emited RxChangeEvent\n             * is not relevant for the query.\n             */\n            filter(changeEvent => {\n                if (\n                    // first emit has no event\n                    changeEvent &&\n                    (\n                        // local documents are not relevant for the query\n                        changeEvent.isLocal ||\n                        // document of the change is not in the ids list.\n                        !ids.includes(changeEvent.documentId)\n                    )\n                ) {\n                    return false;\n                } else {\n                    return true;\n                }\n            }),\n            mergeMap(() => initialPromise),\n            /**\n             * Because shareReplay with refCount: true\n             * will often subscribe/unsusbscribe\n             * we always ensure that we handled all missed events\n             * since the last subscription.\n             */\n            mergeMap(() => {\n                queue = queue.then(async () => {\n                    /**\n                     * We first have to clone the Map\n                     * to ensure we do not create side effects by mutating\n                     * a Map that has already been returned before.\n                     */\n                    currentValue = new Map(ensureNotFalsy(currentValue));\n                    const missedChangeEvents = this._changeEventBuffer.getFrom(lastChangeEvent + 1);\n                    lastChangeEvent = this._changeEventBuffer.counter;\n                    if (missedChangeEvents === null) {\n                        /**\n                         * changeEventBuffer is of bounds -> we must re-execute over the database\n                         * because we cannot calculate the new results just from the events.\n                         */\n                        const newResult = await this.findByIds(ids);\n                        lastChangeEvent = this._changeEventBuffer.counter;\n                        return newResult;\n                    } else {\n                        let resultHasChanged = false;\n                        missedChangeEvents\n                            .forEach(rxChangeEvent => {\n                                const docId = rxChangeEvent.documentId;\n                                if (!ids.includes(docId)) {\n                                    // document is not relevant for the result set\n                                    return;\n                                }\n                                const op = rxChangeEvent.operation;\n                                if (op === 'INSERT' || op === 'UPDATE') {\n                                    resultHasChanged = true;\n                                    const rxDocument = createRxDocument(\n                                        this.asRxCollection,\n                                        rxChangeEvent.documentData\n                                    );\n                                    ensureNotFalsy(currentValue).set(docId, rxDocument);\n                                } else {\n                                    if (ensureNotFalsy(currentValue).has(docId)) {\n                                        resultHasChanged = true;\n                                        ensureNotFalsy(currentValue).delete(docId);\n                                    }\n                                }\n                            });\n\n                        // nothing happened that affects the result -> do not emit\n                        if (!resultHasChanged && firstEmitDone) {\n                            return false as any;\n                        }\n                    }\n                    firstEmitDone = true;\n                    return currentValue;\n                });\n                return queue;\n            }),\n            filter(x => !!x),\n            shareReplay(RXJS_SHARE_REPLAY_DEFAULTS)\n        );\n    }\n\n    /**\n     * Export collection to a JSON friendly format.\n     */\n    exportJSON(): Promise<RxDumpCollection<RxDocumentType>>;\n    exportJSON(): Promise<RxDumpCollectionAny<RxDocumentType>>;\n    exportJSON(): Promise<any> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * Import the parsed JSON export into the collection.\n     * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n     */\n    importJSON(_exportedJSON: RxDumpCollectionAny<RxDocumentType>): Promise<void> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * sync with a CouchDB endpoint\n     */\n    syncCouchDB(_syncOptions: SyncOptions): RxCouchDBReplicationState {\n        throw pluginMissing('replication');\n    }\n\n    /**\n     * sync with a GraphQL endpoint\n     */\n    syncGraphQL<CheckpointType = any>(_options: SyncOptionsGraphQL<RxDocumentType, CheckpointType>): RxGraphQLReplicationState<RxDocumentType, CheckpointType> {\n        throw pluginMissing('replication-graphql');\n    }\n\n    /**\n     * HOOKS\n     */\n    addHook(when: HookWhenType, key: HookKeyType, fun: any, parallel = false) {\n        if (typeof fun !== 'function') {\n            throw newRxTypeError('COL7', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_WHEN.includes(when)) {\n            throw newRxTypeError('COL8', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_KEYS.includes(key)) {\n            throw newRxError('COL9', {\n                key\n            });\n        }\n\n        if (when === 'post' && key === 'create' && parallel === true) {\n            throw newRxError('COL10', {\n                when,\n                key,\n                parallel\n            });\n        }\n\n        // bind this-scope to hook-function\n        const boundFun = fun.bind(this);\n\n        const runName = parallel ? 'parallel' : 'series';\n\n        this.hooks[key] = this.hooks[key] || {};\n        this.hooks[key][when] = this.hooks[key][when] || {\n            series: [],\n            parallel: []\n        };\n        this.hooks[key][when][runName].push(boundFun);\n    }\n\n    getHooks(when: HookWhenType, key: HookKeyType) {\n        if (\n            !this.hooks[key] ||\n            !this.hooks[key][when]\n        ) {\n            return {\n                series: [],\n                parallel: []\n            };\n        }\n        return this.hooks[key][when];\n    }\n\n    hasHooks(when: HookWhenType, key: HookKeyType) {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) {\n            return false;\n        }\n        return hooks.series.length > 0 || hooks.parallel.length > 0;\n    }\n\n    _runHooks(when: HookWhenType, key: HookKeyType, data: any, instance?: any): Promise<any> {\n        const hooks = this.getHooks(when, key);\n\n        if (!hooks) {\n            return PROMISE_RESOLVE_VOID;\n        }\n\n        // run parallel: false\n        const tasks = hooks.series.map((hook: any) => () => hook(data, instance));\n        return promiseSeries(tasks)\n            // run parallel: true\n            .then(() => Promise.all(\n                hooks.parallel\n                    .map((hook: any) => hook(data, instance))\n            ));\n    }\n\n    /**\n     * does the same as ._runHooks() but with non-async-functions\n     */\n    _runHooksSync(when: HookWhenType, key: HookKeyType, data: any, instance: any) {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) return;\n        hooks.series.forEach((hook: any) => hook(data, instance));\n    }\n\n    /**\n     * Returns a promise that resolves after the given time.\n     * Ensures that is properly cleans up when the collection is destroyed\n     * so that no running timeouts prevent the exit of the JavaScript process.\n     */\n    promiseWait(time: number): Promise<void> {\n        const ret = new Promise<void>(res => {\n            const timeout = setTimeout(() => {\n                this.timeouts.delete(timeout);\n                res();\n            }, time);\n            this.timeouts.add(timeout);\n        });\n        return ret;\n    }\n\n    destroy(): Promise<boolean> {\n        if (this.destroyed) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        /**\n         * Settings destroyed = true\n         * must be the first thing to do,\n         * so for example the replication can directly stop\n         * instead of sending requests to a closed storage.\n         */\n        this.destroyed = true;\n\n\n        Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n        if (this._changeEventBuffer) {\n            this._changeEventBuffer.destroy();\n        }\n        /**\n         * First wait until the whole database is idle.\n         * This ensures that the storage does not get closed\n         * while some operation is running.\n         * It is important that we do not intercept a running call\n         * because it might lead to undefined behavior like when a doc is written\n         * but the change is not added to the changes collection.\n         */\n        return this.database.requestIdlePromise()\n            .then(() => Promise.all(this.onDestroy.map(fn => fn())))\n            .then(() => this.storageInstance.close())\n            .then(() => {\n                /**\n                 * Unsubscribing must be done AFTER the storageInstance.close()\n                 * Because the conflict handling is part of the subscriptions and\n                 * otherwise there might be open conflicts to be resolved which\n                 * will then stuck and never resolve.\n                 */\n                this._subs.forEach(sub => sub.unsubscribe());\n\n                delete this.database.collections[this.name];\n                return runAsyncPluginHooks('postDestroyRxCollection', this).then(() => true);\n            });\n    }\n\n    /**\n     * remove all data of the collection\n     */\n    async remove(): Promise<any> {\n        await this.destroy();\n        await removeCollectionStorages(\n            this.database.storage,\n            this.database.internalStore,\n            this.database.token,\n            this.database.name,\n            this.name,\n            this.database.hashFunction\n        );\n    }\n\n    get asRxCollection(): RxCollection<RxDocumentType, OrmMethods, StaticMethods> {\n        return this as any;\n    }\n}\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(\n    collection: RxCollection<any, any>\n) {\n    if (hooksApplied) return; // already run\n    hooksApplied = true;\n    const colProto = Object.getPrototypeOf(collection);\n    HOOKS_KEYS.forEach(key => {\n        HOOKS_WHEN.map(when => {\n            const fnName = when + ucfirst(key);\n            colProto[fnName] = function (fun: string, parallel: boolean) {\n                return this.addHook(when, key, fun, parallel);\n            };\n        });\n    });\n}\n\nfunction _atomicUpsertUpdate<RxDocType>(\n    doc: RxDocumentBase<RxDocType>,\n    json: RxDocumentData<RxDocType>\n): Promise<RxDocumentBase<RxDocType>> {\n    return doc.atomicUpdate((_innerDoc: RxDocumentData<RxDocType>) => {\n        return json;\n    })\n        .then(() => nextTick())\n        .then(() => {\n            return doc;\n        });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _atomicUpsertEnsureRxDocumentExists(\n    rxCollection: RxCollection,\n    primary: string,\n    json: any\n): Promise<\n    {\n        doc: RxDocument,\n        inserted: boolean\n    }\n> {\n    /**\n     * Optimisation shortcut,\n     * first try to find the document in the doc-cache\n     */\n    const docFromCache = rxCollection._docCache.get(primary);\n    if (docFromCache) {\n        return Promise.resolve({\n            doc: docFromCache,\n            inserted: false\n        });\n    }\n    return rxCollection.findOne(primary).exec()\n        .then(doc => {\n            if (!doc) {\n                return rxCollection.insert(json).then(newDoc => ({\n                    doc: newDoc,\n                    inserted: true\n                }));\n            } else {\n                return {\n                    doc,\n                    inserted: false\n                };\n            }\n        });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection(\n    {\n        database,\n        name,\n        schema,\n        instanceCreationOptions = {},\n        migrationStrategies = {},\n        autoMigrate = true,\n        statics = {},\n        methods = {},\n        attachments = {},\n        options = {},\n        localDocuments = false,\n        cacheReplacementPolicy = defaultCacheReplacementPolicy,\n        conflictHandler = defaultConflictHandler\n    }: any\n): Promise<RxCollection> {\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseInstanceToken: database.token,\n        databaseName: database.name,\n        collectionName: name,\n        schema: schema.jsonSchema,\n        options: instanceCreationOptions,\n        multiInstance: database.multiInstance,\n        password: database.password\n    };\n\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    return createRxCollectionStorageInstance(\n        database,\n        storageInstanceCreationParams\n    ).then(storageInstance => {\n        const collection = new RxCollectionBase(\n            database,\n            name,\n            schema,\n            storageInstance,\n            instanceCreationOptions,\n            migrationStrategies,\n            methods,\n            attachments,\n            options,\n            cacheReplacementPolicy,\n            statics,\n            conflictHandler\n        );\n\n        return collection\n            .prepare()\n            .then(() => {\n                // ORM add statics\n                Object\n                    .entries(statics)\n                    .forEach(([funName, fun]) => {\n                        Object.defineProperty(collection, funName, {\n                            get: () => (fun as any).bind(collection)\n                        });\n                    });\n\n                let ret = PROMISE_RESOLVE_VOID;\n                if (autoMigrate && collection.schema.version !== 0) {\n                    ret = collection.migratePromise();\n                }\n                return ret;\n            })\n            .then(() => {\n                runPluginHooks('createRxCollection', {\n                    collection,\n                    creator: {\n                        name,\n                        schema,\n                        storageInstance,\n                        instanceCreationOptions,\n                        migrationStrategies,\n                        methods,\n                        attachments,\n                        options,\n                        cacheReplacementPolicy,\n                        localDocuments,\n                        statics\n                    }\n                });\n                return collection as any;\n            })\n            /**\n             * If the collection creation fails,\n             * we yet have to close the storage instances.\n             */\n            .catch(err => {\n                return storageInstance.close()\n                    .then(() => Promise.reject(err));\n            });\n    });\n}\n\nexport function isRxCollection(obj: any): boolean {\n    return obj instanceof RxCollectionBase;\n}\n"],"mappings":"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"}
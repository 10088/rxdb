{"version":3,"file":"rx-storage-replication.js","names":["BehaviorSubject","combineLatest","filter","firstValueFrom","fillWithDefaultSettings","getComposedPrimaryKeyOfDocumentData","getPrimaryFieldOfPrimaryKey","flatCloneDocWithMeta","createRevision","ensureNotFalsy","fastUnsecureHash","flatClone","getDefaultRevision","lastOfArray","now","parseRevision","PROMISE_RESOLVE_VOID","pact","state","value","s","v","o","bind","then","observer","prototype","onFulfilled","onRejected","result","callback","e","_this","thenable","test","update","body","stage","shouldContinue","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","getAssumedMasterState","docIds","input","metaInstance","findDocumentsById","map","docId","useId","RX_REPLICATION_META_INSTANCE_SCHEMA","itemId","replicationIdentifier","checkpointKey","isCheckpoint","metaDocs","ret","Object","values","forEach","metaDoc","docData","data","metaDocument","awaitRxStorageReplicationIdle","awaitRxStorageReplicationFirstInSync","streamQueue","down","up","Promise","all","firstSyncDone","pipe","setCheckpoint","direction","checkpointDoc","checkpoint","lastCheckpoint","canceled","getValue","JSON","stringify","newDoc","id","_deleted","_attachments","_meta","lwt","_rev","bulkWrite","previous","document","resolveConflictError","conflictHandler","error","status","Error","documentInDb","writeRow","undefined","assumedMasterState","newDocumentState","realMasterState","conflictHandlerOutput","resolvedDoc","assign","documentData","getLastCheckpointDoc","checkpointDocId","checkpointResult","FROM_FORK_FLAG_SUFFIX","primaryKey","key","fields","separator","type","version","additionalProperties","properties","minLength","maxLength","required","replicateRxStorageInstance","primaryPath","masterInstance","schema","getCheckpointKey","startReplicationDownstream","startReplicationUpstream","downstreamSyncOnce","checkpointState","writeToChildQueue","next","lastCheckpointDoc","done","getChangedDocumentsSince","bulkSize","downResult","length","useDownDocs","r","downDocsById","d","forkInstance","currentForkState","useMetaWriteRows","writeRowsToFork","writeRowsToMeta","forkState","masterState","assumedMaster","push","getMetaWriteRow","forkWriteResult","keys","success","inQueueCount","addRunAgain","sub","changeStream","subscribe","unsubscribe","upstreamSyncOnce","writeToMasterQueue","hadConflictWrites","upResult","useUpDocs","writeRowsToMaster","doc","useDoc","assumedMasterDoc","height","masterWriteResult","conflictWriteFork","conflictWriteMeta","entries","resolved","useMetaWrites","useWriteRowsToMeta","waitBeforePersist","hash","identifier","storage","name","databaseName","collectionName","join","newMasterDocState","newMeta","defaultConflictHandler","i","_context"],"sources":["../../src/rx-storage-replication.ts"],"sourcesContent":["/**\n * Replicates two RxStorageInstances\n * with each other.\n * \n * Compared to the 'normal' replication plugins,\n * this one is made for internal use where:\n * - No permission handling is needed.\n * - It is made so that the write amount on the master is less but might increase on the child.\n * - It does not have to be easy to implement a compatible backend.\n *   Here we use another RxStorageImplementation as replication goal\n *   so it has to exactly behave like the RxStorage interface defines.\n * \n * This is made to be used internally by plugins\n * to get a really fast replication performance.\n * \n * The replication works like git, where the fork contains all new writes\n * and must be merged with the master before it can push it's new state to the master.\n */\n\nimport {\n    BehaviorSubject,\n    combineLatest,\n    filter,\n    firstValueFrom\n} from 'rxjs';\nimport {\n    fillWithDefaultSettings,\n    getComposedPrimaryKeyOfDocumentData,\n    getPrimaryFieldOfPrimaryKey\n} from './rx-schema-helper';\nimport { flatCloneDocWithMeta } from './rx-storage-helper';\nimport type {\n    BulkWriteRow,\n    BulkWriteRowById,\n    RxConflictHandler,\n    RxConflictHandlerInput,\n    RxConflictHandlerOutput,\n    RxDocumentData,\n    RxDocumentDataById,\n    RxJsonSchema,\n    RxStorageBulkWriteError,\n    RxStorageInstanceReplicationInput,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationDirection,\n    RxStorageReplicationMeta\n} from './types';\nimport {\n    createRevision,\n    ensureNotFalsy,\n    fastUnsecureHash,\n    flatClone,\n    getDefaultRevision,\n    lastOfArray,\n    now,\n    parseRevision,\n    PROMISE_RESOLVE_VOID\n} from './util';\n\n\n/**\n * Flags that a document state was written to the master\n * by the upstream from the fork.\n * Used in the ._meta of the document data that is stored at the master\n * and contains only the revision.\n * We need this to detect if the document state was written from the upstream\n * so that it is not again replicated to the downstream.\n * TODO instead of doing that, we should have a way to 'mark' bulkWrite()\n * calls so that the emitted events can be detected as being from the upstream.\n */\nconst FROM_FORK_FLAG_SUFFIX = '-fork';\n\n\nexport const RX_REPLICATION_META_INSTANCE_SCHEMA: RxJsonSchema<RxDocumentData<RxStorageReplicationMeta>> = fillWithDefaultSettings({\n    primaryKey: {\n        key: 'id',\n        fields: [\n            'replicationIdentifier',\n            'itemId',\n            'isCheckpoint'\n        ],\n        separator: '|'\n    },\n    type: 'object',\n    version: 0,\n    additionalProperties: false,\n    properties: {\n        id: {\n            type: 'string',\n            minLength: 1,\n            maxLength: 100\n        },\n        replicationIdentifier: {\n            type: 'string'\n        },\n        isCheckpoint: {\n            type: 'string',\n            enum: [\n                '0',\n                '1'\n            ],\n            maxLength: 1\n        },\n        itemId: {\n            type: 'string'\n        },\n        data: {\n            type: 'object',\n            additionalProperties: true\n        }\n    },\n    required: [\n        'id',\n        'replicationIdentifier',\n        'isCheckpoint',\n        'itemId',\n        'data'\n    ]\n});\n\nexport function replicateRxStorageInstance<RxDocType>(\n    input: RxStorageInstanceReplicationInput<RxDocType>\n): RxStorageInstanceReplicationState<RxDocType> {\n    const state: RxStorageInstanceReplicationState<RxDocType> = {\n        primaryPath: getPrimaryFieldOfPrimaryKey(input.masterInstance.schema.primaryKey),\n        input,\n        checkpointKey: getCheckpointKey(input),\n        canceled: new BehaviorSubject<boolean>(false),\n        firstSyncDone: {\n            down: new BehaviorSubject<boolean>(false),\n            up: new BehaviorSubject<boolean>(false)\n        },\n        lastCheckpoint: {},\n        streamQueue: {\n            down: PROMISE_RESOLVE_VOID,\n            up: PROMISE_RESOLVE_VOID\n        }\n    };\n\n    startReplicationDownstream(state);\n    startReplicationUpstream(state);\n    return state;\n}\n\n\n/**\n * Writes all documents from the master to the fork.\n */\nexport function startReplicationDownstream<RxDocType>(\n    state: RxStorageInstanceReplicationState<RxDocType>\n) {\n    let inQueueCount = 0;\n    state.streamQueue.down = state.streamQueue.down.then(() => downstreamSyncOnce());\n\n    function addRunAgain() {\n        if (inQueueCount > 2) {\n            return;\n        }\n        inQueueCount = inQueueCount + 1;\n        state.streamQueue.down = state.streamQueue.down\n            .then(() => downstreamSyncOnce())\n            .catch(() => { })\n            .then(() => inQueueCount = inQueueCount - 1);\n    }\n\n    /**\n     * If a write on the master happens, we have to trigger the downstream.\n     */\n    const sub = state.input.masterInstance.changeStream().subscribe(() => {\n        addRunAgain();\n    });\n    firstValueFrom(\n        state.canceled.pipe(\n            filter(canceled => !!canceled)\n        )\n    ).then(() => sub.unsubscribe());\n\n\n    /**\n     * For faster performance, we directly start each write\n     * and then await all writes at the end.\n     */\n    let writeToChildQueue: Promise<any> = PROMISE_RESOLVE_VOID;\n\n\n    async function downstreamSyncOnce() {\n        if (state.canceled.getValue()) {\n            return;\n        }\n        const checkpointState = await getLastCheckpointDoc(state, 'down');\n        const lastCheckpointDoc = checkpointState ? checkpointState.checkpointDoc : undefined;\n\n        let done = false;\n        while (!done && !state.canceled.getValue()) {\n            const downResult = await state.input.masterInstance.getChangedDocumentsSince(\n                state.input.bulkSize,\n                state.lastCheckpoint.down\n            );\n            if (downResult.length === 0) {\n                done = true;\n                continue;\n            }\n\n            const useDownDocs = downResult.map(r => r.document);\n            state.lastCheckpoint.down = lastOfArray(downResult).checkpoint;\n            writeToChildQueue = writeToChildQueue.then((async () => {\n                const downDocsById: RxDocumentDataById<RxDocType> = {};\n                const docIds = useDownDocs\n                    .map(d => {\n                        const id = (d as any)[state.primaryPath];\n                        downDocsById[id] = d;\n                        return id;\n                    });\n\n                const [\n                    currentForkState,\n                    assumedMasterState\n                ] = await Promise.all([\n                    state.input.forkInstance.findDocumentsById(docIds, true),\n                    getAssumedMasterState(\n                        state,\n                        docIds\n                    )\n                ]);\n\n                const writeRowsToFork: BulkWriteRow<RxDocType>[] = [];\n                const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta> = {};\n                const useMetaWriteRows: BulkWriteRow<RxStorageReplicationMeta>[] = [];\n                docIds.forEach(docId => {\n                    const forkState: RxDocumentData<RxDocType> | undefined = currentForkState[docId];\n                    const masterState = downDocsById[docId];\n                    const assumedMaster = assumedMasterState[docId];\n\n                    if (\n                        (\n                            forkState && assumedMaster &&\n                            assumedMaster.docData._rev !== forkState._rev\n                        ) ||\n                        (\n                            forkState && !assumedMaster\n                        )\n                    ) {\n                        /**\n                         * We have a non-upstream-replicated\n                         * local write to the fork.\n                         * This means we ignore the downstream of this document\n                         * because anyway the upstream will first resolve the conflict.\n                         */\n                        return;\n                    }\n\n                    if (\n                        forkState &&\n                        forkState._rev === masterState._rev\n                    ) {\n                        /**\n                         * Document states are exactly equal.\n                         * This can happen when the replication is shut down\n                         * unexpected like when the user goes offline.\n                         * \n                         * Only when the assumedMaster is differnt from the forkState,\n                         * we have to patch the document in the meta instance.\n                         */\n                        if (\n                            !assumedMaster ||\n                            assumedMaster.docData._rev !== forkState._rev\n                        ) {\n                            useMetaWriteRows.push(\n                                getMetaWriteRow(\n                                    state,\n                                    forkState,\n                                    assumedMaster ? assumedMaster.metaDocument : undefined\n                                )\n                            );\n                        }\n                        return;\n                    }\n\n                    /**\n                     * All other master states need to be written to the forkInstance\n                     * and metaInstance.\n                     */\n                    writeRowsToFork.push({\n                        previous: forkState,\n                        document: masterState\n                    });\n                    writeRowsToMeta[docId] = getMetaWriteRow(\n                        state,\n                        masterState,\n                        assumedMaster ? assumedMaster.metaDocument : undefined\n                    );\n                });\n\n                if (writeRowsToFork.length > 0) {\n                    const forkWriteResult = await state.input.forkInstance.bulkWrite(writeRowsToFork);\n                    Object.keys(forkWriteResult.success).forEach((docId) => {\n                        useMetaWriteRows.push(writeRowsToMeta[docId]);\n                    });\n                }\n                if (useMetaWriteRows.length > 0) {\n                    await state.input.metaInstance.bulkWrite(useMetaWriteRows);\n                }\n            }));\n        }\n        await writeToChildQueue;\n\n        if (!state.firstSyncDone.down.getValue()) {\n            state.firstSyncDone.down.next(true);\n        }\n\n        /**\n         * Write the new checkpoint\n         */\n        await setCheckpoint(\n            state,\n            'down',\n            lastCheckpointDoc\n        );\n    }\n}\n\n\n/**\n * Writes all document changes from the client to the master.\n */\nexport function startReplicationUpstream<RxDocType>(\n    state: RxStorageInstanceReplicationState<RxDocType>\n) {\n    let writeToMasterQueue: Promise<any> = PROMISE_RESOLVE_VOID;\n\n    let inQueueCount = 0;\n    state.streamQueue.up = state.streamQueue.up.then(() => upstreamSyncOnce());\n\n    function addRunAgain() {\n        if (inQueueCount > 2) {\n            return state.streamQueue.up;\n        }\n        inQueueCount = inQueueCount + 1;\n        state.streamQueue.up = state.streamQueue.up\n            .then(() => upstreamSyncOnce())\n            .catch(() => { })\n            .then(() => inQueueCount = inQueueCount - 1);\n        return state.streamQueue.up;\n    }\n    const sub = state.input.forkInstance.changeStream().subscribe(async () => {\n        if (state.input.waitBeforePersist) {\n            await state.input.waitBeforePersist();\n        }\n        addRunAgain();\n    });\n    firstValueFrom(\n        state.canceled.pipe(\n            filter(canceled => !!canceled)\n        )\n    ).then(() => sub.unsubscribe());\n\n\n    async function upstreamSyncOnce() {\n        if (state.canceled.getValue()) {\n            return;\n        }\n\n        const checkpointState = await getLastCheckpointDoc(state, 'up');\n        const lastCheckpointDoc = checkpointState ? checkpointState.checkpointDoc : undefined;\n\n        /**\n         * If this goes to true,\n         * it means that we have to do a new write to the\n         * fork instance to resolve a conflict.\n         * In that case, state.firstSyncDone.up\n         * must not be set to true, because\n         * an additional upstream cycle must be used\n         * to push the resolved conflict state.\n         */\n        let hadConflictWrites = false;\n\n        let done = false;\n        while (!done && !state.canceled.getValue()) {\n            const upResult = await state.input.forkInstance.getChangedDocumentsSince(\n                state.input.bulkSize,\n                state.lastCheckpoint.up\n            );\n            if (\n                upResult.length === 0 ||\n                state.canceled.getValue()\n            ) {\n                done = true;\n                continue;\n            }\n\n            state.lastCheckpoint.up = lastOfArray(upResult).checkpoint;\n            writeToMasterQueue = writeToMasterQueue.then((async () => {\n\n                // used to not have infinity loop during development\n                // that cannot be exited via Ctrl+C\n                // await promiseWait(0);\n\n                if (state.canceled.getValue()) {\n                    return;\n                }\n\n                const useUpDocs = upResult.map(r => r.document);\n                if (useUpDocs.length === 0) {\n                    return;\n                }\n\n                const assumedMasterState = await getAssumedMasterState(\n                    state,\n                    useUpDocs.map(d => (d as any)[state.primaryPath])\n                );\n                const writeRowsToMaster: BulkWriteRow<RxDocType>[] = [];\n                const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta> = {};\n\n                useUpDocs.forEach(doc => {\n                    const docId: string = (doc as any)[state.primaryPath];\n                    const useDoc = flatCloneDocWithMeta(doc);\n                    useDoc._meta[state.checkpointKey + FROM_FORK_FLAG_SUFFIX] = useDoc._rev;\n                    useDoc._meta.lwt = now();\n\n                    const assumedMasterDoc = assumedMasterState[docId];\n\n                    /**\n                     * If the master state is equal to the\n                     * fork state, we can assume that the document state is already\n                     * replicated.\n                     */\n                    if (\n                        assumedMasterDoc &&\n                        assumedMasterDoc.docData._rev === useDoc._rev\n                    ) {\n                        return;\n                    }\n\n                    /**\n                     * If the assumed master state has a heigher revision height\n                     * then the current document state,\n                     * we can assume that a downstream replication has happend in between\n                     * and we can drop this upstream replication.\n                     * \n                     * TODO there is no real reason why this should ever happen,\n                     * however the replication did not work on the PouchDB RxStorage\n                     * without this fix.\n                     */\n                    if (\n                        assumedMasterDoc &&\n                        parseRevision(assumedMasterDoc.docData._rev).height >= parseRevision(useDoc._rev).height\n                    ) {\n                        return;\n                    }\n\n                    writeRowsToMaster.push({\n                        previous: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n                        document: useDoc\n                    });\n                    writeRowsToMeta[docId] = getMetaWriteRow(\n                        state,\n                        useDoc,\n                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined\n                    );\n                });\n\n                if (writeRowsToMaster.length === 0) {\n                    return;\n                }\n                const masterWriteResult = await state.input.masterInstance.bulkWrite(writeRowsToMaster);\n\n                const useWriteRowsToMeta: BulkWriteRow<RxStorageReplicationMeta>[] = [];\n                Object.keys(masterWriteResult.success).forEach(docId => {\n                    useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n                });\n                if (useWriteRowsToMeta.length > 0) {\n                    await state.input.metaInstance.bulkWrite(useWriteRowsToMeta);\n                    // TODO what happens when we have conflicts here?\n                }\n\n                /**\n                 * Resolve conflicts by writing a new document\n                 * state to the fork instance and the 'real' master state\n                 * to the meta instance.\n                 * Non-409 errors will be detected by resolveConflictError()\n                 */\n                if (Object.keys(masterWriteResult.error).length > 0) {\n                    const conflictWriteFork: BulkWriteRow<RxDocType>[] = [];\n                    const conflictWriteMeta: BulkWriteRowById<RxStorageReplicationMeta> = {};\n                    await Promise.all(\n                        Object\n                            .entries(masterWriteResult.error)\n                            .map(async ([docId, error]) => {\n                                const resolved = await resolveConflictError(\n                                    state.input.conflictHandler,\n                                    error\n                                );\n                                if (resolved) {\n                                    conflictWriteFork.push({\n                                        previous: error.writeRow.document,\n                                        document: resolved\n                                    });\n                                }\n                                const assumedMasterDoc = assumedMasterState[docId];\n                                conflictWriteMeta[docId] = getMetaWriteRow(\n                                    state,\n                                    ensureNotFalsy(error.documentInDb),\n                                    assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined\n                                );\n                            })\n                    );\n\n                    if (conflictWriteFork.length > 0) {\n                        hadConflictWrites = true;\n\n                        const forkWriteResult = await state.input.forkInstance.bulkWrite(conflictWriteFork);\n                        /**\n                         * Errors in the forkWriteResult must not be handled\n                         * because they have been caused by a write to the forkInstance\n                         * in between which will anyway trigger a new upstream cycle\n                         * that will then resolved the conflict again.\n                         */\n                        const useMetaWrites: BulkWriteRow<RxStorageReplicationMeta>[] = [];\n                        Object\n                            .keys(forkWriteResult.success)\n                            .forEach((docId) => {\n                                useMetaWrites.push(\n                                    conflictWriteMeta[docId]\n                                );\n                            });\n                        if (useMetaWrites.length > 0) {\n                            await state.input.metaInstance.bulkWrite(useMetaWrites);\n                        }\n                        // TODO what to do with conflicts while writing to the metaInstance?\n                    }\n                }\n            }));\n        }\n\n        await writeToMasterQueue;\n\n        await setCheckpoint(\n            state,\n            'up',\n            lastCheckpointDoc\n        );\n        if (\n            !hadConflictWrites &&\n            !state.firstSyncDone.up.getValue()\n        ) {\n            state.firstSyncDone.up.next(true);\n        }\n    }\n}\n\n\nexport async function getLastCheckpointDoc<RxDocType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    direction: RxStorageReplicationDirection\n): Promise<undefined | {\n    checkpoint: any;\n    checkpointDoc?: RxDocumentData<RxStorageReplicationMeta>;\n}> {\n    const checkpointDocId = getComposedPrimaryKeyOfDocumentData(\n        RX_REPLICATION_META_INSTANCE_SCHEMA,\n        {\n            isCheckpoint: '1',\n            itemId: direction,\n            replicationIdentifier: state.checkpointKey\n        }\n    );\n    const checkpointResult = await state.input.metaInstance.findDocumentsById(\n        [\n            checkpointDocId\n        ],\n        false\n    );\n\n    const checkpointDoc = checkpointResult[checkpointDocId];\n    if (checkpointDoc) {\n        return {\n            checkpoint: checkpointDoc.data,\n            checkpointDoc\n        };\n    } else {\n        return undefined;\n    }\n}\n\n\nexport function getCheckpointKey<RxDocType>(\n    input: RxStorageInstanceReplicationInput<RxDocType>\n): string {\n    const hash = fastUnsecureHash([\n        input.identifier,\n        input.masterInstance.storage.name,\n        input.masterInstance.databaseName,\n        input.masterInstance.collectionName,\n        input.forkInstance.storage.name,\n        input.forkInstance.databaseName,\n        input.forkInstance.collectionName\n    ].join('||'));\n    return 'rx-storage-replication-' + hash;\n}\n\n\n/**\n * Resolves a conflict error.\n * Returns the resolved document that must be written to the fork.\n * Then the new document state can be pushed upstream.\n * If document is not in conflict, returns undefined.\n * If error is non-409, it throws an error.\n * Conflicts are only solved in the upstream, never in the downstream.\n */\nexport async function resolveConflictError<RxDocType>(\n    conflictHandler: RxConflictHandler<RxDocType>,\n    error: RxStorageBulkWriteError<RxDocType>\n): Promise<RxDocumentData<RxDocType> | undefined> {\n    if (error.status !== 409) {\n        /**\n         * If this ever happens,\n         * make a PR with a unit test to reproduce it.\n         */\n        throw new Error('Non conflict error');\n    }\n    const documentInDb = ensureNotFalsy(error.documentInDb);\n    if (documentInDb._rev === error.writeRow.document._rev) {\n        /**\n         * Documents are equal,\n         * so this is not a conflict -> do nothing.\n         */\n        return undefined;\n    } else {\n        /**\n         * We have a conflict, resolve it!\n         */\n        const conflictHandlerOutput = await conflictHandler({\n            assumedMasterState: error.writeRow.previous,\n            newDocumentState: error.writeRow.document,\n            realMasterState: documentInDb\n        }, 'rx-storage-replication');\n\n        const resolvedDoc: RxDocumentData<RxDocType> = Object.assign(\n            {},\n            conflictHandlerOutput.documentData,\n            {\n                /**\n                 * Because the resolved conflict is written to the fork,\n                 * we have to keep/update the forks _meta data, not the masters.\n                 */\n                _meta: flatClone(error.writeRow.document._meta),\n                _rev: getDefaultRevision(),\n                _attachments: flatClone(error.writeRow.document._attachments)\n            }\n        );\n        resolvedDoc._meta.lwt = now();\n        resolvedDoc._rev = createRevision(resolvedDoc, error.writeRow.document);\n        return resolvedDoc;\n    }\n}\n\n\nexport async function setCheckpoint<RxDocType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    direction: RxStorageReplicationDirection,\n    checkpointDoc?: RxDocumentData<RxStorageReplicationMeta>\n) {\n    const checkpoint = state.lastCheckpoint[direction];\n    if (\n        checkpoint &&\n        /**\n         * If the replication is already canceled,\n         * we do not write a checkpoint\n         * because that could mean we write a checkpoint\n         * for data that has been fetched from the master\n         * but not been written to the child.\n         */\n        !state.canceled.getValue() &&\n        /**\n         * Only write checkpoint if it is different from before\n         * to have less writes to the storage.\n         */\n        (\n            !checkpointDoc ||\n            JSON.stringify(checkpointDoc.data) !== JSON.stringify(checkpoint)\n        )\n    ) {\n        const newDoc: RxDocumentData<RxStorageReplicationMeta> = {\n            id: '',\n            isCheckpoint: '1',\n            itemId: direction,\n            replicationIdentifier: state.checkpointKey,\n            _deleted: false,\n            _attachments: {},\n            data: checkpoint,\n            _meta: {\n                lwt: now()\n            },\n            _rev: getDefaultRevision()\n        };\n        newDoc.id = getComposedPrimaryKeyOfDocumentData(\n            RX_REPLICATION_META_INSTANCE_SCHEMA,\n            newDoc\n        );\n        newDoc._rev = createRevision(newDoc, checkpointDoc);\n        await state.input.metaInstance.bulkWrite([{\n            previous: checkpointDoc,\n            document: newDoc\n        }]);\n    }\n}\n\n\nexport async function awaitRxStorageReplicationFirstInSync(\n    state: RxStorageInstanceReplicationState<any>\n) {\n    return firstValueFrom(\n        combineLatest([\n            state.firstSyncDone.down.pipe(\n                filter(v => !!v)\n            ),\n            state.firstSyncDone.up.pipe(\n                filter(v => !!v)\n            )\n        ])\n    );\n}\n\nexport async function awaitRxStorageReplicationIdle(\n    state: RxStorageInstanceReplicationState<any>\n) {\n    await awaitRxStorageReplicationFirstInSync(state);\n    while (true) {\n        const { down, up } = state.streamQueue;\n        await Promise.all([\n            up,\n            down\n        ]);\n        /**\n         * If the Promises have not been reasigned\n         * after awaiting them, we know that the replication\n         * is in idle state at this point in time.\n         */\n        if (\n            down === state.streamQueue.down &&\n            up === state.streamQueue.up\n        ) {\n            return;\n        }\n    }\n}\n\nexport async function getAssumedMasterState<RxDocType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    docIds: string[]\n): Promise<{\n    [docId: string]: {\n        docData: RxDocumentData<RxDocType>;\n        metaDocument: RxDocumentData<RxStorageReplicationMeta>\n    }\n}> {\n    const metaDocs = await state.input.metaInstance.findDocumentsById(\n        docIds.map(docId => {\n            const useId = getComposedPrimaryKeyOfDocumentData(\n                RX_REPLICATION_META_INSTANCE_SCHEMA,\n                {\n                    itemId: docId,\n                    replicationIdentifier: state.checkpointKey,\n                    isCheckpoint: '0'\n                }\n            );\n            return useId;\n        }),\n        true\n    );\n\n    const ret: {\n        [docId: string]: {\n            docData: RxDocumentData<RxDocType>;\n            metaDocument: RxDocumentData<RxStorageReplicationMeta>\n        }\n    } = {};\n    Object\n        .values(metaDocs)\n        .forEach((metaDoc) => {\n            ret[metaDoc.itemId] = {\n                docData: metaDoc.data,\n                metaDocument: metaDoc\n            };\n        });\n\n    return ret;\n}\n\n\nexport function getMetaWriteRow<RxDocType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    newMasterDocState: RxDocumentData<RxDocType>,\n    previous?: RxDocumentData<RxStorageReplicationMeta>\n): BulkWriteRow<RxStorageReplicationMeta> {\n    const docId: string = (newMasterDocState as any)[state.primaryPath];\n    const newMeta: RxDocumentData<RxStorageReplicationMeta> = previous ? flatCloneDocWithMeta(\n        previous\n    ) : {\n        id: '',\n        replicationIdentifier: state.checkpointKey,\n        isCheckpoint: '0',\n        itemId: docId,\n        data: newMasterDocState,\n        _attachments: {},\n        _deleted: false,\n        _rev: getDefaultRevision(),\n        _meta: {\n            lwt: 0\n        }\n    };\n    newMeta.data = newMasterDocState;\n    newMeta._rev = createRevision(newMeta, previous);\n    newMeta._meta.lwt = now();\n    newMeta.id = getComposedPrimaryKeyOfDocumentData(\n        RX_REPLICATION_META_INSTANCE_SCHEMA,\n        newMeta\n    );\n    return {\n        previous,\n        document: newMeta\n    };\n}\n\nexport const defaultConflictHandler: RxConflictHandler<any> = async function (\n    i: RxConflictHandlerInput<any>,\n    _context: string\n): Promise<RxConflictHandlerOutput<any>> {\n    /**\n     * The default conflict handler will always\n     * drop the fork state and use the master state instead.\n     */\n    return {\n        documentData: i.realMasterState\n    };\n}\n"],"mappings":"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"}